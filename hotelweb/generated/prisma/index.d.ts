
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Hotel
 * 
 */
export type Hotel = $Result.DefaultSelection<Prisma.$HotelPayload>
/**
 * Model RoomType
 * 
 */
export type RoomType = $Result.DefaultSelection<Prisma.$RoomTypePayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model BookingStatus
 * 
 */
export type BookingStatus = $Result.DefaultSelection<Prisma.$BookingStatusPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model BookingService
 * 
 */
export type BookingService = $Result.DefaultSelection<Prisma.$BookingServicePayload>
/**
 * Model EmployeeRole
 * 
 */
export type EmployeeRole = $Result.DefaultSelection<Prisma.$EmployeeRolePayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Promotion
 * 
 */
export type Promotion = $Result.DefaultSelection<Prisma.$PromotionPayload>
/**
 * Model RoomAmenity
 * 
 */
export type RoomAmenity = $Result.DefaultSelection<Prisma.$RoomAmenityPayload>
/**
 * Model HotelAmenity
 * 
 */
export type HotelAmenity = $Result.DefaultSelection<Prisma.$HotelAmenityPayload>
/**
 * Model HotelPolicy
 * 
 */
export type HotelPolicy = $Result.DefaultSelection<Prisma.$HotelPolicyPayload>
/**
 * Model PromotionApplied
 * 
 */
export type PromotionApplied = $Result.DefaultSelection<Prisma.$PromotionAppliedPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model HotelEvent
 * 
 */
export type HotelEvent = $Result.DefaultSelection<Prisma.$HotelEventPayload>
/**
 * Model SystemNotification
 * 
 */
export type SystemNotification = $Result.DefaultSelection<Prisma.$SystemNotificationPayload>
/**
 * Model RoomAmenitiesLink
 * 
 */
export type RoomAmenitiesLink = $Result.DefaultSelection<Prisma.$RoomAmenitiesLinkPayload>
/**
 * Model HotelAmenitiesLink
 * 
 */
export type HotelAmenitiesLink = $Result.DefaultSelection<Prisma.$HotelAmenitiesLinkPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Customers
 * const customers = await prisma.customer.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Customers
   * const customers = await prisma.customer.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotel`: Exposes CRUD operations for the **Hotel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hotels
    * const hotels = await prisma.hotel.findMany()
    * ```
    */
  get hotel(): Prisma.HotelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roomType`: Exposes CRUD operations for the **RoomType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomTypes
    * const roomTypes = await prisma.roomType.findMany()
    * ```
    */
  get roomType(): Prisma.RoomTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingStatus`: Exposes CRUD operations for the **BookingStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingStatuses
    * const bookingStatuses = await prisma.bookingStatus.findMany()
    * ```
    */
  get bookingStatus(): Prisma.BookingStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingService`: Exposes CRUD operations for the **BookingService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingServices
    * const bookingServices = await prisma.bookingService.findMany()
    * ```
    */
  get bookingService(): Prisma.BookingServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeRole`: Exposes CRUD operations for the **EmployeeRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeRoles
    * const employeeRoles = await prisma.employeeRole.findMany()
    * ```
    */
  get employeeRole(): Prisma.EmployeeRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promotion`: Exposes CRUD operations for the **Promotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promotions
    * const promotions = await prisma.promotion.findMany()
    * ```
    */
  get promotion(): Prisma.PromotionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roomAmenity`: Exposes CRUD operations for the **RoomAmenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomAmenities
    * const roomAmenities = await prisma.roomAmenity.findMany()
    * ```
    */
  get roomAmenity(): Prisma.RoomAmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelAmenity`: Exposes CRUD operations for the **HotelAmenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelAmenities
    * const hotelAmenities = await prisma.hotelAmenity.findMany()
    * ```
    */
  get hotelAmenity(): Prisma.HotelAmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelPolicy`: Exposes CRUD operations for the **HotelPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelPolicies
    * const hotelPolicies = await prisma.hotelPolicy.findMany()
    * ```
    */
  get hotelPolicy(): Prisma.HotelPolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promotionApplied`: Exposes CRUD operations for the **PromotionApplied** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromotionApplieds
    * const promotionApplieds = await prisma.promotionApplied.findMany()
    * ```
    */
  get promotionApplied(): Prisma.PromotionAppliedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelEvent`: Exposes CRUD operations for the **HotelEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelEvents
    * const hotelEvents = await prisma.hotelEvent.findMany()
    * ```
    */
  get hotelEvent(): Prisma.HotelEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemNotification`: Exposes CRUD operations for the **SystemNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemNotifications
    * const systemNotifications = await prisma.systemNotification.findMany()
    * ```
    */
  get systemNotification(): Prisma.SystemNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roomAmenitiesLink`: Exposes CRUD operations for the **RoomAmenitiesLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomAmenitiesLinks
    * const roomAmenitiesLinks = await prisma.roomAmenitiesLink.findMany()
    * ```
    */
  get roomAmenitiesLink(): Prisma.RoomAmenitiesLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelAmenitiesLink`: Exposes CRUD operations for the **HotelAmenitiesLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelAmenitiesLinks
    * const hotelAmenitiesLinks = await prisma.hotelAmenitiesLink.findMany()
    * ```
    */
  get hotelAmenitiesLink(): Prisma.HotelAmenitiesLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Customer: 'Customer',
    Hotel: 'Hotel',
    RoomType: 'RoomType',
    Room: 'Room',
    BookingStatus: 'BookingStatus',
    Booking: 'Booking',
    Service: 'Service',
    BookingService: 'BookingService',
    EmployeeRole: 'EmployeeRole',
    Department: 'Department',
    Employee: 'Employee',
    Payment: 'Payment',
    Review: 'Review',
    Promotion: 'Promotion',
    RoomAmenity: 'RoomAmenity',
    HotelAmenity: 'HotelAmenity',
    HotelPolicy: 'HotelPolicy',
    PromotionApplied: 'PromotionApplied',
    ActivityLog: 'ActivityLog',
    HotelEvent: 'HotelEvent',
    SystemNotification: 'SystemNotification',
    RoomAmenitiesLink: 'RoomAmenitiesLink',
    HotelAmenitiesLink: 'HotelAmenitiesLink',
    User: 'User'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "customer" | "hotel" | "roomType" | "room" | "bookingStatus" | "booking" | "service" | "bookingService" | "employeeRole" | "department" | "employee" | "payment" | "review" | "promotion" | "roomAmenity" | "hotelAmenity" | "hotelPolicy" | "promotionApplied" | "activityLog" | "hotelEvent" | "systemNotification" | "roomAmenitiesLink" | "hotelAmenitiesLink" | "user"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Hotel: {
        payload: Prisma.$HotelPayload<ExtArgs>
        fields: Prisma.HotelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          findFirst: {
            args: Prisma.HotelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          findMany: {
            args: Prisma.HotelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>[]
          }
          create: {
            args: Prisma.HotelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          createMany: {
            args: Prisma.HotelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HotelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          update: {
            args: Prisma.HotelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          deleteMany: {
            args: Prisma.HotelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          aggregate: {
            args: Prisma.HotelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotel>
          }
          groupBy: {
            args: Prisma.HotelGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelCountArgs<ExtArgs>
            result: $Utils.Optional<HotelCountAggregateOutputType> | number
          }
        }
      }
      RoomType: {
        payload: Prisma.$RoomTypePayload<ExtArgs>
        fields: Prisma.RoomTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          findFirst: {
            args: Prisma.RoomTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          findMany: {
            args: Prisma.RoomTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>[]
          }
          create: {
            args: Prisma.RoomTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          createMany: {
            args: Prisma.RoomTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoomTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          update: {
            args: Prisma.RoomTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          deleteMany: {
            args: Prisma.RoomTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          aggregate: {
            args: Prisma.RoomTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomType>
          }
          groupBy: {
            args: Prisma.RoomTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomTypeCountArgs<ExtArgs>
            result: $Utils.Optional<RoomTypeCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      BookingStatus: {
        payload: Prisma.$BookingStatusPayload<ExtArgs>
        fields: Prisma.BookingStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusPayload>
          }
          findFirst: {
            args: Prisma.BookingStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusPayload>
          }
          findMany: {
            args: Prisma.BookingStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusPayload>[]
          }
          create: {
            args: Prisma.BookingStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusPayload>
          }
          createMany: {
            args: Prisma.BookingStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BookingStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusPayload>
          }
          update: {
            args: Prisma.BookingStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusPayload>
          }
          deleteMany: {
            args: Prisma.BookingStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusPayload>
          }
          aggregate: {
            args: Prisma.BookingStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingStatus>
          }
          groupBy: {
            args: Prisma.BookingStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingStatusCountArgs<ExtArgs>
            result: $Utils.Optional<BookingStatusCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      BookingService: {
        payload: Prisma.$BookingServicePayload<ExtArgs>
        fields: Prisma.BookingServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>
          }
          findFirst: {
            args: Prisma.BookingServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>
          }
          findMany: {
            args: Prisma.BookingServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>[]
          }
          create: {
            args: Prisma.BookingServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>
          }
          createMany: {
            args: Prisma.BookingServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BookingServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>
          }
          update: {
            args: Prisma.BookingServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>
          }
          deleteMany: {
            args: Prisma.BookingServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>
          }
          aggregate: {
            args: Prisma.BookingServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingService>
          }
          groupBy: {
            args: Prisma.BookingServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingServiceCountArgs<ExtArgs>
            result: $Utils.Optional<BookingServiceCountAggregateOutputType> | number
          }
        }
      }
      EmployeeRole: {
        payload: Prisma.$EmployeeRolePayload<ExtArgs>
        fields: Prisma.EmployeeRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload>
          }
          findFirst: {
            args: Prisma.EmployeeRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload>
          }
          findMany: {
            args: Prisma.EmployeeRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload>[]
          }
          create: {
            args: Prisma.EmployeeRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload>
          }
          createMany: {
            args: Prisma.EmployeeRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload>
          }
          update: {
            args: Prisma.EmployeeRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload>
          }
          aggregate: {
            args: Prisma.EmployeeRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeRole>
          }
          groupBy: {
            args: Prisma.EmployeeRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeRoleCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeRoleCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Promotion: {
        payload: Prisma.$PromotionPayload<ExtArgs>
        fields: Prisma.PromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findFirst: {
            args: Prisma.PromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findMany: {
            args: Prisma.PromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          create: {
            args: Prisma.PromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          createMany: {
            args: Prisma.PromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          update: {
            args: Prisma.PromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          deleteMany: {
            args: Prisma.PromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          aggregate: {
            args: Prisma.PromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotion>
          }
          groupBy: {
            args: Prisma.PromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionCountAggregateOutputType> | number
          }
        }
      }
      RoomAmenity: {
        payload: Prisma.$RoomAmenityPayload<ExtArgs>
        fields: Prisma.RoomAmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomAmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomAmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>
          }
          findFirst: {
            args: Prisma.RoomAmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomAmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>
          }
          findMany: {
            args: Prisma.RoomAmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>[]
          }
          create: {
            args: Prisma.RoomAmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>
          }
          createMany: {
            args: Prisma.RoomAmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoomAmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>
          }
          update: {
            args: Prisma.RoomAmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>
          }
          deleteMany: {
            args: Prisma.RoomAmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomAmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomAmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>
          }
          aggregate: {
            args: Prisma.RoomAmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomAmenity>
          }
          groupBy: {
            args: Prisma.RoomAmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomAmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomAmenityCountArgs<ExtArgs>
            result: $Utils.Optional<RoomAmenityCountAggregateOutputType> | number
          }
        }
      }
      HotelAmenity: {
        payload: Prisma.$HotelAmenityPayload<ExtArgs>
        fields: Prisma.HotelAmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelAmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelAmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>
          }
          findFirst: {
            args: Prisma.HotelAmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelAmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>
          }
          findMany: {
            args: Prisma.HotelAmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>[]
          }
          create: {
            args: Prisma.HotelAmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>
          }
          createMany: {
            args: Prisma.HotelAmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HotelAmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>
          }
          update: {
            args: Prisma.HotelAmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>
          }
          deleteMany: {
            args: Prisma.HotelAmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelAmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotelAmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>
          }
          aggregate: {
            args: Prisma.HotelAmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelAmenity>
          }
          groupBy: {
            args: Prisma.HotelAmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelAmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelAmenityCountArgs<ExtArgs>
            result: $Utils.Optional<HotelAmenityCountAggregateOutputType> | number
          }
        }
      }
      HotelPolicy: {
        payload: Prisma.$HotelPolicyPayload<ExtArgs>
        fields: Prisma.HotelPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPolicyPayload>
          }
          findFirst: {
            args: Prisma.HotelPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPolicyPayload>
          }
          findMany: {
            args: Prisma.HotelPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPolicyPayload>[]
          }
          create: {
            args: Prisma.HotelPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPolicyPayload>
          }
          createMany: {
            args: Prisma.HotelPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HotelPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPolicyPayload>
          }
          update: {
            args: Prisma.HotelPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPolicyPayload>
          }
          deleteMany: {
            args: Prisma.HotelPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotelPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPolicyPayload>
          }
          aggregate: {
            args: Prisma.HotelPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelPolicy>
          }
          groupBy: {
            args: Prisma.HotelPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<HotelPolicyCountAggregateOutputType> | number
          }
        }
      }
      PromotionApplied: {
        payload: Prisma.$PromotionAppliedPayload<ExtArgs>
        fields: Prisma.PromotionAppliedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionAppliedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionAppliedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionAppliedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionAppliedPayload>
          }
          findFirst: {
            args: Prisma.PromotionAppliedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionAppliedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionAppliedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionAppliedPayload>
          }
          findMany: {
            args: Prisma.PromotionAppliedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionAppliedPayload>[]
          }
          create: {
            args: Prisma.PromotionAppliedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionAppliedPayload>
          }
          createMany: {
            args: Prisma.PromotionAppliedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PromotionAppliedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionAppliedPayload>
          }
          update: {
            args: Prisma.PromotionAppliedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionAppliedPayload>
          }
          deleteMany: {
            args: Prisma.PromotionAppliedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionAppliedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromotionAppliedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionAppliedPayload>
          }
          aggregate: {
            args: Prisma.PromotionAppliedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotionApplied>
          }
          groupBy: {
            args: Prisma.PromotionAppliedGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionAppliedGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionAppliedCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionAppliedCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      HotelEvent: {
        payload: Prisma.$HotelEventPayload<ExtArgs>
        fields: Prisma.HotelEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelEventPayload>
          }
          findFirst: {
            args: Prisma.HotelEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelEventPayload>
          }
          findMany: {
            args: Prisma.HotelEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelEventPayload>[]
          }
          create: {
            args: Prisma.HotelEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelEventPayload>
          }
          createMany: {
            args: Prisma.HotelEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HotelEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelEventPayload>
          }
          update: {
            args: Prisma.HotelEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelEventPayload>
          }
          deleteMany: {
            args: Prisma.HotelEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotelEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelEventPayload>
          }
          aggregate: {
            args: Prisma.HotelEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelEvent>
          }
          groupBy: {
            args: Prisma.HotelEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelEventCountArgs<ExtArgs>
            result: $Utils.Optional<HotelEventCountAggregateOutputType> | number
          }
        }
      }
      SystemNotification: {
        payload: Prisma.$SystemNotificationPayload<ExtArgs>
        fields: Prisma.SystemNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload>
          }
          findFirst: {
            args: Prisma.SystemNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload>
          }
          findMany: {
            args: Prisma.SystemNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload>[]
          }
          create: {
            args: Prisma.SystemNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload>
          }
          createMany: {
            args: Prisma.SystemNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload>
          }
          update: {
            args: Prisma.SystemNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload>
          }
          deleteMany: {
            args: Prisma.SystemNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload>
          }
          aggregate: {
            args: Prisma.SystemNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemNotification>
          }
          groupBy: {
            args: Prisma.SystemNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<SystemNotificationCountAggregateOutputType> | number
          }
        }
      }
      RoomAmenitiesLink: {
        payload: Prisma.$RoomAmenitiesLinkPayload<ExtArgs>
        fields: Prisma.RoomAmenitiesLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomAmenitiesLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenitiesLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomAmenitiesLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenitiesLinkPayload>
          }
          findFirst: {
            args: Prisma.RoomAmenitiesLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenitiesLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomAmenitiesLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenitiesLinkPayload>
          }
          findMany: {
            args: Prisma.RoomAmenitiesLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenitiesLinkPayload>[]
          }
          create: {
            args: Prisma.RoomAmenitiesLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenitiesLinkPayload>
          }
          createMany: {
            args: Prisma.RoomAmenitiesLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoomAmenitiesLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenitiesLinkPayload>
          }
          update: {
            args: Prisma.RoomAmenitiesLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenitiesLinkPayload>
          }
          deleteMany: {
            args: Prisma.RoomAmenitiesLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomAmenitiesLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomAmenitiesLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenitiesLinkPayload>
          }
          aggregate: {
            args: Prisma.RoomAmenitiesLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomAmenitiesLink>
          }
          groupBy: {
            args: Prisma.RoomAmenitiesLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomAmenitiesLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomAmenitiesLinkCountArgs<ExtArgs>
            result: $Utils.Optional<RoomAmenitiesLinkCountAggregateOutputType> | number
          }
        }
      }
      HotelAmenitiesLink: {
        payload: Prisma.$HotelAmenitiesLinkPayload<ExtArgs>
        fields: Prisma.HotelAmenitiesLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelAmenitiesLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenitiesLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelAmenitiesLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenitiesLinkPayload>
          }
          findFirst: {
            args: Prisma.HotelAmenitiesLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenitiesLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelAmenitiesLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenitiesLinkPayload>
          }
          findMany: {
            args: Prisma.HotelAmenitiesLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenitiesLinkPayload>[]
          }
          create: {
            args: Prisma.HotelAmenitiesLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenitiesLinkPayload>
          }
          createMany: {
            args: Prisma.HotelAmenitiesLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HotelAmenitiesLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenitiesLinkPayload>
          }
          update: {
            args: Prisma.HotelAmenitiesLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenitiesLinkPayload>
          }
          deleteMany: {
            args: Prisma.HotelAmenitiesLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelAmenitiesLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotelAmenitiesLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenitiesLinkPayload>
          }
          aggregate: {
            args: Prisma.HotelAmenitiesLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelAmenitiesLink>
          }
          groupBy: {
            args: Prisma.HotelAmenitiesLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelAmenitiesLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelAmenitiesLinkCountArgs<ExtArgs>
            result: $Utils.Optional<HotelAmenitiesLinkCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    customer?: CustomerOmit
    hotel?: HotelOmit
    roomType?: RoomTypeOmit
    room?: RoomOmit
    bookingStatus?: BookingStatusOmit
    booking?: BookingOmit
    service?: ServiceOmit
    bookingService?: BookingServiceOmit
    employeeRole?: EmployeeRoleOmit
    department?: DepartmentOmit
    employee?: EmployeeOmit
    payment?: PaymentOmit
    review?: ReviewOmit
    promotion?: PromotionOmit
    roomAmenity?: RoomAmenityOmit
    hotelAmenity?: HotelAmenityOmit
    hotelPolicy?: HotelPolicyOmit
    promotionApplied?: PromotionAppliedOmit
    activityLog?: ActivityLogOmit
    hotelEvent?: HotelEventOmit
    systemNotification?: SystemNotificationOmit
    roomAmenitiesLink?: RoomAmenitiesLinkOmit
    hotelAmenitiesLink?: HotelAmenitiesLinkOmit
    user?: UserOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    bookings: number
    reviews: number
    activityLogs: number
    notifications: number
    User: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | CustomerCountOutputTypeCountBookingsArgs
    reviews?: boolean | CustomerCountOutputTypeCountReviewsArgs
    activityLogs?: boolean | CustomerCountOutputTypeCountActivityLogsArgs
    notifications?: boolean | CustomerCountOutputTypeCountNotificationsArgs
    User?: boolean | CustomerCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemNotificationWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type HotelCountOutputType
   */

  export type HotelCountOutputType = {
    rooms: number
    reviews: number
    policies: number
    events: number
    amenities: number
  }

  export type HotelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | HotelCountOutputTypeCountRoomsArgs
    reviews?: boolean | HotelCountOutputTypeCountReviewsArgs
    policies?: boolean | HotelCountOutputTypeCountPoliciesArgs
    events?: boolean | HotelCountOutputTypeCountEventsArgs
    amenities?: boolean | HotelCountOutputTypeCountAmenitiesArgs
  }

  // Custom InputTypes
  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCountOutputType
     */
    select?: HotelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelPolicyWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelEventWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountAmenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelAmenitiesLinkWhereInput
  }


  /**
   * Count Type RoomTypeCountOutputType
   */

  export type RoomTypeCountOutputType = {
    rooms: number
  }

  export type RoomTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | RoomTypeCountOutputTypeCountRoomsArgs
  }

  // Custom InputTypes
  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypeCountOutputType
     */
    select?: RoomTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }


  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    bookings: number
    amenities: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | RoomCountOutputTypeCountBookingsArgs
    amenities?: boolean | RoomCountOutputTypeCountAmenitiesArgs
  }

  // Custom InputTypes
  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountAmenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomAmenitiesLinkWhereInput
  }


  /**
   * Count Type BookingStatusCountOutputType
   */

  export type BookingStatusCountOutputType = {
    bookings: number
  }

  export type BookingStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | BookingStatusCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * BookingStatusCountOutputType without action
   */
  export type BookingStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusCountOutputType
     */
    select?: BookingStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingStatusCountOutputType without action
   */
  export type BookingStatusCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    services: number
    payments: number
    promotions: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | BookingCountOutputTypeCountServicesArgs
    payments?: boolean | BookingCountOutputTypeCountPaymentsArgs
    promotions?: boolean | BookingCountOutputTypeCountPromotionsArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingServiceWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPromotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionAppliedWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    bookings: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | ServiceCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingServiceWhereInput
  }


  /**
   * Count Type EmployeeRoleCountOutputType
   */

  export type EmployeeRoleCountOutputType = {
    employees: number
  }

  export type EmployeeRoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | EmployeeRoleCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * EmployeeRoleCountOutputType without action
   */
  export type EmployeeRoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRoleCountOutputType
     */
    select?: EmployeeRoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeRoleCountOutputType without action
   */
  export type EmployeeRoleCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    employees: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | DepartmentCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type PromotionCountOutputType
   */

  export type PromotionCountOutputType = {
    bookings: number
  }

  export type PromotionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | PromotionCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCountOutputType
     */
    select?: PromotionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionAppliedWhereInput
  }


  /**
   * Count Type RoomAmenityCountOutputType
   */

  export type RoomAmenityCountOutputType = {
    rooms: number
  }

  export type RoomAmenityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | RoomAmenityCountOutputTypeCountRoomsArgs
  }

  // Custom InputTypes
  /**
   * RoomAmenityCountOutputType without action
   */
  export type RoomAmenityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenityCountOutputType
     */
    select?: RoomAmenityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomAmenityCountOutputType without action
   */
  export type RoomAmenityCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomAmenitiesLinkWhereInput
  }


  /**
   * Count Type HotelAmenityCountOutputType
   */

  export type HotelAmenityCountOutputType = {
    hotels: number
  }

  export type HotelAmenityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotels?: boolean | HotelAmenityCountOutputTypeCountHotelsArgs
  }

  // Custom InputTypes
  /**
   * HotelAmenityCountOutputType without action
   */
  export type HotelAmenityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenityCountOutputType
     */
    select?: HotelAmenityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelAmenityCountOutputType without action
   */
  export type HotelAmenityCountOutputTypeCountHotelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelAmenitiesLinkWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    name: string | null
    email: string | null
    phone: string | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    bookings?: boolean | Customer$bookingsArgs<ExtArgs>
    reviews?: boolean | Customer$reviewsArgs<ExtArgs>
    activityLogs?: boolean | Customer$activityLogsArgs<ExtArgs>
    notifications?: boolean | Customer$notificationsArgs<ExtArgs>
    User?: boolean | Customer$UserArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>



  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | Customer$bookingsArgs<ExtArgs>
    reviews?: boolean | Customer$reviewsArgs<ExtArgs>
    activityLogs?: boolean | Customer$activityLogsArgs<ExtArgs>
    notifications?: boolean | Customer$notificationsArgs<ExtArgs>
    User?: boolean | Customer$UserArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
      notifications: Prisma.$SystemNotificationPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      email: string | null
      phone: string | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends Customer$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Customer$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activityLogs<T extends Customer$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Customer$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends Customer$UserArgs<ExtArgs> = {}>(args?: Subset<T, Customer$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'Int'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data?: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.bookings
   */
  export type Customer$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Customer.reviews
   */
  export type Customer$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Customer.activityLogs
   */
  export type Customer$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * Customer.notifications
   */
  export type Customer$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    where?: SystemNotificationWhereInput
    orderBy?: SystemNotificationOrderByWithRelationInput | SystemNotificationOrderByWithRelationInput[]
    cursor?: SystemNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemNotificationScalarFieldEnum | SystemNotificationScalarFieldEnum[]
  }

  /**
   * Customer.User
   */
  export type Customer$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Hotel
   */

  export type AggregateHotel = {
    _count: HotelCountAggregateOutputType | null
    _avg: HotelAvgAggregateOutputType | null
    _sum: HotelSumAggregateOutputType | null
    _min: HotelMinAggregateOutputType | null
    _max: HotelMaxAggregateOutputType | null
  }

  export type HotelAvgAggregateOutputType = {
    id: number | null
    rating: number | null
  }

  export type HotelSumAggregateOutputType = {
    id: number | null
    rating: number | null
  }

  export type HotelMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    city: string | null
    rating: number | null
  }

  export type HotelMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    city: string | null
    rating: number | null
  }

  export type HotelCountAggregateOutputType = {
    id: number
    name: number
    address: number
    city: number
    rating: number
    _all: number
  }


  export type HotelAvgAggregateInputType = {
    id?: true
    rating?: true
  }

  export type HotelSumAggregateInputType = {
    id?: true
    rating?: true
  }

  export type HotelMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    rating?: true
  }

  export type HotelMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    rating?: true
  }

  export type HotelCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    rating?: true
    _all?: true
  }

  export type HotelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hotel to aggregate.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hotels
    **/
    _count?: true | HotelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelMaxAggregateInputType
  }

  export type GetHotelAggregateType<T extends HotelAggregateArgs> = {
        [P in keyof T & keyof AggregateHotel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotel[P]>
      : GetScalarType<T[P], AggregateHotel[P]>
  }




  export type HotelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelWhereInput
    orderBy?: HotelOrderByWithAggregationInput | HotelOrderByWithAggregationInput[]
    by: HotelScalarFieldEnum[] | HotelScalarFieldEnum
    having?: HotelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelCountAggregateInputType | true
    _avg?: HotelAvgAggregateInputType
    _sum?: HotelSumAggregateInputType
    _min?: HotelMinAggregateInputType
    _max?: HotelMaxAggregateInputType
  }

  export type HotelGroupByOutputType = {
    id: number
    name: string | null
    address: string | null
    city: string | null
    rating: number | null
    _count: HotelCountAggregateOutputType | null
    _avg: HotelAvgAggregateOutputType | null
    _sum: HotelSumAggregateOutputType | null
    _min: HotelMinAggregateOutputType | null
    _max: HotelMaxAggregateOutputType | null
  }

  type GetHotelGroupByPayload<T extends HotelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelGroupByOutputType[P]>
            : GetScalarType<T[P], HotelGroupByOutputType[P]>
        }
      >
    >


  export type HotelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    rating?: boolean
    rooms?: boolean | Hotel$roomsArgs<ExtArgs>
    reviews?: boolean | Hotel$reviewsArgs<ExtArgs>
    policies?: boolean | Hotel$policiesArgs<ExtArgs>
    events?: boolean | Hotel$eventsArgs<ExtArgs>
    amenities?: boolean | Hotel$amenitiesArgs<ExtArgs>
    _count?: boolean | HotelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotel"]>



  export type HotelSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    rating?: boolean
  }

  export type HotelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "city" | "rating", ExtArgs["result"]["hotel"]>
  export type HotelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | Hotel$roomsArgs<ExtArgs>
    reviews?: boolean | Hotel$reviewsArgs<ExtArgs>
    policies?: boolean | Hotel$policiesArgs<ExtArgs>
    events?: boolean | Hotel$eventsArgs<ExtArgs>
    amenities?: boolean | Hotel$amenitiesArgs<ExtArgs>
    _count?: boolean | HotelCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $HotelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hotel"
    objects: {
      rooms: Prisma.$RoomPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      policies: Prisma.$HotelPolicyPayload<ExtArgs>[]
      events: Prisma.$HotelEventPayload<ExtArgs>[]
      amenities: Prisma.$HotelAmenitiesLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      address: string | null
      city: string | null
      rating: number | null
    }, ExtArgs["result"]["hotel"]>
    composites: {}
  }

  type HotelGetPayload<S extends boolean | null | undefined | HotelDefaultArgs> = $Result.GetResult<Prisma.$HotelPayload, S>

  type HotelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelCountAggregateInputType | true
    }

  export interface HotelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hotel'], meta: { name: 'Hotel' } }
    /**
     * Find zero or one Hotel that matches the filter.
     * @param {HotelFindUniqueArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelFindUniqueArgs>(args: SelectSubset<T, HotelFindUniqueArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hotel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelFindUniqueOrThrowArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hotel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindFirstArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelFindFirstArgs>(args?: SelectSubset<T, HotelFindFirstArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hotel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindFirstOrThrowArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hotels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hotels
     * const hotels = await prisma.hotel.findMany()
     * 
     * // Get first 10 Hotels
     * const hotels = await prisma.hotel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelWithIdOnly = await prisma.hotel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelFindManyArgs>(args?: SelectSubset<T, HotelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hotel.
     * @param {HotelCreateArgs} args - Arguments to create a Hotel.
     * @example
     * // Create one Hotel
     * const Hotel = await prisma.hotel.create({
     *   data: {
     *     // ... data to create a Hotel
     *   }
     * })
     * 
     */
    create<T extends HotelCreateArgs>(args: SelectSubset<T, HotelCreateArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hotels.
     * @param {HotelCreateManyArgs} args - Arguments to create many Hotels.
     * @example
     * // Create many Hotels
     * const hotel = await prisma.hotel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelCreateManyArgs>(args?: SelectSubset<T, HotelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hotel.
     * @param {HotelDeleteArgs} args - Arguments to delete one Hotel.
     * @example
     * // Delete one Hotel
     * const Hotel = await prisma.hotel.delete({
     *   where: {
     *     // ... filter to delete one Hotel
     *   }
     * })
     * 
     */
    delete<T extends HotelDeleteArgs>(args: SelectSubset<T, HotelDeleteArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hotel.
     * @param {HotelUpdateArgs} args - Arguments to update one Hotel.
     * @example
     * // Update one Hotel
     * const hotel = await prisma.hotel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelUpdateArgs>(args: SelectSubset<T, HotelUpdateArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hotels.
     * @param {HotelDeleteManyArgs} args - Arguments to filter Hotels to delete.
     * @example
     * // Delete a few Hotels
     * const { count } = await prisma.hotel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelDeleteManyArgs>(args?: SelectSubset<T, HotelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hotels
     * const hotel = await prisma.hotel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelUpdateManyArgs>(args: SelectSubset<T, HotelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hotel.
     * @param {HotelUpsertArgs} args - Arguments to update or create a Hotel.
     * @example
     * // Update or create a Hotel
     * const hotel = await prisma.hotel.upsert({
     *   create: {
     *     // ... data to create a Hotel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hotel we want to update
     *   }
     * })
     */
    upsert<T extends HotelUpsertArgs>(args: SelectSubset<T, HotelUpsertArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCountArgs} args - Arguments to filter Hotels to count.
     * @example
     * // Count the number of Hotels
     * const count = await prisma.hotel.count({
     *   where: {
     *     // ... the filter for the Hotels we want to count
     *   }
     * })
    **/
    count<T extends HotelCountArgs>(
      args?: Subset<T, HotelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hotel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelAggregateArgs>(args: Subset<T, HotelAggregateArgs>): Prisma.PrismaPromise<GetHotelAggregateType<T>>

    /**
     * Group by Hotel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelGroupByArgs['orderBy'] }
        : { orderBy?: HotelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hotel model
   */
  readonly fields: HotelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hotel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rooms<T extends Hotel$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Hotel$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    policies<T extends Hotel$policiesArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$policiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends Hotel$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    amenities<T extends Hotel$amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelAmenitiesLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hotel model
   */
  interface HotelFieldRefs {
    readonly id: FieldRef<"Hotel", 'Int'>
    readonly name: FieldRef<"Hotel", 'String'>
    readonly address: FieldRef<"Hotel", 'String'>
    readonly city: FieldRef<"Hotel", 'String'>
    readonly rating: FieldRef<"Hotel", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Hotel findUnique
   */
  export type HotelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel findUniqueOrThrow
   */
  export type HotelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel findFirst
   */
  export type HotelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hotels.
     */
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel findFirstOrThrow
   */
  export type HotelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hotels.
     */
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel findMany
   */
  export type HotelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotels to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel create
   */
  export type HotelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The data needed to create a Hotel.
     */
    data?: XOR<HotelCreateInput, HotelUncheckedCreateInput>
  }

  /**
   * Hotel createMany
   */
  export type HotelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hotels.
     */
    data: HotelCreateManyInput | HotelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hotel update
   */
  export type HotelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The data needed to update a Hotel.
     */
    data: XOR<HotelUpdateInput, HotelUncheckedUpdateInput>
    /**
     * Choose, which Hotel to update.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel updateMany
   */
  export type HotelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hotels.
     */
    data: XOR<HotelUpdateManyMutationInput, HotelUncheckedUpdateManyInput>
    /**
     * Filter which Hotels to update
     */
    where?: HotelWhereInput
    /**
     * Limit how many Hotels to update.
     */
    limit?: number
  }

  /**
   * Hotel upsert
   */
  export type HotelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The filter to search for the Hotel to update in case it exists.
     */
    where: HotelWhereUniqueInput
    /**
     * In case the Hotel found by the `where` argument doesn't exist, create a new Hotel with this data.
     */
    create: XOR<HotelCreateInput, HotelUncheckedCreateInput>
    /**
     * In case the Hotel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelUpdateInput, HotelUncheckedUpdateInput>
  }

  /**
   * Hotel delete
   */
  export type HotelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter which Hotel to delete.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel deleteMany
   */
  export type HotelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hotels to delete
     */
    where?: HotelWhereInput
    /**
     * Limit how many Hotels to delete.
     */
    limit?: number
  }

  /**
   * Hotel.rooms
   */
  export type Hotel$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Hotel.reviews
   */
  export type Hotel$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Hotel.policies
   */
  export type Hotel$policiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPolicy
     */
    select?: HotelPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPolicy
     */
    omit?: HotelPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPolicyInclude<ExtArgs> | null
    where?: HotelPolicyWhereInput
    orderBy?: HotelPolicyOrderByWithRelationInput | HotelPolicyOrderByWithRelationInput[]
    cursor?: HotelPolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelPolicyScalarFieldEnum | HotelPolicyScalarFieldEnum[]
  }

  /**
   * Hotel.events
   */
  export type Hotel$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelEvent
     */
    select?: HotelEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelEvent
     */
    omit?: HotelEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelEventInclude<ExtArgs> | null
    where?: HotelEventWhereInput
    orderBy?: HotelEventOrderByWithRelationInput | HotelEventOrderByWithRelationInput[]
    cursor?: HotelEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelEventScalarFieldEnum | HotelEventScalarFieldEnum[]
  }

  /**
   * Hotel.amenities
   */
  export type Hotel$amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenitiesLink
     */
    select?: HotelAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenitiesLink
     */
    omit?: HotelAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenitiesLinkInclude<ExtArgs> | null
    where?: HotelAmenitiesLinkWhereInput
    orderBy?: HotelAmenitiesLinkOrderByWithRelationInput | HotelAmenitiesLinkOrderByWithRelationInput[]
    cursor?: HotelAmenitiesLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelAmenitiesLinkScalarFieldEnum | HotelAmenitiesLinkScalarFieldEnum[]
  }

  /**
   * Hotel without action
   */
  export type HotelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
  }


  /**
   * Model RoomType
   */

  export type AggregateRoomType = {
    _count: RoomTypeCountAggregateOutputType | null
    _avg: RoomTypeAvgAggregateOutputType | null
    _sum: RoomTypeSumAggregateOutputType | null
    _min: RoomTypeMinAggregateOutputType | null
    _max: RoomTypeMaxAggregateOutputType | null
  }

  export type RoomTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type RoomTypeSumAggregateOutputType = {
    id: number | null
  }

  export type RoomTypeMinAggregateOutputType = {
    id: number | null
    typeName: string | null
    description: string | null
  }

  export type RoomTypeMaxAggregateOutputType = {
    id: number | null
    typeName: string | null
    description: string | null
  }

  export type RoomTypeCountAggregateOutputType = {
    id: number
    typeName: number
    description: number
    _all: number
  }


  export type RoomTypeAvgAggregateInputType = {
    id?: true
  }

  export type RoomTypeSumAggregateInputType = {
    id?: true
  }

  export type RoomTypeMinAggregateInputType = {
    id?: true
    typeName?: true
    description?: true
  }

  export type RoomTypeMaxAggregateInputType = {
    id?: true
    typeName?: true
    description?: true
  }

  export type RoomTypeCountAggregateInputType = {
    id?: true
    typeName?: true
    description?: true
    _all?: true
  }

  export type RoomTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomType to aggregate.
     */
    where?: RoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypeOrderByWithRelationInput | RoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomTypes
    **/
    _count?: true | RoomTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomTypeMaxAggregateInputType
  }

  export type GetRoomTypeAggregateType<T extends RoomTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomType[P]>
      : GetScalarType<T[P], AggregateRoomType[P]>
  }




  export type RoomTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomTypeWhereInput
    orderBy?: RoomTypeOrderByWithAggregationInput | RoomTypeOrderByWithAggregationInput[]
    by: RoomTypeScalarFieldEnum[] | RoomTypeScalarFieldEnum
    having?: RoomTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomTypeCountAggregateInputType | true
    _avg?: RoomTypeAvgAggregateInputType
    _sum?: RoomTypeSumAggregateInputType
    _min?: RoomTypeMinAggregateInputType
    _max?: RoomTypeMaxAggregateInputType
  }

  export type RoomTypeGroupByOutputType = {
    id: number
    typeName: string | null
    description: string | null
    _count: RoomTypeCountAggregateOutputType | null
    _avg: RoomTypeAvgAggregateOutputType | null
    _sum: RoomTypeSumAggregateOutputType | null
    _min: RoomTypeMinAggregateOutputType | null
    _max: RoomTypeMaxAggregateOutputType | null
  }

  type GetRoomTypeGroupByPayload<T extends RoomTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomTypeGroupByOutputType[P]>
            : GetScalarType<T[P], RoomTypeGroupByOutputType[P]>
        }
      >
    >


  export type RoomTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    typeName?: boolean
    description?: boolean
    rooms?: boolean | RoomType$roomsArgs<ExtArgs>
    _count?: boolean | RoomTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomType"]>



  export type RoomTypeSelectScalar = {
    id?: boolean
    typeName?: boolean
    description?: boolean
  }

  export type RoomTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "typeName" | "description", ExtArgs["result"]["roomType"]>
  export type RoomTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | RoomType$roomsArgs<ExtArgs>
    _count?: boolean | RoomTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RoomTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomType"
    objects: {
      rooms: Prisma.$RoomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      typeName: string | null
      description: string | null
    }, ExtArgs["result"]["roomType"]>
    composites: {}
  }

  type RoomTypeGetPayload<S extends boolean | null | undefined | RoomTypeDefaultArgs> = $Result.GetResult<Prisma.$RoomTypePayload, S>

  type RoomTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomTypeCountAggregateInputType | true
    }

  export interface RoomTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomType'], meta: { name: 'RoomType' } }
    /**
     * Find zero or one RoomType that matches the filter.
     * @param {RoomTypeFindUniqueArgs} args - Arguments to find a RoomType
     * @example
     * // Get one RoomType
     * const roomType = await prisma.roomType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomTypeFindUniqueArgs>(args: SelectSubset<T, RoomTypeFindUniqueArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoomType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomTypeFindUniqueOrThrowArgs} args - Arguments to find a RoomType
     * @example
     * // Get one RoomType
     * const roomType = await prisma.roomType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeFindFirstArgs} args - Arguments to find a RoomType
     * @example
     * // Get one RoomType
     * const roomType = await prisma.roomType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomTypeFindFirstArgs>(args?: SelectSubset<T, RoomTypeFindFirstArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeFindFirstOrThrowArgs} args - Arguments to find a RoomType
     * @example
     * // Get one RoomType
     * const roomType = await prisma.roomType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoomTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomTypes
     * const roomTypes = await prisma.roomType.findMany()
     * 
     * // Get first 10 RoomTypes
     * const roomTypes = await prisma.roomType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomTypeWithIdOnly = await prisma.roomType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomTypeFindManyArgs>(args?: SelectSubset<T, RoomTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoomType.
     * @param {RoomTypeCreateArgs} args - Arguments to create a RoomType.
     * @example
     * // Create one RoomType
     * const RoomType = await prisma.roomType.create({
     *   data: {
     *     // ... data to create a RoomType
     *   }
     * })
     * 
     */
    create<T extends RoomTypeCreateArgs>(args: SelectSubset<T, RoomTypeCreateArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoomTypes.
     * @param {RoomTypeCreateManyArgs} args - Arguments to create many RoomTypes.
     * @example
     * // Create many RoomTypes
     * const roomType = await prisma.roomType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomTypeCreateManyArgs>(args?: SelectSubset<T, RoomTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoomType.
     * @param {RoomTypeDeleteArgs} args - Arguments to delete one RoomType.
     * @example
     * // Delete one RoomType
     * const RoomType = await prisma.roomType.delete({
     *   where: {
     *     // ... filter to delete one RoomType
     *   }
     * })
     * 
     */
    delete<T extends RoomTypeDeleteArgs>(args: SelectSubset<T, RoomTypeDeleteArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoomType.
     * @param {RoomTypeUpdateArgs} args - Arguments to update one RoomType.
     * @example
     * // Update one RoomType
     * const roomType = await prisma.roomType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomTypeUpdateArgs>(args: SelectSubset<T, RoomTypeUpdateArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoomTypes.
     * @param {RoomTypeDeleteManyArgs} args - Arguments to filter RoomTypes to delete.
     * @example
     * // Delete a few RoomTypes
     * const { count } = await prisma.roomType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomTypeDeleteManyArgs>(args?: SelectSubset<T, RoomTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomTypes
     * const roomType = await prisma.roomType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomTypeUpdateManyArgs>(args: SelectSubset<T, RoomTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomType.
     * @param {RoomTypeUpsertArgs} args - Arguments to update or create a RoomType.
     * @example
     * // Update or create a RoomType
     * const roomType = await prisma.roomType.upsert({
     *   create: {
     *     // ... data to create a RoomType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomType we want to update
     *   }
     * })
     */
    upsert<T extends RoomTypeUpsertArgs>(args: SelectSubset<T, RoomTypeUpsertArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoomTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeCountArgs} args - Arguments to filter RoomTypes to count.
     * @example
     * // Count the number of RoomTypes
     * const count = await prisma.roomType.count({
     *   where: {
     *     // ... the filter for the RoomTypes we want to count
     *   }
     * })
    **/
    count<T extends RoomTypeCountArgs>(
      args?: Subset<T, RoomTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomTypeAggregateArgs>(args: Subset<T, RoomTypeAggregateArgs>): Prisma.PrismaPromise<GetRoomTypeAggregateType<T>>

    /**
     * Group by RoomType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomTypeGroupByArgs['orderBy'] }
        : { orderBy?: RoomTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomType model
   */
  readonly fields: RoomTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rooms<T extends RoomType$roomsArgs<ExtArgs> = {}>(args?: Subset<T, RoomType$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomType model
   */
  interface RoomTypeFieldRefs {
    readonly id: FieldRef<"RoomType", 'Int'>
    readonly typeName: FieldRef<"RoomType", 'String'>
    readonly description: FieldRef<"RoomType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RoomType findUnique
   */
  export type RoomTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomType to fetch.
     */
    where: RoomTypeWhereUniqueInput
  }

  /**
   * RoomType findUniqueOrThrow
   */
  export type RoomTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomType to fetch.
     */
    where: RoomTypeWhereUniqueInput
  }

  /**
   * RoomType findFirst
   */
  export type RoomTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomType to fetch.
     */
    where?: RoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypeOrderByWithRelationInput | RoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomTypes.
     */
    cursor?: RoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomTypes.
     */
    distinct?: RoomTypeScalarFieldEnum | RoomTypeScalarFieldEnum[]
  }

  /**
   * RoomType findFirstOrThrow
   */
  export type RoomTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomType to fetch.
     */
    where?: RoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypeOrderByWithRelationInput | RoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomTypes.
     */
    cursor?: RoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomTypes.
     */
    distinct?: RoomTypeScalarFieldEnum | RoomTypeScalarFieldEnum[]
  }

  /**
   * RoomType findMany
   */
  export type RoomTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomTypes to fetch.
     */
    where?: RoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypeOrderByWithRelationInput | RoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomTypes.
     */
    cursor?: RoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    distinct?: RoomTypeScalarFieldEnum | RoomTypeScalarFieldEnum[]
  }

  /**
   * RoomType create
   */
  export type RoomTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomType.
     */
    data?: XOR<RoomTypeCreateInput, RoomTypeUncheckedCreateInput>
  }

  /**
   * RoomType createMany
   */
  export type RoomTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomTypes.
     */
    data: RoomTypeCreateManyInput | RoomTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoomType update
   */
  export type RoomTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomType.
     */
    data: XOR<RoomTypeUpdateInput, RoomTypeUncheckedUpdateInput>
    /**
     * Choose, which RoomType to update.
     */
    where: RoomTypeWhereUniqueInput
  }

  /**
   * RoomType updateMany
   */
  export type RoomTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomTypes.
     */
    data: XOR<RoomTypeUpdateManyMutationInput, RoomTypeUncheckedUpdateManyInput>
    /**
     * Filter which RoomTypes to update
     */
    where?: RoomTypeWhereInput
    /**
     * Limit how many RoomTypes to update.
     */
    limit?: number
  }

  /**
   * RoomType upsert
   */
  export type RoomTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomType to update in case it exists.
     */
    where: RoomTypeWhereUniqueInput
    /**
     * In case the RoomType found by the `where` argument doesn't exist, create a new RoomType with this data.
     */
    create: XOR<RoomTypeCreateInput, RoomTypeUncheckedCreateInput>
    /**
     * In case the RoomType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomTypeUpdateInput, RoomTypeUncheckedUpdateInput>
  }

  /**
   * RoomType delete
   */
  export type RoomTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter which RoomType to delete.
     */
    where: RoomTypeWhereUniqueInput
  }

  /**
   * RoomType deleteMany
   */
  export type RoomTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomTypes to delete
     */
    where?: RoomTypeWhereInput
    /**
     * Limit how many RoomTypes to delete.
     */
    limit?: number
  }

  /**
   * RoomType.rooms
   */
  export type RoomType$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * RoomType without action
   */
  export type RoomTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomAvgAggregateOutputType = {
    id: number | null
    hotelId: number | null
    roomTypeId: number | null
    price: Decimal | null
  }

  export type RoomSumAggregateOutputType = {
    id: number | null
    hotelId: number | null
    roomTypeId: number | null
    price: Decimal | null
  }

  export type RoomMinAggregateOutputType = {
    id: number | null
    hotelId: number | null
    roomTypeId: number | null
    price: Decimal | null
    availability: boolean | null
  }

  export type RoomMaxAggregateOutputType = {
    id: number | null
    hotelId: number | null
    roomTypeId: number | null
    price: Decimal | null
    availability: boolean | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    hotelId: number
    roomTypeId: number
    price: number
    availability: number
    _all: number
  }


  export type RoomAvgAggregateInputType = {
    id?: true
    hotelId?: true
    roomTypeId?: true
    price?: true
  }

  export type RoomSumAggregateInputType = {
    id?: true
    hotelId?: true
    roomTypeId?: true
    price?: true
  }

  export type RoomMinAggregateInputType = {
    id?: true
    hotelId?: true
    roomTypeId?: true
    price?: true
    availability?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    hotelId?: true
    roomTypeId?: true
    price?: true
    availability?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    hotelId?: true
    roomTypeId?: true
    price?: true
    availability?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _avg?: RoomAvgAggregateInputType
    _sum?: RoomSumAggregateInputType
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: number
    hotelId: number | null
    roomTypeId: number | null
    price: Decimal | null
    availability: boolean | null
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    roomTypeId?: boolean
    price?: boolean
    availability?: boolean
    hotel?: boolean | Room$hotelArgs<ExtArgs>
    roomType?: boolean | Room$roomTypeArgs<ExtArgs>
    bookings?: boolean | Room$bookingsArgs<ExtArgs>
    amenities?: boolean | Room$amenitiesArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>



  export type RoomSelectScalar = {
    id?: boolean
    hotelId?: boolean
    roomTypeId?: boolean
    price?: boolean
    availability?: boolean
  }

  export type RoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hotelId" | "roomTypeId" | "price" | "availability", ExtArgs["result"]["room"]>
  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | Room$hotelArgs<ExtArgs>
    roomType?: boolean | Room$roomTypeArgs<ExtArgs>
    bookings?: boolean | Room$bookingsArgs<ExtArgs>
    amenities?: boolean | Room$amenitiesArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      hotel: Prisma.$HotelPayload<ExtArgs> | null
      roomType: Prisma.$RoomTypePayload<ExtArgs> | null
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      amenities: Prisma.$RoomAmenitiesLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hotelId: number | null
      roomTypeId: number | null
      price: Prisma.Decimal | null
      availability: boolean | null
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends Room$hotelArgs<ExtArgs> = {}>(args?: Subset<T, Room$hotelArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    roomType<T extends Room$roomTypeArgs<ExtArgs> = {}>(args?: Subset<T, Room$roomTypeArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bookings<T extends Room$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Room$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    amenities<T extends Room$amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, Room$amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAmenitiesLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'Int'>
    readonly hotelId: FieldRef<"Room", 'Int'>
    readonly roomTypeId: FieldRef<"Room", 'Int'>
    readonly price: FieldRef<"Room", 'Decimal'>
    readonly availability: FieldRef<"Room", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data?: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to update.
     */
    limit?: number
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to delete.
     */
    limit?: number
  }

  /**
   * Room.hotel
   */
  export type Room$hotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
  }

  /**
   * Room.roomType
   */
  export type Room$roomTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    where?: RoomTypeWhereInput
  }

  /**
   * Room.bookings
   */
  export type Room$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Room.amenities
   */
  export type Room$amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenitiesLink
     */
    select?: RoomAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenitiesLink
     */
    omit?: RoomAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenitiesLinkInclude<ExtArgs> | null
    where?: RoomAmenitiesLinkWhereInput
    orderBy?: RoomAmenitiesLinkOrderByWithRelationInput | RoomAmenitiesLinkOrderByWithRelationInput[]
    cursor?: RoomAmenitiesLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomAmenitiesLinkScalarFieldEnum | RoomAmenitiesLinkScalarFieldEnum[]
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
  }


  /**
   * Model BookingStatus
   */

  export type AggregateBookingStatus = {
    _count: BookingStatusCountAggregateOutputType | null
    _avg: BookingStatusAvgAggregateOutputType | null
    _sum: BookingStatusSumAggregateOutputType | null
    _min: BookingStatusMinAggregateOutputType | null
    _max: BookingStatusMaxAggregateOutputType | null
  }

  export type BookingStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type BookingStatusSumAggregateOutputType = {
    id: number | null
  }

  export type BookingStatusMinAggregateOutputType = {
    id: number | null
    statusName: string | null
  }

  export type BookingStatusMaxAggregateOutputType = {
    id: number | null
    statusName: string | null
  }

  export type BookingStatusCountAggregateOutputType = {
    id: number
    statusName: number
    _all: number
  }


  export type BookingStatusAvgAggregateInputType = {
    id?: true
  }

  export type BookingStatusSumAggregateInputType = {
    id?: true
  }

  export type BookingStatusMinAggregateInputType = {
    id?: true
    statusName?: true
  }

  export type BookingStatusMaxAggregateInputType = {
    id?: true
    statusName?: true
  }

  export type BookingStatusCountAggregateInputType = {
    id?: true
    statusName?: true
    _all?: true
  }

  export type BookingStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingStatus to aggregate.
     */
    where?: BookingStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingStatuses to fetch.
     */
    orderBy?: BookingStatusOrderByWithRelationInput | BookingStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingStatuses
    **/
    _count?: true | BookingStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingStatusMaxAggregateInputType
  }

  export type GetBookingStatusAggregateType<T extends BookingStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingStatus[P]>
      : GetScalarType<T[P], AggregateBookingStatus[P]>
  }




  export type BookingStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingStatusWhereInput
    orderBy?: BookingStatusOrderByWithAggregationInput | BookingStatusOrderByWithAggregationInput[]
    by: BookingStatusScalarFieldEnum[] | BookingStatusScalarFieldEnum
    having?: BookingStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingStatusCountAggregateInputType | true
    _avg?: BookingStatusAvgAggregateInputType
    _sum?: BookingStatusSumAggregateInputType
    _min?: BookingStatusMinAggregateInputType
    _max?: BookingStatusMaxAggregateInputType
  }

  export type BookingStatusGroupByOutputType = {
    id: number
    statusName: string | null
    _count: BookingStatusCountAggregateOutputType | null
    _avg: BookingStatusAvgAggregateOutputType | null
    _sum: BookingStatusSumAggregateOutputType | null
    _min: BookingStatusMinAggregateOutputType | null
    _max: BookingStatusMaxAggregateOutputType | null
  }

  type GetBookingStatusGroupByPayload<T extends BookingStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingStatusGroupByOutputType[P]>
            : GetScalarType<T[P], BookingStatusGroupByOutputType[P]>
        }
      >
    >


  export type BookingStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statusName?: boolean
    bookings?: boolean | BookingStatus$bookingsArgs<ExtArgs>
    _count?: boolean | BookingStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingStatus"]>



  export type BookingStatusSelectScalar = {
    id?: boolean
    statusName?: boolean
  }

  export type BookingStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "statusName", ExtArgs["result"]["bookingStatus"]>
  export type BookingStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | BookingStatus$bookingsArgs<ExtArgs>
    _count?: boolean | BookingStatusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BookingStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingStatus"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      statusName: string | null
    }, ExtArgs["result"]["bookingStatus"]>
    composites: {}
  }

  type BookingStatusGetPayload<S extends boolean | null | undefined | BookingStatusDefaultArgs> = $Result.GetResult<Prisma.$BookingStatusPayload, S>

  type BookingStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingStatusCountAggregateInputType | true
    }

  export interface BookingStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingStatus'], meta: { name: 'BookingStatus' } }
    /**
     * Find zero or one BookingStatus that matches the filter.
     * @param {BookingStatusFindUniqueArgs} args - Arguments to find a BookingStatus
     * @example
     * // Get one BookingStatus
     * const bookingStatus = await prisma.bookingStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingStatusFindUniqueArgs>(args: SelectSubset<T, BookingStatusFindUniqueArgs<ExtArgs>>): Prisma__BookingStatusClient<$Result.GetResult<Prisma.$BookingStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingStatusFindUniqueOrThrowArgs} args - Arguments to find a BookingStatus
     * @example
     * // Get one BookingStatus
     * const bookingStatus = await prisma.bookingStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingStatusClient<$Result.GetResult<Prisma.$BookingStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusFindFirstArgs} args - Arguments to find a BookingStatus
     * @example
     * // Get one BookingStatus
     * const bookingStatus = await prisma.bookingStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingStatusFindFirstArgs>(args?: SelectSubset<T, BookingStatusFindFirstArgs<ExtArgs>>): Prisma__BookingStatusClient<$Result.GetResult<Prisma.$BookingStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusFindFirstOrThrowArgs} args - Arguments to find a BookingStatus
     * @example
     * // Get one BookingStatus
     * const bookingStatus = await prisma.bookingStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingStatusClient<$Result.GetResult<Prisma.$BookingStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingStatuses
     * const bookingStatuses = await prisma.bookingStatus.findMany()
     * 
     * // Get first 10 BookingStatuses
     * const bookingStatuses = await prisma.bookingStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingStatusWithIdOnly = await prisma.bookingStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingStatusFindManyArgs>(args?: SelectSubset<T, BookingStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingStatus.
     * @param {BookingStatusCreateArgs} args - Arguments to create a BookingStatus.
     * @example
     * // Create one BookingStatus
     * const BookingStatus = await prisma.bookingStatus.create({
     *   data: {
     *     // ... data to create a BookingStatus
     *   }
     * })
     * 
     */
    create<T extends BookingStatusCreateArgs>(args: SelectSubset<T, BookingStatusCreateArgs<ExtArgs>>): Prisma__BookingStatusClient<$Result.GetResult<Prisma.$BookingStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingStatuses.
     * @param {BookingStatusCreateManyArgs} args - Arguments to create many BookingStatuses.
     * @example
     * // Create many BookingStatuses
     * const bookingStatus = await prisma.bookingStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingStatusCreateManyArgs>(args?: SelectSubset<T, BookingStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BookingStatus.
     * @param {BookingStatusDeleteArgs} args - Arguments to delete one BookingStatus.
     * @example
     * // Delete one BookingStatus
     * const BookingStatus = await prisma.bookingStatus.delete({
     *   where: {
     *     // ... filter to delete one BookingStatus
     *   }
     * })
     * 
     */
    delete<T extends BookingStatusDeleteArgs>(args: SelectSubset<T, BookingStatusDeleteArgs<ExtArgs>>): Prisma__BookingStatusClient<$Result.GetResult<Prisma.$BookingStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingStatus.
     * @param {BookingStatusUpdateArgs} args - Arguments to update one BookingStatus.
     * @example
     * // Update one BookingStatus
     * const bookingStatus = await prisma.bookingStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingStatusUpdateArgs>(args: SelectSubset<T, BookingStatusUpdateArgs<ExtArgs>>): Prisma__BookingStatusClient<$Result.GetResult<Prisma.$BookingStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingStatuses.
     * @param {BookingStatusDeleteManyArgs} args - Arguments to filter BookingStatuses to delete.
     * @example
     * // Delete a few BookingStatuses
     * const { count } = await prisma.bookingStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingStatusDeleteManyArgs>(args?: SelectSubset<T, BookingStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingStatuses
     * const bookingStatus = await prisma.bookingStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingStatusUpdateManyArgs>(args: SelectSubset<T, BookingStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookingStatus.
     * @param {BookingStatusUpsertArgs} args - Arguments to update or create a BookingStatus.
     * @example
     * // Update or create a BookingStatus
     * const bookingStatus = await prisma.bookingStatus.upsert({
     *   create: {
     *     // ... data to create a BookingStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingStatus we want to update
     *   }
     * })
     */
    upsert<T extends BookingStatusUpsertArgs>(args: SelectSubset<T, BookingStatusUpsertArgs<ExtArgs>>): Prisma__BookingStatusClient<$Result.GetResult<Prisma.$BookingStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusCountArgs} args - Arguments to filter BookingStatuses to count.
     * @example
     * // Count the number of BookingStatuses
     * const count = await prisma.bookingStatus.count({
     *   where: {
     *     // ... the filter for the BookingStatuses we want to count
     *   }
     * })
    **/
    count<T extends BookingStatusCountArgs>(
      args?: Subset<T, BookingStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingStatusAggregateArgs>(args: Subset<T, BookingStatusAggregateArgs>): Prisma.PrismaPromise<GetBookingStatusAggregateType<T>>

    /**
     * Group by BookingStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingStatusGroupByArgs['orderBy'] }
        : { orderBy?: BookingStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingStatus model
   */
  readonly fields: BookingStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends BookingStatus$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, BookingStatus$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingStatus model
   */
  interface BookingStatusFieldRefs {
    readonly id: FieldRef<"BookingStatus", 'Int'>
    readonly statusName: FieldRef<"BookingStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BookingStatus findUnique
   */
  export type BookingStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatus
     */
    select?: BookingStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatus
     */
    omit?: BookingStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusInclude<ExtArgs> | null
    /**
     * Filter, which BookingStatus to fetch.
     */
    where: BookingStatusWhereUniqueInput
  }

  /**
   * BookingStatus findUniqueOrThrow
   */
  export type BookingStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatus
     */
    select?: BookingStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatus
     */
    omit?: BookingStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusInclude<ExtArgs> | null
    /**
     * Filter, which BookingStatus to fetch.
     */
    where: BookingStatusWhereUniqueInput
  }

  /**
   * BookingStatus findFirst
   */
  export type BookingStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatus
     */
    select?: BookingStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatus
     */
    omit?: BookingStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusInclude<ExtArgs> | null
    /**
     * Filter, which BookingStatus to fetch.
     */
    where?: BookingStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingStatuses to fetch.
     */
    orderBy?: BookingStatusOrderByWithRelationInput | BookingStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingStatuses.
     */
    cursor?: BookingStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingStatuses.
     */
    distinct?: BookingStatusScalarFieldEnum | BookingStatusScalarFieldEnum[]
  }

  /**
   * BookingStatus findFirstOrThrow
   */
  export type BookingStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatus
     */
    select?: BookingStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatus
     */
    omit?: BookingStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusInclude<ExtArgs> | null
    /**
     * Filter, which BookingStatus to fetch.
     */
    where?: BookingStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingStatuses to fetch.
     */
    orderBy?: BookingStatusOrderByWithRelationInput | BookingStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingStatuses.
     */
    cursor?: BookingStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingStatuses.
     */
    distinct?: BookingStatusScalarFieldEnum | BookingStatusScalarFieldEnum[]
  }

  /**
   * BookingStatus findMany
   */
  export type BookingStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatus
     */
    select?: BookingStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatus
     */
    omit?: BookingStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusInclude<ExtArgs> | null
    /**
     * Filter, which BookingStatuses to fetch.
     */
    where?: BookingStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingStatuses to fetch.
     */
    orderBy?: BookingStatusOrderByWithRelationInput | BookingStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingStatuses.
     */
    cursor?: BookingStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingStatuses.
     */
    skip?: number
    distinct?: BookingStatusScalarFieldEnum | BookingStatusScalarFieldEnum[]
  }

  /**
   * BookingStatus create
   */
  export type BookingStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatus
     */
    select?: BookingStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatus
     */
    omit?: BookingStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingStatus.
     */
    data?: XOR<BookingStatusCreateInput, BookingStatusUncheckedCreateInput>
  }

  /**
   * BookingStatus createMany
   */
  export type BookingStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingStatuses.
     */
    data: BookingStatusCreateManyInput | BookingStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingStatus update
   */
  export type BookingStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatus
     */
    select?: BookingStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatus
     */
    omit?: BookingStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingStatus.
     */
    data: XOR<BookingStatusUpdateInput, BookingStatusUncheckedUpdateInput>
    /**
     * Choose, which BookingStatus to update.
     */
    where: BookingStatusWhereUniqueInput
  }

  /**
   * BookingStatus updateMany
   */
  export type BookingStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingStatuses.
     */
    data: XOR<BookingStatusUpdateManyMutationInput, BookingStatusUncheckedUpdateManyInput>
    /**
     * Filter which BookingStatuses to update
     */
    where?: BookingStatusWhereInput
    /**
     * Limit how many BookingStatuses to update.
     */
    limit?: number
  }

  /**
   * BookingStatus upsert
   */
  export type BookingStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatus
     */
    select?: BookingStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatus
     */
    omit?: BookingStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingStatus to update in case it exists.
     */
    where: BookingStatusWhereUniqueInput
    /**
     * In case the BookingStatus found by the `where` argument doesn't exist, create a new BookingStatus with this data.
     */
    create: XOR<BookingStatusCreateInput, BookingStatusUncheckedCreateInput>
    /**
     * In case the BookingStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingStatusUpdateInput, BookingStatusUncheckedUpdateInput>
  }

  /**
   * BookingStatus delete
   */
  export type BookingStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatus
     */
    select?: BookingStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatus
     */
    omit?: BookingStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusInclude<ExtArgs> | null
    /**
     * Filter which BookingStatus to delete.
     */
    where: BookingStatusWhereUniqueInput
  }

  /**
   * BookingStatus deleteMany
   */
  export type BookingStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingStatuses to delete
     */
    where?: BookingStatusWhereInput
    /**
     * Limit how many BookingStatuses to delete.
     */
    limit?: number
  }

  /**
   * BookingStatus.bookings
   */
  export type BookingStatus$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * BookingStatus without action
   */
  export type BookingStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatus
     */
    select?: BookingStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatus
     */
    omit?: BookingStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    roomId: number | null
    statusId: number | null
    totalPrice: Decimal | null
  }

  export type BookingSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    roomId: number | null
    statusId: number | null
    totalPrice: Decimal | null
  }

  export type BookingMinAggregateOutputType = {
    id: number | null
    customerId: number | null
    roomId: number | null
    statusId: number | null
    checkIn: Date | null
    checkOut: Date | null
    totalPrice: Decimal | null
  }

  export type BookingMaxAggregateOutputType = {
    id: number | null
    customerId: number | null
    roomId: number | null
    statusId: number | null
    checkIn: Date | null
    checkOut: Date | null
    totalPrice: Decimal | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    customerId: number
    roomId: number
    statusId: number
    checkIn: number
    checkOut: number
    totalPrice: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    id?: true
    customerId?: true
    roomId?: true
    statusId?: true
    totalPrice?: true
  }

  export type BookingSumAggregateInputType = {
    id?: true
    customerId?: true
    roomId?: true
    statusId?: true
    totalPrice?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    customerId?: true
    roomId?: true
    statusId?: true
    checkIn?: true
    checkOut?: true
    totalPrice?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    customerId?: true
    roomId?: true
    statusId?: true
    checkIn?: true
    checkOut?: true
    totalPrice?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    customerId?: true
    roomId?: true
    statusId?: true
    checkIn?: true
    checkOut?: true
    totalPrice?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: number
    customerId: number | null
    roomId: number | null
    statusId: number | null
    checkIn: Date | null
    checkOut: Date | null
    totalPrice: Decimal | null
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    roomId?: boolean
    statusId?: boolean
    checkIn?: boolean
    checkOut?: boolean
    totalPrice?: boolean
    customer?: boolean | Booking$customerArgs<ExtArgs>
    room?: boolean | Booking$roomArgs<ExtArgs>
    status?: boolean | Booking$statusArgs<ExtArgs>
    services?: boolean | Booking$servicesArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    promotions?: boolean | Booking$promotionsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>



  export type BookingSelectScalar = {
    id?: boolean
    customerId?: boolean
    roomId?: boolean
    statusId?: boolean
    checkIn?: boolean
    checkOut?: boolean
    totalPrice?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "roomId" | "statusId" | "checkIn" | "checkOut" | "totalPrice", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Booking$customerArgs<ExtArgs>
    room?: boolean | Booking$roomArgs<ExtArgs>
    status?: boolean | Booking$statusArgs<ExtArgs>
    services?: boolean | Booking$servicesArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    promotions?: boolean | Booking$promotionsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      room: Prisma.$RoomPayload<ExtArgs> | null
      status: Prisma.$BookingStatusPayload<ExtArgs> | null
      services: Prisma.$BookingServicePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      promotions: Prisma.$PromotionAppliedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customerId: number | null
      roomId: number | null
      statusId: number | null
      checkIn: Date | null
      checkOut: Date | null
      totalPrice: Prisma.Decimal | null
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends Booking$customerArgs<ExtArgs> = {}>(args?: Subset<T, Booking$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    room<T extends Booking$roomArgs<ExtArgs> = {}>(args?: Subset<T, Booking$roomArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    status<T extends Booking$statusArgs<ExtArgs> = {}>(args?: Subset<T, Booking$statusArgs<ExtArgs>>): Prisma__BookingStatusClient<$Result.GetResult<Prisma.$BookingStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    services<T extends Booking$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Booking$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Booking$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promotions<T extends Booking$promotionsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$promotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionAppliedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'Int'>
    readonly customerId: FieldRef<"Booking", 'Int'>
    readonly roomId: FieldRef<"Booking", 'Int'>
    readonly statusId: FieldRef<"Booking", 'Int'>
    readonly checkIn: FieldRef<"Booking", 'DateTime'>
    readonly checkOut: FieldRef<"Booking", 'DateTime'>
    readonly totalPrice: FieldRef<"Booking", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data?: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.customer
   */
  export type Booking$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Booking.room
   */
  export type Booking$roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
  }

  /**
   * Booking.status
   */
  export type Booking$statusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatus
     */
    select?: BookingStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatus
     */
    omit?: BookingStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusInclude<ExtArgs> | null
    where?: BookingStatusWhereInput
  }

  /**
   * Booking.services
   */
  export type Booking$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    where?: BookingServiceWhereInput
    orderBy?: BookingServiceOrderByWithRelationInput | BookingServiceOrderByWithRelationInput[]
    cursor?: BookingServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingServiceScalarFieldEnum | BookingServiceScalarFieldEnum[]
  }

  /**
   * Booking.payments
   */
  export type Booking$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Booking.promotions
   */
  export type Booking$promotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionApplied
     */
    select?: PromotionAppliedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionApplied
     */
    omit?: PromotionAppliedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionAppliedInclude<ExtArgs> | null
    where?: PromotionAppliedWhereInput
    orderBy?: PromotionAppliedOrderByWithRelationInput | PromotionAppliedOrderByWithRelationInput[]
    cursor?: PromotionAppliedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionAppliedScalarFieldEnum | PromotionAppliedScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    id: number | null
    price: Decimal | null
  }

  export type ServiceSumAggregateOutputType = {
    id: number | null
    price: Decimal | null
  }

  export type ServiceMinAggregateOutputType = {
    id: number | null
    serviceName: string | null
    price: Decimal | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: number | null
    serviceName: string | null
    price: Decimal | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    serviceName: number
    price: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type ServiceSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    serviceName?: true
    price?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    serviceName?: true
    price?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    serviceName?: true
    price?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: number
    serviceName: string | null
    price: Decimal | null
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceName?: boolean
    price?: boolean
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>



  export type ServiceSelectScalar = {
    id?: boolean
    serviceName?: boolean
    price?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceName" | "price", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      bookings: Prisma.$BookingServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serviceName: string | null
      price: Prisma.Decimal | null
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends Service$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Service$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'Int'>
    readonly serviceName: FieldRef<"Service", 'String'>
    readonly price: FieldRef<"Service", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data?: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.bookings
   */
  export type Service$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    where?: BookingServiceWhereInput
    orderBy?: BookingServiceOrderByWithRelationInput | BookingServiceOrderByWithRelationInput[]
    cursor?: BookingServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingServiceScalarFieldEnum | BookingServiceScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model BookingService
   */

  export type AggregateBookingService = {
    _count: BookingServiceCountAggregateOutputType | null
    _avg: BookingServiceAvgAggregateOutputType | null
    _sum: BookingServiceSumAggregateOutputType | null
    _min: BookingServiceMinAggregateOutputType | null
    _max: BookingServiceMaxAggregateOutputType | null
  }

  export type BookingServiceAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    serviceId: number | null
    quantity: number | null
  }

  export type BookingServiceSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    serviceId: number | null
    quantity: number | null
  }

  export type BookingServiceMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    serviceId: number | null
    quantity: number | null
  }

  export type BookingServiceMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    serviceId: number | null
    quantity: number | null
  }

  export type BookingServiceCountAggregateOutputType = {
    id: number
    bookingId: number
    serviceId: number
    quantity: number
    _all: number
  }


  export type BookingServiceAvgAggregateInputType = {
    id?: true
    bookingId?: true
    serviceId?: true
    quantity?: true
  }

  export type BookingServiceSumAggregateInputType = {
    id?: true
    bookingId?: true
    serviceId?: true
    quantity?: true
  }

  export type BookingServiceMinAggregateInputType = {
    id?: true
    bookingId?: true
    serviceId?: true
    quantity?: true
  }

  export type BookingServiceMaxAggregateInputType = {
    id?: true
    bookingId?: true
    serviceId?: true
    quantity?: true
  }

  export type BookingServiceCountAggregateInputType = {
    id?: true
    bookingId?: true
    serviceId?: true
    quantity?: true
    _all?: true
  }

  export type BookingServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingService to aggregate.
     */
    where?: BookingServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingServices to fetch.
     */
    orderBy?: BookingServiceOrderByWithRelationInput | BookingServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingServices
    **/
    _count?: true | BookingServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingServiceMaxAggregateInputType
  }

  export type GetBookingServiceAggregateType<T extends BookingServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingService[P]>
      : GetScalarType<T[P], AggregateBookingService[P]>
  }




  export type BookingServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingServiceWhereInput
    orderBy?: BookingServiceOrderByWithAggregationInput | BookingServiceOrderByWithAggregationInput[]
    by: BookingServiceScalarFieldEnum[] | BookingServiceScalarFieldEnum
    having?: BookingServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingServiceCountAggregateInputType | true
    _avg?: BookingServiceAvgAggregateInputType
    _sum?: BookingServiceSumAggregateInputType
    _min?: BookingServiceMinAggregateInputType
    _max?: BookingServiceMaxAggregateInputType
  }

  export type BookingServiceGroupByOutputType = {
    id: number
    bookingId: number
    serviceId: number | null
    quantity: number | null
    _count: BookingServiceCountAggregateOutputType | null
    _avg: BookingServiceAvgAggregateOutputType | null
    _sum: BookingServiceSumAggregateOutputType | null
    _min: BookingServiceMinAggregateOutputType | null
    _max: BookingServiceMaxAggregateOutputType | null
  }

  type GetBookingServiceGroupByPayload<T extends BookingServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingServiceGroupByOutputType[P]>
            : GetScalarType<T[P], BookingServiceGroupByOutputType[P]>
        }
      >
    >


  export type BookingServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    serviceId?: boolean
    quantity?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | BookingService$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["bookingService"]>



  export type BookingServiceSelectScalar = {
    id?: boolean
    bookingId?: boolean
    serviceId?: boolean
    quantity?: boolean
  }

  export type BookingServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "serviceId" | "quantity", ExtArgs["result"]["bookingService"]>
  export type BookingServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | BookingService$serviceArgs<ExtArgs>
  }

  export type $BookingServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingService"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      serviceId: number | null
      quantity: number | null
    }, ExtArgs["result"]["bookingService"]>
    composites: {}
  }

  type BookingServiceGetPayload<S extends boolean | null | undefined | BookingServiceDefaultArgs> = $Result.GetResult<Prisma.$BookingServicePayload, S>

  type BookingServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingServiceCountAggregateInputType | true
    }

  export interface BookingServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingService'], meta: { name: 'BookingService' } }
    /**
     * Find zero or one BookingService that matches the filter.
     * @param {BookingServiceFindUniqueArgs} args - Arguments to find a BookingService
     * @example
     * // Get one BookingService
     * const bookingService = await prisma.bookingService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingServiceFindUniqueArgs>(args: SelectSubset<T, BookingServiceFindUniqueArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingServiceFindUniqueOrThrowArgs} args - Arguments to find a BookingService
     * @example
     * // Get one BookingService
     * const bookingService = await prisma.bookingService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceFindFirstArgs} args - Arguments to find a BookingService
     * @example
     * // Get one BookingService
     * const bookingService = await prisma.bookingService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingServiceFindFirstArgs>(args?: SelectSubset<T, BookingServiceFindFirstArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceFindFirstOrThrowArgs} args - Arguments to find a BookingService
     * @example
     * // Get one BookingService
     * const bookingService = await prisma.bookingService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingServices
     * const bookingServices = await prisma.bookingService.findMany()
     * 
     * // Get first 10 BookingServices
     * const bookingServices = await prisma.bookingService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingServiceWithIdOnly = await prisma.bookingService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingServiceFindManyArgs>(args?: SelectSubset<T, BookingServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingService.
     * @param {BookingServiceCreateArgs} args - Arguments to create a BookingService.
     * @example
     * // Create one BookingService
     * const BookingService = await prisma.bookingService.create({
     *   data: {
     *     // ... data to create a BookingService
     *   }
     * })
     * 
     */
    create<T extends BookingServiceCreateArgs>(args: SelectSubset<T, BookingServiceCreateArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingServices.
     * @param {BookingServiceCreateManyArgs} args - Arguments to create many BookingServices.
     * @example
     * // Create many BookingServices
     * const bookingService = await prisma.bookingService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingServiceCreateManyArgs>(args?: SelectSubset<T, BookingServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BookingService.
     * @param {BookingServiceDeleteArgs} args - Arguments to delete one BookingService.
     * @example
     * // Delete one BookingService
     * const BookingService = await prisma.bookingService.delete({
     *   where: {
     *     // ... filter to delete one BookingService
     *   }
     * })
     * 
     */
    delete<T extends BookingServiceDeleteArgs>(args: SelectSubset<T, BookingServiceDeleteArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingService.
     * @param {BookingServiceUpdateArgs} args - Arguments to update one BookingService.
     * @example
     * // Update one BookingService
     * const bookingService = await prisma.bookingService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingServiceUpdateArgs>(args: SelectSubset<T, BookingServiceUpdateArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingServices.
     * @param {BookingServiceDeleteManyArgs} args - Arguments to filter BookingServices to delete.
     * @example
     * // Delete a few BookingServices
     * const { count } = await prisma.bookingService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingServiceDeleteManyArgs>(args?: SelectSubset<T, BookingServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingServices
     * const bookingService = await prisma.bookingService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingServiceUpdateManyArgs>(args: SelectSubset<T, BookingServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookingService.
     * @param {BookingServiceUpsertArgs} args - Arguments to update or create a BookingService.
     * @example
     * // Update or create a BookingService
     * const bookingService = await prisma.bookingService.upsert({
     *   create: {
     *     // ... data to create a BookingService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingService we want to update
     *   }
     * })
     */
    upsert<T extends BookingServiceUpsertArgs>(args: SelectSubset<T, BookingServiceUpsertArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceCountArgs} args - Arguments to filter BookingServices to count.
     * @example
     * // Count the number of BookingServices
     * const count = await prisma.bookingService.count({
     *   where: {
     *     // ... the filter for the BookingServices we want to count
     *   }
     * })
    **/
    count<T extends BookingServiceCountArgs>(
      args?: Subset<T, BookingServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingServiceAggregateArgs>(args: Subset<T, BookingServiceAggregateArgs>): Prisma.PrismaPromise<GetBookingServiceAggregateType<T>>

    /**
     * Group by BookingService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingServiceGroupByArgs['orderBy'] }
        : { orderBy?: BookingServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingService model
   */
  readonly fields: BookingServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends BookingService$serviceArgs<ExtArgs> = {}>(args?: Subset<T, BookingService$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingService model
   */
  interface BookingServiceFieldRefs {
    readonly id: FieldRef<"BookingService", 'Int'>
    readonly bookingId: FieldRef<"BookingService", 'Int'>
    readonly serviceId: FieldRef<"BookingService", 'Int'>
    readonly quantity: FieldRef<"BookingService", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BookingService findUnique
   */
  export type BookingServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * Filter, which BookingService to fetch.
     */
    where: BookingServiceWhereUniqueInput
  }

  /**
   * BookingService findUniqueOrThrow
   */
  export type BookingServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * Filter, which BookingService to fetch.
     */
    where: BookingServiceWhereUniqueInput
  }

  /**
   * BookingService findFirst
   */
  export type BookingServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * Filter, which BookingService to fetch.
     */
    where?: BookingServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingServices to fetch.
     */
    orderBy?: BookingServiceOrderByWithRelationInput | BookingServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingServices.
     */
    cursor?: BookingServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingServices.
     */
    distinct?: BookingServiceScalarFieldEnum | BookingServiceScalarFieldEnum[]
  }

  /**
   * BookingService findFirstOrThrow
   */
  export type BookingServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * Filter, which BookingService to fetch.
     */
    where?: BookingServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingServices to fetch.
     */
    orderBy?: BookingServiceOrderByWithRelationInput | BookingServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingServices.
     */
    cursor?: BookingServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingServices.
     */
    distinct?: BookingServiceScalarFieldEnum | BookingServiceScalarFieldEnum[]
  }

  /**
   * BookingService findMany
   */
  export type BookingServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * Filter, which BookingServices to fetch.
     */
    where?: BookingServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingServices to fetch.
     */
    orderBy?: BookingServiceOrderByWithRelationInput | BookingServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingServices.
     */
    cursor?: BookingServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingServices.
     */
    skip?: number
    distinct?: BookingServiceScalarFieldEnum | BookingServiceScalarFieldEnum[]
  }

  /**
   * BookingService create
   */
  export type BookingServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingService.
     */
    data: XOR<BookingServiceCreateInput, BookingServiceUncheckedCreateInput>
  }

  /**
   * BookingService createMany
   */
  export type BookingServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingServices.
     */
    data: BookingServiceCreateManyInput | BookingServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingService update
   */
  export type BookingServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingService.
     */
    data: XOR<BookingServiceUpdateInput, BookingServiceUncheckedUpdateInput>
    /**
     * Choose, which BookingService to update.
     */
    where: BookingServiceWhereUniqueInput
  }

  /**
   * BookingService updateMany
   */
  export type BookingServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingServices.
     */
    data: XOR<BookingServiceUpdateManyMutationInput, BookingServiceUncheckedUpdateManyInput>
    /**
     * Filter which BookingServices to update
     */
    where?: BookingServiceWhereInput
    /**
     * Limit how many BookingServices to update.
     */
    limit?: number
  }

  /**
   * BookingService upsert
   */
  export type BookingServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingService to update in case it exists.
     */
    where: BookingServiceWhereUniqueInput
    /**
     * In case the BookingService found by the `where` argument doesn't exist, create a new BookingService with this data.
     */
    create: XOR<BookingServiceCreateInput, BookingServiceUncheckedCreateInput>
    /**
     * In case the BookingService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingServiceUpdateInput, BookingServiceUncheckedUpdateInput>
  }

  /**
   * BookingService delete
   */
  export type BookingServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * Filter which BookingService to delete.
     */
    where: BookingServiceWhereUniqueInput
  }

  /**
   * BookingService deleteMany
   */
  export type BookingServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingServices to delete
     */
    where?: BookingServiceWhereInput
    /**
     * Limit how many BookingServices to delete.
     */
    limit?: number
  }

  /**
   * BookingService.service
   */
  export type BookingService$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * BookingService without action
   */
  export type BookingServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeRole
   */

  export type AggregateEmployeeRole = {
    _count: EmployeeRoleCountAggregateOutputType | null
    _avg: EmployeeRoleAvgAggregateOutputType | null
    _sum: EmployeeRoleSumAggregateOutputType | null
    _min: EmployeeRoleMinAggregateOutputType | null
    _max: EmployeeRoleMaxAggregateOutputType | null
  }

  export type EmployeeRoleAvgAggregateOutputType = {
    id: number | null
  }

  export type EmployeeRoleSumAggregateOutputType = {
    id: number | null
  }

  export type EmployeeRoleMinAggregateOutputType = {
    id: number | null
    roleName: string | null
    description: string | null
  }

  export type EmployeeRoleMaxAggregateOutputType = {
    id: number | null
    roleName: string | null
    description: string | null
  }

  export type EmployeeRoleCountAggregateOutputType = {
    id: number
    roleName: number
    description: number
    _all: number
  }


  export type EmployeeRoleAvgAggregateInputType = {
    id?: true
  }

  export type EmployeeRoleSumAggregateInputType = {
    id?: true
  }

  export type EmployeeRoleMinAggregateInputType = {
    id?: true
    roleName?: true
    description?: true
  }

  export type EmployeeRoleMaxAggregateInputType = {
    id?: true
    roleName?: true
    description?: true
  }

  export type EmployeeRoleCountAggregateInputType = {
    id?: true
    roleName?: true
    description?: true
    _all?: true
  }

  export type EmployeeRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeRole to aggregate.
     */
    where?: EmployeeRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeRoles to fetch.
     */
    orderBy?: EmployeeRoleOrderByWithRelationInput | EmployeeRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeRoles
    **/
    _count?: true | EmployeeRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeRoleMaxAggregateInputType
  }

  export type GetEmployeeRoleAggregateType<T extends EmployeeRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeRole[P]>
      : GetScalarType<T[P], AggregateEmployeeRole[P]>
  }




  export type EmployeeRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeRoleWhereInput
    orderBy?: EmployeeRoleOrderByWithAggregationInput | EmployeeRoleOrderByWithAggregationInput[]
    by: EmployeeRoleScalarFieldEnum[] | EmployeeRoleScalarFieldEnum
    having?: EmployeeRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeRoleCountAggregateInputType | true
    _avg?: EmployeeRoleAvgAggregateInputType
    _sum?: EmployeeRoleSumAggregateInputType
    _min?: EmployeeRoleMinAggregateInputType
    _max?: EmployeeRoleMaxAggregateInputType
  }

  export type EmployeeRoleGroupByOutputType = {
    id: number
    roleName: string | null
    description: string | null
    _count: EmployeeRoleCountAggregateOutputType | null
    _avg: EmployeeRoleAvgAggregateOutputType | null
    _sum: EmployeeRoleSumAggregateOutputType | null
    _min: EmployeeRoleMinAggregateOutputType | null
    _max: EmployeeRoleMaxAggregateOutputType | null
  }

  type GetEmployeeRoleGroupByPayload<T extends EmployeeRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeRoleGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeRoleGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleName?: boolean
    description?: boolean
    employees?: boolean | EmployeeRole$employeesArgs<ExtArgs>
    _count?: boolean | EmployeeRoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeRole"]>



  export type EmployeeRoleSelectScalar = {
    id?: boolean
    roleName?: boolean
    description?: boolean
  }

  export type EmployeeRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleName" | "description", ExtArgs["result"]["employeeRole"]>
  export type EmployeeRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | EmployeeRole$employeesArgs<ExtArgs>
    _count?: boolean | EmployeeRoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmployeeRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeRole"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roleName: string | null
      description: string | null
    }, ExtArgs["result"]["employeeRole"]>
    composites: {}
  }

  type EmployeeRoleGetPayload<S extends boolean | null | undefined | EmployeeRoleDefaultArgs> = $Result.GetResult<Prisma.$EmployeeRolePayload, S>

  type EmployeeRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeRoleCountAggregateInputType | true
    }

  export interface EmployeeRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeRole'], meta: { name: 'EmployeeRole' } }
    /**
     * Find zero or one EmployeeRole that matches the filter.
     * @param {EmployeeRoleFindUniqueArgs} args - Arguments to find a EmployeeRole
     * @example
     * // Get one EmployeeRole
     * const employeeRole = await prisma.employeeRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeRoleFindUniqueArgs>(args: SelectSubset<T, EmployeeRoleFindUniqueArgs<ExtArgs>>): Prisma__EmployeeRoleClient<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeRoleFindUniqueOrThrowArgs} args - Arguments to find a EmployeeRole
     * @example
     * // Get one EmployeeRole
     * const employeeRole = await prisma.employeeRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeRoleClient<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRoleFindFirstArgs} args - Arguments to find a EmployeeRole
     * @example
     * // Get one EmployeeRole
     * const employeeRole = await prisma.employeeRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeRoleFindFirstArgs>(args?: SelectSubset<T, EmployeeRoleFindFirstArgs<ExtArgs>>): Prisma__EmployeeRoleClient<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRoleFindFirstOrThrowArgs} args - Arguments to find a EmployeeRole
     * @example
     * // Get one EmployeeRole
     * const employeeRole = await prisma.employeeRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeRoleClient<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeRoles
     * const employeeRoles = await prisma.employeeRole.findMany()
     * 
     * // Get first 10 EmployeeRoles
     * const employeeRoles = await prisma.employeeRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeRoleWithIdOnly = await prisma.employeeRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeRoleFindManyArgs>(args?: SelectSubset<T, EmployeeRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeRole.
     * @param {EmployeeRoleCreateArgs} args - Arguments to create a EmployeeRole.
     * @example
     * // Create one EmployeeRole
     * const EmployeeRole = await prisma.employeeRole.create({
     *   data: {
     *     // ... data to create a EmployeeRole
     *   }
     * })
     * 
     */
    create<T extends EmployeeRoleCreateArgs>(args: SelectSubset<T, EmployeeRoleCreateArgs<ExtArgs>>): Prisma__EmployeeRoleClient<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeRoles.
     * @param {EmployeeRoleCreateManyArgs} args - Arguments to create many EmployeeRoles.
     * @example
     * // Create many EmployeeRoles
     * const employeeRole = await prisma.employeeRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeRoleCreateManyArgs>(args?: SelectSubset<T, EmployeeRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeeRole.
     * @param {EmployeeRoleDeleteArgs} args - Arguments to delete one EmployeeRole.
     * @example
     * // Delete one EmployeeRole
     * const EmployeeRole = await prisma.employeeRole.delete({
     *   where: {
     *     // ... filter to delete one EmployeeRole
     *   }
     * })
     * 
     */
    delete<T extends EmployeeRoleDeleteArgs>(args: SelectSubset<T, EmployeeRoleDeleteArgs<ExtArgs>>): Prisma__EmployeeRoleClient<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeRole.
     * @param {EmployeeRoleUpdateArgs} args - Arguments to update one EmployeeRole.
     * @example
     * // Update one EmployeeRole
     * const employeeRole = await prisma.employeeRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeRoleUpdateArgs>(args: SelectSubset<T, EmployeeRoleUpdateArgs<ExtArgs>>): Prisma__EmployeeRoleClient<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeRoles.
     * @param {EmployeeRoleDeleteManyArgs} args - Arguments to filter EmployeeRoles to delete.
     * @example
     * // Delete a few EmployeeRoles
     * const { count } = await prisma.employeeRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeRoleDeleteManyArgs>(args?: SelectSubset<T, EmployeeRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeRoles
     * const employeeRole = await prisma.employeeRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeRoleUpdateManyArgs>(args: SelectSubset<T, EmployeeRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeRole.
     * @param {EmployeeRoleUpsertArgs} args - Arguments to update or create a EmployeeRole.
     * @example
     * // Update or create a EmployeeRole
     * const employeeRole = await prisma.employeeRole.upsert({
     *   create: {
     *     // ... data to create a EmployeeRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeRole we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeRoleUpsertArgs>(args: SelectSubset<T, EmployeeRoleUpsertArgs<ExtArgs>>): Prisma__EmployeeRoleClient<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRoleCountArgs} args - Arguments to filter EmployeeRoles to count.
     * @example
     * // Count the number of EmployeeRoles
     * const count = await prisma.employeeRole.count({
     *   where: {
     *     // ... the filter for the EmployeeRoles we want to count
     *   }
     * })
    **/
    count<T extends EmployeeRoleCountArgs>(
      args?: Subset<T, EmployeeRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeRoleAggregateArgs>(args: Subset<T, EmployeeRoleAggregateArgs>): Prisma.PrismaPromise<GetEmployeeRoleAggregateType<T>>

    /**
     * Group by EmployeeRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeRoleGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeRole model
   */
  readonly fields: EmployeeRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends EmployeeRole$employeesArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeRole$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeRole model
   */
  interface EmployeeRoleFieldRefs {
    readonly id: FieldRef<"EmployeeRole", 'Int'>
    readonly roleName: FieldRef<"EmployeeRole", 'String'>
    readonly description: FieldRef<"EmployeeRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeRole findUnique
   */
  export type EmployeeRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeRole to fetch.
     */
    where: EmployeeRoleWhereUniqueInput
  }

  /**
   * EmployeeRole findUniqueOrThrow
   */
  export type EmployeeRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeRole to fetch.
     */
    where: EmployeeRoleWhereUniqueInput
  }

  /**
   * EmployeeRole findFirst
   */
  export type EmployeeRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeRole to fetch.
     */
    where?: EmployeeRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeRoles to fetch.
     */
    orderBy?: EmployeeRoleOrderByWithRelationInput | EmployeeRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeRoles.
     */
    cursor?: EmployeeRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeRoles.
     */
    distinct?: EmployeeRoleScalarFieldEnum | EmployeeRoleScalarFieldEnum[]
  }

  /**
   * EmployeeRole findFirstOrThrow
   */
  export type EmployeeRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeRole to fetch.
     */
    where?: EmployeeRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeRoles to fetch.
     */
    orderBy?: EmployeeRoleOrderByWithRelationInput | EmployeeRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeRoles.
     */
    cursor?: EmployeeRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeRoles.
     */
    distinct?: EmployeeRoleScalarFieldEnum | EmployeeRoleScalarFieldEnum[]
  }

  /**
   * EmployeeRole findMany
   */
  export type EmployeeRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeRoles to fetch.
     */
    where?: EmployeeRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeRoles to fetch.
     */
    orderBy?: EmployeeRoleOrderByWithRelationInput | EmployeeRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeRoles.
     */
    cursor?: EmployeeRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeRoles.
     */
    skip?: number
    distinct?: EmployeeRoleScalarFieldEnum | EmployeeRoleScalarFieldEnum[]
  }

  /**
   * EmployeeRole create
   */
  export type EmployeeRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeRole.
     */
    data?: XOR<EmployeeRoleCreateInput, EmployeeRoleUncheckedCreateInput>
  }

  /**
   * EmployeeRole createMany
   */
  export type EmployeeRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeRoles.
     */
    data: EmployeeRoleCreateManyInput | EmployeeRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeRole update
   */
  export type EmployeeRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeRole.
     */
    data: XOR<EmployeeRoleUpdateInput, EmployeeRoleUncheckedUpdateInput>
    /**
     * Choose, which EmployeeRole to update.
     */
    where: EmployeeRoleWhereUniqueInput
  }

  /**
   * EmployeeRole updateMany
   */
  export type EmployeeRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeRoles.
     */
    data: XOR<EmployeeRoleUpdateManyMutationInput, EmployeeRoleUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeRoles to update
     */
    where?: EmployeeRoleWhereInput
    /**
     * Limit how many EmployeeRoles to update.
     */
    limit?: number
  }

  /**
   * EmployeeRole upsert
   */
  export type EmployeeRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeRole to update in case it exists.
     */
    where: EmployeeRoleWhereUniqueInput
    /**
     * In case the EmployeeRole found by the `where` argument doesn't exist, create a new EmployeeRole with this data.
     */
    create: XOR<EmployeeRoleCreateInput, EmployeeRoleUncheckedCreateInput>
    /**
     * In case the EmployeeRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeRoleUpdateInput, EmployeeRoleUncheckedUpdateInput>
  }

  /**
   * EmployeeRole delete
   */
  export type EmployeeRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    /**
     * Filter which EmployeeRole to delete.
     */
    where: EmployeeRoleWhereUniqueInput
  }

  /**
   * EmployeeRole deleteMany
   */
  export type EmployeeRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeRoles to delete
     */
    where?: EmployeeRoleWhereInput
    /**
     * Limit how many EmployeeRoles to delete.
     */
    limit?: number
  }

  /**
   * EmployeeRole.employees
   */
  export type EmployeeRole$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * EmployeeRole without action
   */
  export type EmployeeRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentAvgAggregateOutputType = {
    id: number | null
  }

  export type DepartmentSumAggregateOutputType = {
    id: number | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: number | null
    departmentName: string | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: number | null
    departmentName: string | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    departmentName: number
    _all: number
  }


  export type DepartmentAvgAggregateInputType = {
    id?: true
  }

  export type DepartmentSumAggregateInputType = {
    id?: true
  }

  export type DepartmentMinAggregateInputType = {
    id?: true
    departmentName?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    departmentName?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    departmentName?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _avg?: DepartmentAvgAggregateInputType
    _sum?: DepartmentSumAggregateInputType
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: number
    departmentName: string | null
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentName?: boolean
    employees?: boolean | Department$employeesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>



  export type DepartmentSelectScalar = {
    id?: boolean
    departmentName?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "departmentName", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | Department$employeesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      departmentName: string | null
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends Department$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Department$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'Int'>
    readonly departmentName: FieldRef<"Department", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data?: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.employees
   */
  export type Department$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
    departmentId: number | null
    salary: Decimal | null
  }

  export type EmployeeSumAggregateOutputType = {
    id: number | null
    roleId: number | null
    departmentId: number | null
    salary: Decimal | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: number | null
    roleId: number | null
    departmentId: number | null
    name: string | null
    position: string | null
    salary: Decimal | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: number | null
    roleId: number | null
    departmentId: number | null
    name: string | null
    position: string | null
    salary: Decimal | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    roleId: number
    departmentId: number
    name: number
    position: number
    salary: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    id?: true
    roleId?: true
    departmentId?: true
    salary?: true
  }

  export type EmployeeSumAggregateInputType = {
    id?: true
    roleId?: true
    departmentId?: true
    salary?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    roleId?: true
    departmentId?: true
    name?: true
    position?: true
    salary?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    roleId?: true
    departmentId?: true
    name?: true
    position?: true
    salary?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    roleId?: true
    departmentId?: true
    name?: true
    position?: true
    salary?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: number
    roleId: number | null
    departmentId: number | null
    name: string | null
    position: string | null
    salary: Decimal | null
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    departmentId?: boolean
    name?: boolean
    position?: boolean
    salary?: boolean
    role?: boolean | Employee$roleArgs<ExtArgs>
    department?: boolean | Employee$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>



  export type EmployeeSelectScalar = {
    id?: boolean
    roleId?: boolean
    departmentId?: boolean
    name?: boolean
    position?: boolean
    salary?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleId" | "departmentId" | "name" | "position" | "salary", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | Employee$roleArgs<ExtArgs>
    department?: boolean | Employee$departmentArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      role: Prisma.$EmployeeRolePayload<ExtArgs> | null
      department: Prisma.$DepartmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roleId: number | null
      departmentId: number | null
      name: string | null
      position: string | null
      salary: Prisma.Decimal | null
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends Employee$roleArgs<ExtArgs> = {}>(args?: Subset<T, Employee$roleArgs<ExtArgs>>): Prisma__EmployeeRoleClient<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    department<T extends Employee$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Employee$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'Int'>
    readonly roleId: FieldRef<"Employee", 'Int'>
    readonly departmentId: FieldRef<"Employee", 'Int'>
    readonly name: FieldRef<"Employee", 'String'>
    readonly position: FieldRef<"Employee", 'String'>
    readonly salary: FieldRef<"Employee", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data?: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.role
   */
  export type Employee$roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    where?: EmployeeRoleWhereInput
  }

  /**
   * Employee.department
   */
  export type Employee$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    amount: Decimal | null
    paymentDate: Date | null
    paymentMethod: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    amount: Decimal | null
    paymentDate: Date | null
    paymentMethod: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    bookingId: number
    amount: number
    paymentDate: number
    paymentMethod: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    bookingId: number | null
    amount: Decimal | null
    paymentDate: Date | null
    paymentMethod: string | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    booking?: boolean | Payment$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>



  export type PaymentSelectScalar = {
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "amount" | "paymentDate" | "paymentMethod", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | Payment$bookingArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number | null
      amount: Prisma.Decimal | null
      paymentDate: Date | null
      paymentMethod: string | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends Payment$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Payment$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly bookingId: FieldRef<"Payment", 'Int'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data?: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.booking
   */
  export type Payment$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    hotelId: number | null
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    hotelId: number | null
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: number | null
    customerId: number | null
    hotelId: number | null
    rating: number | null
    comments: string | null
    reviewDate: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: number | null
    customerId: number | null
    hotelId: number | null
    rating: number | null
    comments: string | null
    reviewDate: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    customerId: number
    hotelId: number
    rating: number
    comments: number
    reviewDate: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    id?: true
    customerId?: true
    hotelId?: true
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    id?: true
    customerId?: true
    hotelId?: true
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    customerId?: true
    hotelId?: true
    rating?: true
    comments?: true
    reviewDate?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    customerId?: true
    hotelId?: true
    rating?: true
    comments?: true
    reviewDate?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    customerId?: true
    hotelId?: true
    rating?: true
    comments?: true
    reviewDate?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: number
    customerId: number | null
    hotelId: number | null
    rating: number | null
    comments: string | null
    reviewDate: Date | null
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    hotelId?: boolean
    rating?: boolean
    comments?: boolean
    reviewDate?: boolean
    customer?: boolean | Review$customerArgs<ExtArgs>
    hotel?: boolean | Review$hotelArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>



  export type ReviewSelectScalar = {
    id?: boolean
    customerId?: boolean
    hotelId?: boolean
    rating?: boolean
    comments?: boolean
    reviewDate?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "hotelId" | "rating" | "comments" | "reviewDate", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Review$customerArgs<ExtArgs>
    hotel?: boolean | Review$hotelArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      hotel: Prisma.$HotelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customerId: number | null
      hotelId: number | null
      rating: number | null
      comments: string | null
      reviewDate: Date | null
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends Review$customerArgs<ExtArgs> = {}>(args?: Subset<T, Review$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    hotel<T extends Review$hotelArgs<ExtArgs> = {}>(args?: Subset<T, Review$hotelArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'Int'>
    readonly customerId: FieldRef<"Review", 'Int'>
    readonly hotelId: FieldRef<"Review", 'Int'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comments: FieldRef<"Review", 'String'>
    readonly reviewDate: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data?: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review.customer
   */
  export type Review$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Review.hotel
   */
  export type Review$hotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Promotion
   */

  export type AggregatePromotion = {
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  export type PromotionAvgAggregateOutputType = {
    id: number | null
    discount: Decimal | null
  }

  export type PromotionSumAggregateOutputType = {
    id: number | null
    discount: Decimal | null
  }

  export type PromotionMinAggregateOutputType = {
    id: number | null
    description: string | null
    discount: Decimal | null
    startDate: Date | null
    endDate: Date | null
  }

  export type PromotionMaxAggregateOutputType = {
    id: number | null
    description: string | null
    discount: Decimal | null
    startDate: Date | null
    endDate: Date | null
  }

  export type PromotionCountAggregateOutputType = {
    id: number
    description: number
    discount: number
    startDate: number
    endDate: number
    _all: number
  }


  export type PromotionAvgAggregateInputType = {
    id?: true
    discount?: true
  }

  export type PromotionSumAggregateInputType = {
    id?: true
    discount?: true
  }

  export type PromotionMinAggregateInputType = {
    id?: true
    description?: true
    discount?: true
    startDate?: true
    endDate?: true
  }

  export type PromotionMaxAggregateInputType = {
    id?: true
    description?: true
    discount?: true
    startDate?: true
    endDate?: true
  }

  export type PromotionCountAggregateInputType = {
    id?: true
    description?: true
    discount?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type PromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotion to aggregate.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promotions
    **/
    _count?: true | PromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionMaxAggregateInputType
  }

  export type GetPromotionAggregateType<T extends PromotionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotion[P]>
      : GetScalarType<T[P], AggregatePromotion[P]>
  }




  export type PromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithAggregationInput | PromotionOrderByWithAggregationInput[]
    by: PromotionScalarFieldEnum[] | PromotionScalarFieldEnum
    having?: PromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionCountAggregateInputType | true
    _avg?: PromotionAvgAggregateInputType
    _sum?: PromotionSumAggregateInputType
    _min?: PromotionMinAggregateInputType
    _max?: PromotionMaxAggregateInputType
  }

  export type PromotionGroupByOutputType = {
    id: number
    description: string | null
    discount: Decimal | null
    startDate: Date | null
    endDate: Date | null
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  type GetPromotionGroupByPayload<T extends PromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionGroupByOutputType[P]>
        }
      >
    >


  export type PromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    discount?: boolean
    startDate?: boolean
    endDate?: boolean
    bookings?: boolean | Promotion$bookingsArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotion"]>



  export type PromotionSelectScalar = {
    id?: boolean
    description?: boolean
    discount?: boolean
    startDate?: boolean
    endDate?: boolean
  }

  export type PromotionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "discount" | "startDate" | "endDate", ExtArgs["result"]["promotion"]>
  export type PromotionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | Promotion$bookingsArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Promotion"
    objects: {
      bookings: Prisma.$PromotionAppliedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      description: string | null
      discount: Prisma.Decimal | null
      startDate: Date | null
      endDate: Date | null
    }, ExtArgs["result"]["promotion"]>
    composites: {}
  }

  type PromotionGetPayload<S extends boolean | null | undefined | PromotionDefaultArgs> = $Result.GetResult<Prisma.$PromotionPayload, S>

  type PromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromotionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromotionCountAggregateInputType | true
    }

  export interface PromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Promotion'], meta: { name: 'Promotion' } }
    /**
     * Find zero or one Promotion that matches the filter.
     * @param {PromotionFindUniqueArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionFindUniqueArgs>(args: SelectSubset<T, PromotionFindUniqueArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Promotion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromotionFindUniqueOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionFindFirstArgs>(args?: SelectSubset<T, PromotionFindFirstArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promotions
     * const promotions = await prisma.promotion.findMany()
     * 
     * // Get first 10 Promotions
     * const promotions = await prisma.promotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionWithIdOnly = await prisma.promotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionFindManyArgs>(args?: SelectSubset<T, PromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Promotion.
     * @param {PromotionCreateArgs} args - Arguments to create a Promotion.
     * @example
     * // Create one Promotion
     * const Promotion = await prisma.promotion.create({
     *   data: {
     *     // ... data to create a Promotion
     *   }
     * })
     * 
     */
    create<T extends PromotionCreateArgs>(args: SelectSubset<T, PromotionCreateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Promotions.
     * @param {PromotionCreateManyArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionCreateManyArgs>(args?: SelectSubset<T, PromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Promotion.
     * @param {PromotionDeleteArgs} args - Arguments to delete one Promotion.
     * @example
     * // Delete one Promotion
     * const Promotion = await prisma.promotion.delete({
     *   where: {
     *     // ... filter to delete one Promotion
     *   }
     * })
     * 
     */
    delete<T extends PromotionDeleteArgs>(args: SelectSubset<T, PromotionDeleteArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Promotion.
     * @param {PromotionUpdateArgs} args - Arguments to update one Promotion.
     * @example
     * // Update one Promotion
     * const promotion = await prisma.promotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionUpdateArgs>(args: SelectSubset<T, PromotionUpdateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Promotions.
     * @param {PromotionDeleteManyArgs} args - Arguments to filter Promotions to delete.
     * @example
     * // Delete a few Promotions
     * const { count } = await prisma.promotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionDeleteManyArgs>(args?: SelectSubset<T, PromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionUpdateManyArgs>(args: SelectSubset<T, PromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Promotion.
     * @param {PromotionUpsertArgs} args - Arguments to update or create a Promotion.
     * @example
     * // Update or create a Promotion
     * const promotion = await prisma.promotion.upsert({
     *   create: {
     *     // ... data to create a Promotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promotion we want to update
     *   }
     * })
     */
    upsert<T extends PromotionUpsertArgs>(args: SelectSubset<T, PromotionUpsertArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCountArgs} args - Arguments to filter Promotions to count.
     * @example
     * // Count the number of Promotions
     * const count = await prisma.promotion.count({
     *   where: {
     *     // ... the filter for the Promotions we want to count
     *   }
     * })
    **/
    count<T extends PromotionCountArgs>(
      args?: Subset<T, PromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionAggregateArgs>(args: Subset<T, PromotionAggregateArgs>): Prisma.PrismaPromise<GetPromotionAggregateType<T>>

    /**
     * Group by Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionGroupByArgs['orderBy'] }
        : { orderBy?: PromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Promotion model
   */
  readonly fields: PromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends Promotion$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionAppliedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Promotion model
   */
  interface PromotionFieldRefs {
    readonly id: FieldRef<"Promotion", 'Int'>
    readonly description: FieldRef<"Promotion", 'String'>
    readonly discount: FieldRef<"Promotion", 'Decimal'>
    readonly startDate: FieldRef<"Promotion", 'DateTime'>
    readonly endDate: FieldRef<"Promotion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Promotion findUnique
   */
  export type PromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findUniqueOrThrow
   */
  export type PromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findFirst
   */
  export type PromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findFirstOrThrow
   */
  export type PromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findMany
   */
  export type PromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotions to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion create
   */
  export type PromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to create a Promotion.
     */
    data?: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
  }

  /**
   * Promotion createMany
   */
  export type PromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion update
   */
  export type PromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to update a Promotion.
     */
    data: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
    /**
     * Choose, which Promotion to update.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion updateMany
   */
  export type PromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to update.
     */
    limit?: number
  }

  /**
   * Promotion upsert
   */
  export type PromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The filter to search for the Promotion to update in case it exists.
     */
    where: PromotionWhereUniqueInput
    /**
     * In case the Promotion found by the `where` argument doesn't exist, create a new Promotion with this data.
     */
    create: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
    /**
     * In case the Promotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
  }

  /**
   * Promotion delete
   */
  export type PromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter which Promotion to delete.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion deleteMany
   */
  export type PromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotions to delete
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to delete.
     */
    limit?: number
  }

  /**
   * Promotion.bookings
   */
  export type Promotion$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionApplied
     */
    select?: PromotionAppliedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionApplied
     */
    omit?: PromotionAppliedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionAppliedInclude<ExtArgs> | null
    where?: PromotionAppliedWhereInput
    orderBy?: PromotionAppliedOrderByWithRelationInput | PromotionAppliedOrderByWithRelationInput[]
    cursor?: PromotionAppliedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionAppliedScalarFieldEnum | PromotionAppliedScalarFieldEnum[]
  }

  /**
   * Promotion without action
   */
  export type PromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
  }


  /**
   * Model RoomAmenity
   */

  export type AggregateRoomAmenity = {
    _count: RoomAmenityCountAggregateOutputType | null
    _avg: RoomAmenityAvgAggregateOutputType | null
    _sum: RoomAmenitySumAggregateOutputType | null
    _min: RoomAmenityMinAggregateOutputType | null
    _max: RoomAmenityMaxAggregateOutputType | null
  }

  export type RoomAmenityAvgAggregateOutputType = {
    id: number | null
  }

  export type RoomAmenitySumAggregateOutputType = {
    id: number | null
  }

  export type RoomAmenityMinAggregateOutputType = {
    id: number | null
    amenityName: string | null
    description: string | null
  }

  export type RoomAmenityMaxAggregateOutputType = {
    id: number | null
    amenityName: string | null
    description: string | null
  }

  export type RoomAmenityCountAggregateOutputType = {
    id: number
    amenityName: number
    description: number
    _all: number
  }


  export type RoomAmenityAvgAggregateInputType = {
    id?: true
  }

  export type RoomAmenitySumAggregateInputType = {
    id?: true
  }

  export type RoomAmenityMinAggregateInputType = {
    id?: true
    amenityName?: true
    description?: true
  }

  export type RoomAmenityMaxAggregateInputType = {
    id?: true
    amenityName?: true
    description?: true
  }

  export type RoomAmenityCountAggregateInputType = {
    id?: true
    amenityName?: true
    description?: true
    _all?: true
  }

  export type RoomAmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomAmenity to aggregate.
     */
    where?: RoomAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAmenities to fetch.
     */
    orderBy?: RoomAmenityOrderByWithRelationInput | RoomAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomAmenities
    **/
    _count?: true | RoomAmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAmenityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomAmenitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomAmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomAmenityMaxAggregateInputType
  }

  export type GetRoomAmenityAggregateType<T extends RoomAmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomAmenity[P]>
      : GetScalarType<T[P], AggregateRoomAmenity[P]>
  }




  export type RoomAmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomAmenityWhereInput
    orderBy?: RoomAmenityOrderByWithAggregationInput | RoomAmenityOrderByWithAggregationInput[]
    by: RoomAmenityScalarFieldEnum[] | RoomAmenityScalarFieldEnum
    having?: RoomAmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomAmenityCountAggregateInputType | true
    _avg?: RoomAmenityAvgAggregateInputType
    _sum?: RoomAmenitySumAggregateInputType
    _min?: RoomAmenityMinAggregateInputType
    _max?: RoomAmenityMaxAggregateInputType
  }

  export type RoomAmenityGroupByOutputType = {
    id: number
    amenityName: string | null
    description: string | null
    _count: RoomAmenityCountAggregateOutputType | null
    _avg: RoomAmenityAvgAggregateOutputType | null
    _sum: RoomAmenitySumAggregateOutputType | null
    _min: RoomAmenityMinAggregateOutputType | null
    _max: RoomAmenityMaxAggregateOutputType | null
  }

  type GetRoomAmenityGroupByPayload<T extends RoomAmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomAmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomAmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomAmenityGroupByOutputType[P]>
            : GetScalarType<T[P], RoomAmenityGroupByOutputType[P]>
        }
      >
    >


  export type RoomAmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amenityName?: boolean
    description?: boolean
    rooms?: boolean | RoomAmenity$roomsArgs<ExtArgs>
    _count?: boolean | RoomAmenityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomAmenity"]>



  export type RoomAmenitySelectScalar = {
    id?: boolean
    amenityName?: boolean
    description?: boolean
  }

  export type RoomAmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amenityName" | "description", ExtArgs["result"]["roomAmenity"]>
  export type RoomAmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | RoomAmenity$roomsArgs<ExtArgs>
    _count?: boolean | RoomAmenityCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RoomAmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomAmenity"
    objects: {
      rooms: Prisma.$RoomAmenitiesLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amenityName: string | null
      description: string | null
    }, ExtArgs["result"]["roomAmenity"]>
    composites: {}
  }

  type RoomAmenityGetPayload<S extends boolean | null | undefined | RoomAmenityDefaultArgs> = $Result.GetResult<Prisma.$RoomAmenityPayload, S>

  type RoomAmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomAmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomAmenityCountAggregateInputType | true
    }

  export interface RoomAmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomAmenity'], meta: { name: 'RoomAmenity' } }
    /**
     * Find zero or one RoomAmenity that matches the filter.
     * @param {RoomAmenityFindUniqueArgs} args - Arguments to find a RoomAmenity
     * @example
     * // Get one RoomAmenity
     * const roomAmenity = await prisma.roomAmenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomAmenityFindUniqueArgs>(args: SelectSubset<T, RoomAmenityFindUniqueArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoomAmenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomAmenityFindUniqueOrThrowArgs} args - Arguments to find a RoomAmenity
     * @example
     * // Get one RoomAmenity
     * const roomAmenity = await prisma.roomAmenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomAmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomAmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomAmenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityFindFirstArgs} args - Arguments to find a RoomAmenity
     * @example
     * // Get one RoomAmenity
     * const roomAmenity = await prisma.roomAmenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomAmenityFindFirstArgs>(args?: SelectSubset<T, RoomAmenityFindFirstArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomAmenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityFindFirstOrThrowArgs} args - Arguments to find a RoomAmenity
     * @example
     * // Get one RoomAmenity
     * const roomAmenity = await prisma.roomAmenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomAmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomAmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoomAmenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomAmenities
     * const roomAmenities = await prisma.roomAmenity.findMany()
     * 
     * // Get first 10 RoomAmenities
     * const roomAmenities = await prisma.roomAmenity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomAmenityWithIdOnly = await prisma.roomAmenity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomAmenityFindManyArgs>(args?: SelectSubset<T, RoomAmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoomAmenity.
     * @param {RoomAmenityCreateArgs} args - Arguments to create a RoomAmenity.
     * @example
     * // Create one RoomAmenity
     * const RoomAmenity = await prisma.roomAmenity.create({
     *   data: {
     *     // ... data to create a RoomAmenity
     *   }
     * })
     * 
     */
    create<T extends RoomAmenityCreateArgs>(args: SelectSubset<T, RoomAmenityCreateArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoomAmenities.
     * @param {RoomAmenityCreateManyArgs} args - Arguments to create many RoomAmenities.
     * @example
     * // Create many RoomAmenities
     * const roomAmenity = await prisma.roomAmenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomAmenityCreateManyArgs>(args?: SelectSubset<T, RoomAmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoomAmenity.
     * @param {RoomAmenityDeleteArgs} args - Arguments to delete one RoomAmenity.
     * @example
     * // Delete one RoomAmenity
     * const RoomAmenity = await prisma.roomAmenity.delete({
     *   where: {
     *     // ... filter to delete one RoomAmenity
     *   }
     * })
     * 
     */
    delete<T extends RoomAmenityDeleteArgs>(args: SelectSubset<T, RoomAmenityDeleteArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoomAmenity.
     * @param {RoomAmenityUpdateArgs} args - Arguments to update one RoomAmenity.
     * @example
     * // Update one RoomAmenity
     * const roomAmenity = await prisma.roomAmenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomAmenityUpdateArgs>(args: SelectSubset<T, RoomAmenityUpdateArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoomAmenities.
     * @param {RoomAmenityDeleteManyArgs} args - Arguments to filter RoomAmenities to delete.
     * @example
     * // Delete a few RoomAmenities
     * const { count } = await prisma.roomAmenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomAmenityDeleteManyArgs>(args?: SelectSubset<T, RoomAmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomAmenities
     * const roomAmenity = await prisma.roomAmenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomAmenityUpdateManyArgs>(args: SelectSubset<T, RoomAmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomAmenity.
     * @param {RoomAmenityUpsertArgs} args - Arguments to update or create a RoomAmenity.
     * @example
     * // Update or create a RoomAmenity
     * const roomAmenity = await prisma.roomAmenity.upsert({
     *   create: {
     *     // ... data to create a RoomAmenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomAmenity we want to update
     *   }
     * })
     */
    upsert<T extends RoomAmenityUpsertArgs>(args: SelectSubset<T, RoomAmenityUpsertArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoomAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityCountArgs} args - Arguments to filter RoomAmenities to count.
     * @example
     * // Count the number of RoomAmenities
     * const count = await prisma.roomAmenity.count({
     *   where: {
     *     // ... the filter for the RoomAmenities we want to count
     *   }
     * })
    **/
    count<T extends RoomAmenityCountArgs>(
      args?: Subset<T, RoomAmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomAmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAmenityAggregateArgs>(args: Subset<T, RoomAmenityAggregateArgs>): Prisma.PrismaPromise<GetRoomAmenityAggregateType<T>>

    /**
     * Group by RoomAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomAmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomAmenityGroupByArgs['orderBy'] }
        : { orderBy?: RoomAmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomAmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomAmenity model
   */
  readonly fields: RoomAmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomAmenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomAmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rooms<T extends RoomAmenity$roomsArgs<ExtArgs> = {}>(args?: Subset<T, RoomAmenity$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAmenitiesLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomAmenity model
   */
  interface RoomAmenityFieldRefs {
    readonly id: FieldRef<"RoomAmenity", 'Int'>
    readonly amenityName: FieldRef<"RoomAmenity", 'String'>
    readonly description: FieldRef<"RoomAmenity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RoomAmenity findUnique
   */
  export type RoomAmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenity to fetch.
     */
    where: RoomAmenityWhereUniqueInput
  }

  /**
   * RoomAmenity findUniqueOrThrow
   */
  export type RoomAmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenity to fetch.
     */
    where: RoomAmenityWhereUniqueInput
  }

  /**
   * RoomAmenity findFirst
   */
  export type RoomAmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenity to fetch.
     */
    where?: RoomAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAmenities to fetch.
     */
    orderBy?: RoomAmenityOrderByWithRelationInput | RoomAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomAmenities.
     */
    cursor?: RoomAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomAmenities.
     */
    distinct?: RoomAmenityScalarFieldEnum | RoomAmenityScalarFieldEnum[]
  }

  /**
   * RoomAmenity findFirstOrThrow
   */
  export type RoomAmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenity to fetch.
     */
    where?: RoomAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAmenities to fetch.
     */
    orderBy?: RoomAmenityOrderByWithRelationInput | RoomAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomAmenities.
     */
    cursor?: RoomAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomAmenities.
     */
    distinct?: RoomAmenityScalarFieldEnum | RoomAmenityScalarFieldEnum[]
  }

  /**
   * RoomAmenity findMany
   */
  export type RoomAmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenities to fetch.
     */
    where?: RoomAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAmenities to fetch.
     */
    orderBy?: RoomAmenityOrderByWithRelationInput | RoomAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomAmenities.
     */
    cursor?: RoomAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAmenities.
     */
    skip?: number
    distinct?: RoomAmenityScalarFieldEnum | RoomAmenityScalarFieldEnum[]
  }

  /**
   * RoomAmenity create
   */
  export type RoomAmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomAmenity.
     */
    data?: XOR<RoomAmenityCreateInput, RoomAmenityUncheckedCreateInput>
  }

  /**
   * RoomAmenity createMany
   */
  export type RoomAmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomAmenities.
     */
    data: RoomAmenityCreateManyInput | RoomAmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoomAmenity update
   */
  export type RoomAmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomAmenity.
     */
    data: XOR<RoomAmenityUpdateInput, RoomAmenityUncheckedUpdateInput>
    /**
     * Choose, which RoomAmenity to update.
     */
    where: RoomAmenityWhereUniqueInput
  }

  /**
   * RoomAmenity updateMany
   */
  export type RoomAmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomAmenities.
     */
    data: XOR<RoomAmenityUpdateManyMutationInput, RoomAmenityUncheckedUpdateManyInput>
    /**
     * Filter which RoomAmenities to update
     */
    where?: RoomAmenityWhereInput
    /**
     * Limit how many RoomAmenities to update.
     */
    limit?: number
  }

  /**
   * RoomAmenity upsert
   */
  export type RoomAmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomAmenity to update in case it exists.
     */
    where: RoomAmenityWhereUniqueInput
    /**
     * In case the RoomAmenity found by the `where` argument doesn't exist, create a new RoomAmenity with this data.
     */
    create: XOR<RoomAmenityCreateInput, RoomAmenityUncheckedCreateInput>
    /**
     * In case the RoomAmenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomAmenityUpdateInput, RoomAmenityUncheckedUpdateInput>
  }

  /**
   * RoomAmenity delete
   */
  export type RoomAmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * Filter which RoomAmenity to delete.
     */
    where: RoomAmenityWhereUniqueInput
  }

  /**
   * RoomAmenity deleteMany
   */
  export type RoomAmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomAmenities to delete
     */
    where?: RoomAmenityWhereInput
    /**
     * Limit how many RoomAmenities to delete.
     */
    limit?: number
  }

  /**
   * RoomAmenity.rooms
   */
  export type RoomAmenity$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenitiesLink
     */
    select?: RoomAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenitiesLink
     */
    omit?: RoomAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenitiesLinkInclude<ExtArgs> | null
    where?: RoomAmenitiesLinkWhereInput
    orderBy?: RoomAmenitiesLinkOrderByWithRelationInput | RoomAmenitiesLinkOrderByWithRelationInput[]
    cursor?: RoomAmenitiesLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomAmenitiesLinkScalarFieldEnum | RoomAmenitiesLinkScalarFieldEnum[]
  }

  /**
   * RoomAmenity without action
   */
  export type RoomAmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
  }


  /**
   * Model HotelAmenity
   */

  export type AggregateHotelAmenity = {
    _count: HotelAmenityCountAggregateOutputType | null
    _avg: HotelAmenityAvgAggregateOutputType | null
    _sum: HotelAmenitySumAggregateOutputType | null
    _min: HotelAmenityMinAggregateOutputType | null
    _max: HotelAmenityMaxAggregateOutputType | null
  }

  export type HotelAmenityAvgAggregateOutputType = {
    id: number | null
  }

  export type HotelAmenitySumAggregateOutputType = {
    id: number | null
  }

  export type HotelAmenityMinAggregateOutputType = {
    id: number | null
    amenityName: string | null
    description: string | null
  }

  export type HotelAmenityMaxAggregateOutputType = {
    id: number | null
    amenityName: string | null
    description: string | null
  }

  export type HotelAmenityCountAggregateOutputType = {
    id: number
    amenityName: number
    description: number
    _all: number
  }


  export type HotelAmenityAvgAggregateInputType = {
    id?: true
  }

  export type HotelAmenitySumAggregateInputType = {
    id?: true
  }

  export type HotelAmenityMinAggregateInputType = {
    id?: true
    amenityName?: true
    description?: true
  }

  export type HotelAmenityMaxAggregateInputType = {
    id?: true
    amenityName?: true
    description?: true
  }

  export type HotelAmenityCountAggregateInputType = {
    id?: true
    amenityName?: true
    description?: true
    _all?: true
  }

  export type HotelAmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelAmenity to aggregate.
     */
    where?: HotelAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelAmenities to fetch.
     */
    orderBy?: HotelAmenityOrderByWithRelationInput | HotelAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelAmenities
    **/
    _count?: true | HotelAmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelAmenityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelAmenitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelAmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelAmenityMaxAggregateInputType
  }

  export type GetHotelAmenityAggregateType<T extends HotelAmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelAmenity[P]>
      : GetScalarType<T[P], AggregateHotelAmenity[P]>
  }




  export type HotelAmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelAmenityWhereInput
    orderBy?: HotelAmenityOrderByWithAggregationInput | HotelAmenityOrderByWithAggregationInput[]
    by: HotelAmenityScalarFieldEnum[] | HotelAmenityScalarFieldEnum
    having?: HotelAmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelAmenityCountAggregateInputType | true
    _avg?: HotelAmenityAvgAggregateInputType
    _sum?: HotelAmenitySumAggregateInputType
    _min?: HotelAmenityMinAggregateInputType
    _max?: HotelAmenityMaxAggregateInputType
  }

  export type HotelAmenityGroupByOutputType = {
    id: number
    amenityName: string | null
    description: string | null
    _count: HotelAmenityCountAggregateOutputType | null
    _avg: HotelAmenityAvgAggregateOutputType | null
    _sum: HotelAmenitySumAggregateOutputType | null
    _min: HotelAmenityMinAggregateOutputType | null
    _max: HotelAmenityMaxAggregateOutputType | null
  }

  type GetHotelAmenityGroupByPayload<T extends HotelAmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelAmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelAmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelAmenityGroupByOutputType[P]>
            : GetScalarType<T[P], HotelAmenityGroupByOutputType[P]>
        }
      >
    >


  export type HotelAmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amenityName?: boolean
    description?: boolean
    hotels?: boolean | HotelAmenity$hotelsArgs<ExtArgs>
    _count?: boolean | HotelAmenityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelAmenity"]>



  export type HotelAmenitySelectScalar = {
    id?: boolean
    amenityName?: boolean
    description?: boolean
  }

  export type HotelAmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amenityName" | "description", ExtArgs["result"]["hotelAmenity"]>
  export type HotelAmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotels?: boolean | HotelAmenity$hotelsArgs<ExtArgs>
    _count?: boolean | HotelAmenityCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $HotelAmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelAmenity"
    objects: {
      hotels: Prisma.$HotelAmenitiesLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amenityName: string | null
      description: string | null
    }, ExtArgs["result"]["hotelAmenity"]>
    composites: {}
  }

  type HotelAmenityGetPayload<S extends boolean | null | undefined | HotelAmenityDefaultArgs> = $Result.GetResult<Prisma.$HotelAmenityPayload, S>

  type HotelAmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelAmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelAmenityCountAggregateInputType | true
    }

  export interface HotelAmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelAmenity'], meta: { name: 'HotelAmenity' } }
    /**
     * Find zero or one HotelAmenity that matches the filter.
     * @param {HotelAmenityFindUniqueArgs} args - Arguments to find a HotelAmenity
     * @example
     * // Get one HotelAmenity
     * const hotelAmenity = await prisma.hotelAmenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelAmenityFindUniqueArgs>(args: SelectSubset<T, HotelAmenityFindUniqueArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelAmenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelAmenityFindUniqueOrThrowArgs} args - Arguments to find a HotelAmenity
     * @example
     * // Get one HotelAmenity
     * const hotelAmenity = await prisma.hotelAmenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelAmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelAmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelAmenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityFindFirstArgs} args - Arguments to find a HotelAmenity
     * @example
     * // Get one HotelAmenity
     * const hotelAmenity = await prisma.hotelAmenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelAmenityFindFirstArgs>(args?: SelectSubset<T, HotelAmenityFindFirstArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelAmenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityFindFirstOrThrowArgs} args - Arguments to find a HotelAmenity
     * @example
     * // Get one HotelAmenity
     * const hotelAmenity = await prisma.hotelAmenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelAmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelAmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelAmenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelAmenities
     * const hotelAmenities = await prisma.hotelAmenity.findMany()
     * 
     * // Get first 10 HotelAmenities
     * const hotelAmenities = await prisma.hotelAmenity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelAmenityWithIdOnly = await prisma.hotelAmenity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelAmenityFindManyArgs>(args?: SelectSubset<T, HotelAmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelAmenity.
     * @param {HotelAmenityCreateArgs} args - Arguments to create a HotelAmenity.
     * @example
     * // Create one HotelAmenity
     * const HotelAmenity = await prisma.hotelAmenity.create({
     *   data: {
     *     // ... data to create a HotelAmenity
     *   }
     * })
     * 
     */
    create<T extends HotelAmenityCreateArgs>(args: SelectSubset<T, HotelAmenityCreateArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelAmenities.
     * @param {HotelAmenityCreateManyArgs} args - Arguments to create many HotelAmenities.
     * @example
     * // Create many HotelAmenities
     * const hotelAmenity = await prisma.hotelAmenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelAmenityCreateManyArgs>(args?: SelectSubset<T, HotelAmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HotelAmenity.
     * @param {HotelAmenityDeleteArgs} args - Arguments to delete one HotelAmenity.
     * @example
     * // Delete one HotelAmenity
     * const HotelAmenity = await prisma.hotelAmenity.delete({
     *   where: {
     *     // ... filter to delete one HotelAmenity
     *   }
     * })
     * 
     */
    delete<T extends HotelAmenityDeleteArgs>(args: SelectSubset<T, HotelAmenityDeleteArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelAmenity.
     * @param {HotelAmenityUpdateArgs} args - Arguments to update one HotelAmenity.
     * @example
     * // Update one HotelAmenity
     * const hotelAmenity = await prisma.hotelAmenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelAmenityUpdateArgs>(args: SelectSubset<T, HotelAmenityUpdateArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelAmenities.
     * @param {HotelAmenityDeleteManyArgs} args - Arguments to filter HotelAmenities to delete.
     * @example
     * // Delete a few HotelAmenities
     * const { count } = await prisma.hotelAmenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelAmenityDeleteManyArgs>(args?: SelectSubset<T, HotelAmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelAmenities
     * const hotelAmenity = await prisma.hotelAmenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelAmenityUpdateManyArgs>(args: SelectSubset<T, HotelAmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotelAmenity.
     * @param {HotelAmenityUpsertArgs} args - Arguments to update or create a HotelAmenity.
     * @example
     * // Update or create a HotelAmenity
     * const hotelAmenity = await prisma.hotelAmenity.upsert({
     *   create: {
     *     // ... data to create a HotelAmenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelAmenity we want to update
     *   }
     * })
     */
    upsert<T extends HotelAmenityUpsertArgs>(args: SelectSubset<T, HotelAmenityUpsertArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityCountArgs} args - Arguments to filter HotelAmenities to count.
     * @example
     * // Count the number of HotelAmenities
     * const count = await prisma.hotelAmenity.count({
     *   where: {
     *     // ... the filter for the HotelAmenities we want to count
     *   }
     * })
    **/
    count<T extends HotelAmenityCountArgs>(
      args?: Subset<T, HotelAmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelAmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelAmenityAggregateArgs>(args: Subset<T, HotelAmenityAggregateArgs>): Prisma.PrismaPromise<GetHotelAmenityAggregateType<T>>

    /**
     * Group by HotelAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelAmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelAmenityGroupByArgs['orderBy'] }
        : { orderBy?: HotelAmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelAmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelAmenity model
   */
  readonly fields: HotelAmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelAmenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelAmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotels<T extends HotelAmenity$hotelsArgs<ExtArgs> = {}>(args?: Subset<T, HotelAmenity$hotelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelAmenitiesLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelAmenity model
   */
  interface HotelAmenityFieldRefs {
    readonly id: FieldRef<"HotelAmenity", 'Int'>
    readonly amenityName: FieldRef<"HotelAmenity", 'String'>
    readonly description: FieldRef<"HotelAmenity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HotelAmenity findUnique
   */
  export type HotelAmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenity to fetch.
     */
    where: HotelAmenityWhereUniqueInput
  }

  /**
   * HotelAmenity findUniqueOrThrow
   */
  export type HotelAmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenity to fetch.
     */
    where: HotelAmenityWhereUniqueInput
  }

  /**
   * HotelAmenity findFirst
   */
  export type HotelAmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenity to fetch.
     */
    where?: HotelAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelAmenities to fetch.
     */
    orderBy?: HotelAmenityOrderByWithRelationInput | HotelAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelAmenities.
     */
    cursor?: HotelAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelAmenities.
     */
    distinct?: HotelAmenityScalarFieldEnum | HotelAmenityScalarFieldEnum[]
  }

  /**
   * HotelAmenity findFirstOrThrow
   */
  export type HotelAmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenity to fetch.
     */
    where?: HotelAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelAmenities to fetch.
     */
    orderBy?: HotelAmenityOrderByWithRelationInput | HotelAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelAmenities.
     */
    cursor?: HotelAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelAmenities.
     */
    distinct?: HotelAmenityScalarFieldEnum | HotelAmenityScalarFieldEnum[]
  }

  /**
   * HotelAmenity findMany
   */
  export type HotelAmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenities to fetch.
     */
    where?: HotelAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelAmenities to fetch.
     */
    orderBy?: HotelAmenityOrderByWithRelationInput | HotelAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelAmenities.
     */
    cursor?: HotelAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelAmenities.
     */
    skip?: number
    distinct?: HotelAmenityScalarFieldEnum | HotelAmenityScalarFieldEnum[]
  }

  /**
   * HotelAmenity create
   */
  export type HotelAmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelAmenity.
     */
    data?: XOR<HotelAmenityCreateInput, HotelAmenityUncheckedCreateInput>
  }

  /**
   * HotelAmenity createMany
   */
  export type HotelAmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelAmenities.
     */
    data: HotelAmenityCreateManyInput | HotelAmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotelAmenity update
   */
  export type HotelAmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelAmenity.
     */
    data: XOR<HotelAmenityUpdateInput, HotelAmenityUncheckedUpdateInput>
    /**
     * Choose, which HotelAmenity to update.
     */
    where: HotelAmenityWhereUniqueInput
  }

  /**
   * HotelAmenity updateMany
   */
  export type HotelAmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelAmenities.
     */
    data: XOR<HotelAmenityUpdateManyMutationInput, HotelAmenityUncheckedUpdateManyInput>
    /**
     * Filter which HotelAmenities to update
     */
    where?: HotelAmenityWhereInput
    /**
     * Limit how many HotelAmenities to update.
     */
    limit?: number
  }

  /**
   * HotelAmenity upsert
   */
  export type HotelAmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelAmenity to update in case it exists.
     */
    where: HotelAmenityWhereUniqueInput
    /**
     * In case the HotelAmenity found by the `where` argument doesn't exist, create a new HotelAmenity with this data.
     */
    create: XOR<HotelAmenityCreateInput, HotelAmenityUncheckedCreateInput>
    /**
     * In case the HotelAmenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelAmenityUpdateInput, HotelAmenityUncheckedUpdateInput>
  }

  /**
   * HotelAmenity delete
   */
  export type HotelAmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * Filter which HotelAmenity to delete.
     */
    where: HotelAmenityWhereUniqueInput
  }

  /**
   * HotelAmenity deleteMany
   */
  export type HotelAmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelAmenities to delete
     */
    where?: HotelAmenityWhereInput
    /**
     * Limit how many HotelAmenities to delete.
     */
    limit?: number
  }

  /**
   * HotelAmenity.hotels
   */
  export type HotelAmenity$hotelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenitiesLink
     */
    select?: HotelAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenitiesLink
     */
    omit?: HotelAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenitiesLinkInclude<ExtArgs> | null
    where?: HotelAmenitiesLinkWhereInput
    orderBy?: HotelAmenitiesLinkOrderByWithRelationInput | HotelAmenitiesLinkOrderByWithRelationInput[]
    cursor?: HotelAmenitiesLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelAmenitiesLinkScalarFieldEnum | HotelAmenitiesLinkScalarFieldEnum[]
  }

  /**
   * HotelAmenity without action
   */
  export type HotelAmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
  }


  /**
   * Model HotelPolicy
   */

  export type AggregateHotelPolicy = {
    _count: HotelPolicyCountAggregateOutputType | null
    _avg: HotelPolicyAvgAggregateOutputType | null
    _sum: HotelPolicySumAggregateOutputType | null
    _min: HotelPolicyMinAggregateOutputType | null
    _max: HotelPolicyMaxAggregateOutputType | null
  }

  export type HotelPolicyAvgAggregateOutputType = {
    id: number | null
    hotelId: number | null
  }

  export type HotelPolicySumAggregateOutputType = {
    id: number | null
    hotelId: number | null
  }

  export type HotelPolicyMinAggregateOutputType = {
    id: number | null
    hotelId: number | null
    policyDescription: string | null
  }

  export type HotelPolicyMaxAggregateOutputType = {
    id: number | null
    hotelId: number | null
    policyDescription: string | null
  }

  export type HotelPolicyCountAggregateOutputType = {
    id: number
    hotelId: number
    policyDescription: number
    _all: number
  }


  export type HotelPolicyAvgAggregateInputType = {
    id?: true
    hotelId?: true
  }

  export type HotelPolicySumAggregateInputType = {
    id?: true
    hotelId?: true
  }

  export type HotelPolicyMinAggregateInputType = {
    id?: true
    hotelId?: true
    policyDescription?: true
  }

  export type HotelPolicyMaxAggregateInputType = {
    id?: true
    hotelId?: true
    policyDescription?: true
  }

  export type HotelPolicyCountAggregateInputType = {
    id?: true
    hotelId?: true
    policyDescription?: true
    _all?: true
  }

  export type HotelPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelPolicy to aggregate.
     */
    where?: HotelPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelPolicies to fetch.
     */
    orderBy?: HotelPolicyOrderByWithRelationInput | HotelPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelPolicies
    **/
    _count?: true | HotelPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelPolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelPolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelPolicyMaxAggregateInputType
  }

  export type GetHotelPolicyAggregateType<T extends HotelPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelPolicy[P]>
      : GetScalarType<T[P], AggregateHotelPolicy[P]>
  }




  export type HotelPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelPolicyWhereInput
    orderBy?: HotelPolicyOrderByWithAggregationInput | HotelPolicyOrderByWithAggregationInput[]
    by: HotelPolicyScalarFieldEnum[] | HotelPolicyScalarFieldEnum
    having?: HotelPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelPolicyCountAggregateInputType | true
    _avg?: HotelPolicyAvgAggregateInputType
    _sum?: HotelPolicySumAggregateInputType
    _min?: HotelPolicyMinAggregateInputType
    _max?: HotelPolicyMaxAggregateInputType
  }

  export type HotelPolicyGroupByOutputType = {
    id: number
    hotelId: number | null
    policyDescription: string | null
    _count: HotelPolicyCountAggregateOutputType | null
    _avg: HotelPolicyAvgAggregateOutputType | null
    _sum: HotelPolicySumAggregateOutputType | null
    _min: HotelPolicyMinAggregateOutputType | null
    _max: HotelPolicyMaxAggregateOutputType | null
  }

  type GetHotelPolicyGroupByPayload<T extends HotelPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], HotelPolicyGroupByOutputType[P]>
        }
      >
    >


  export type HotelPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    policyDescription?: boolean
    hotel?: boolean | HotelPolicy$hotelArgs<ExtArgs>
  }, ExtArgs["result"]["hotelPolicy"]>



  export type HotelPolicySelectScalar = {
    id?: boolean
    hotelId?: boolean
    policyDescription?: boolean
  }

  export type HotelPolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hotelId" | "policyDescription", ExtArgs["result"]["hotelPolicy"]>
  export type HotelPolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelPolicy$hotelArgs<ExtArgs>
  }

  export type $HotelPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelPolicy"
    objects: {
      hotel: Prisma.$HotelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hotelId: number | null
      policyDescription: string | null
    }, ExtArgs["result"]["hotelPolicy"]>
    composites: {}
  }

  type HotelPolicyGetPayload<S extends boolean | null | undefined | HotelPolicyDefaultArgs> = $Result.GetResult<Prisma.$HotelPolicyPayload, S>

  type HotelPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelPolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelPolicyCountAggregateInputType | true
    }

  export interface HotelPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelPolicy'], meta: { name: 'HotelPolicy' } }
    /**
     * Find zero or one HotelPolicy that matches the filter.
     * @param {HotelPolicyFindUniqueArgs} args - Arguments to find a HotelPolicy
     * @example
     * // Get one HotelPolicy
     * const hotelPolicy = await prisma.hotelPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelPolicyFindUniqueArgs>(args: SelectSubset<T, HotelPolicyFindUniqueArgs<ExtArgs>>): Prisma__HotelPolicyClient<$Result.GetResult<Prisma.$HotelPolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelPolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelPolicyFindUniqueOrThrowArgs} args - Arguments to find a HotelPolicy
     * @example
     * // Get one HotelPolicy
     * const hotelPolicy = await prisma.hotelPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelPolicyClient<$Result.GetResult<Prisma.$HotelPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelPolicyFindFirstArgs} args - Arguments to find a HotelPolicy
     * @example
     * // Get one HotelPolicy
     * const hotelPolicy = await prisma.hotelPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelPolicyFindFirstArgs>(args?: SelectSubset<T, HotelPolicyFindFirstArgs<ExtArgs>>): Prisma__HotelPolicyClient<$Result.GetResult<Prisma.$HotelPolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelPolicyFindFirstOrThrowArgs} args - Arguments to find a HotelPolicy
     * @example
     * // Get one HotelPolicy
     * const hotelPolicy = await prisma.hotelPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelPolicyClient<$Result.GetResult<Prisma.$HotelPolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelPolicies
     * const hotelPolicies = await prisma.hotelPolicy.findMany()
     * 
     * // Get first 10 HotelPolicies
     * const hotelPolicies = await prisma.hotelPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelPolicyWithIdOnly = await prisma.hotelPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelPolicyFindManyArgs>(args?: SelectSubset<T, HotelPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelPolicy.
     * @param {HotelPolicyCreateArgs} args - Arguments to create a HotelPolicy.
     * @example
     * // Create one HotelPolicy
     * const HotelPolicy = await prisma.hotelPolicy.create({
     *   data: {
     *     // ... data to create a HotelPolicy
     *   }
     * })
     * 
     */
    create<T extends HotelPolicyCreateArgs>(args: SelectSubset<T, HotelPolicyCreateArgs<ExtArgs>>): Prisma__HotelPolicyClient<$Result.GetResult<Prisma.$HotelPolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelPolicies.
     * @param {HotelPolicyCreateManyArgs} args - Arguments to create many HotelPolicies.
     * @example
     * // Create many HotelPolicies
     * const hotelPolicy = await prisma.hotelPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelPolicyCreateManyArgs>(args?: SelectSubset<T, HotelPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HotelPolicy.
     * @param {HotelPolicyDeleteArgs} args - Arguments to delete one HotelPolicy.
     * @example
     * // Delete one HotelPolicy
     * const HotelPolicy = await prisma.hotelPolicy.delete({
     *   where: {
     *     // ... filter to delete one HotelPolicy
     *   }
     * })
     * 
     */
    delete<T extends HotelPolicyDeleteArgs>(args: SelectSubset<T, HotelPolicyDeleteArgs<ExtArgs>>): Prisma__HotelPolicyClient<$Result.GetResult<Prisma.$HotelPolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelPolicy.
     * @param {HotelPolicyUpdateArgs} args - Arguments to update one HotelPolicy.
     * @example
     * // Update one HotelPolicy
     * const hotelPolicy = await prisma.hotelPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelPolicyUpdateArgs>(args: SelectSubset<T, HotelPolicyUpdateArgs<ExtArgs>>): Prisma__HotelPolicyClient<$Result.GetResult<Prisma.$HotelPolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelPolicies.
     * @param {HotelPolicyDeleteManyArgs} args - Arguments to filter HotelPolicies to delete.
     * @example
     * // Delete a few HotelPolicies
     * const { count } = await prisma.hotelPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelPolicyDeleteManyArgs>(args?: SelectSubset<T, HotelPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelPolicies
     * const hotelPolicy = await prisma.hotelPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelPolicyUpdateManyArgs>(args: SelectSubset<T, HotelPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotelPolicy.
     * @param {HotelPolicyUpsertArgs} args - Arguments to update or create a HotelPolicy.
     * @example
     * // Update or create a HotelPolicy
     * const hotelPolicy = await prisma.hotelPolicy.upsert({
     *   create: {
     *     // ... data to create a HotelPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelPolicy we want to update
     *   }
     * })
     */
    upsert<T extends HotelPolicyUpsertArgs>(args: SelectSubset<T, HotelPolicyUpsertArgs<ExtArgs>>): Prisma__HotelPolicyClient<$Result.GetResult<Prisma.$HotelPolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelPolicyCountArgs} args - Arguments to filter HotelPolicies to count.
     * @example
     * // Count the number of HotelPolicies
     * const count = await prisma.hotelPolicy.count({
     *   where: {
     *     // ... the filter for the HotelPolicies we want to count
     *   }
     * })
    **/
    count<T extends HotelPolicyCountArgs>(
      args?: Subset<T, HotelPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelPolicyAggregateArgs>(args: Subset<T, HotelPolicyAggregateArgs>): Prisma.PrismaPromise<GetHotelPolicyAggregateType<T>>

    /**
     * Group by HotelPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelPolicyGroupByArgs['orderBy'] }
        : { orderBy?: HotelPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelPolicy model
   */
  readonly fields: HotelPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends HotelPolicy$hotelArgs<ExtArgs> = {}>(args?: Subset<T, HotelPolicy$hotelArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelPolicy model
   */
  interface HotelPolicyFieldRefs {
    readonly id: FieldRef<"HotelPolicy", 'Int'>
    readonly hotelId: FieldRef<"HotelPolicy", 'Int'>
    readonly policyDescription: FieldRef<"HotelPolicy", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HotelPolicy findUnique
   */
  export type HotelPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPolicy
     */
    select?: HotelPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPolicy
     */
    omit?: HotelPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPolicyInclude<ExtArgs> | null
    /**
     * Filter, which HotelPolicy to fetch.
     */
    where: HotelPolicyWhereUniqueInput
  }

  /**
   * HotelPolicy findUniqueOrThrow
   */
  export type HotelPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPolicy
     */
    select?: HotelPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPolicy
     */
    omit?: HotelPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPolicyInclude<ExtArgs> | null
    /**
     * Filter, which HotelPolicy to fetch.
     */
    where: HotelPolicyWhereUniqueInput
  }

  /**
   * HotelPolicy findFirst
   */
  export type HotelPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPolicy
     */
    select?: HotelPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPolicy
     */
    omit?: HotelPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPolicyInclude<ExtArgs> | null
    /**
     * Filter, which HotelPolicy to fetch.
     */
    where?: HotelPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelPolicies to fetch.
     */
    orderBy?: HotelPolicyOrderByWithRelationInput | HotelPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelPolicies.
     */
    cursor?: HotelPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelPolicies.
     */
    distinct?: HotelPolicyScalarFieldEnum | HotelPolicyScalarFieldEnum[]
  }

  /**
   * HotelPolicy findFirstOrThrow
   */
  export type HotelPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPolicy
     */
    select?: HotelPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPolicy
     */
    omit?: HotelPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPolicyInclude<ExtArgs> | null
    /**
     * Filter, which HotelPolicy to fetch.
     */
    where?: HotelPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelPolicies to fetch.
     */
    orderBy?: HotelPolicyOrderByWithRelationInput | HotelPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelPolicies.
     */
    cursor?: HotelPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelPolicies.
     */
    distinct?: HotelPolicyScalarFieldEnum | HotelPolicyScalarFieldEnum[]
  }

  /**
   * HotelPolicy findMany
   */
  export type HotelPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPolicy
     */
    select?: HotelPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPolicy
     */
    omit?: HotelPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPolicyInclude<ExtArgs> | null
    /**
     * Filter, which HotelPolicies to fetch.
     */
    where?: HotelPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelPolicies to fetch.
     */
    orderBy?: HotelPolicyOrderByWithRelationInput | HotelPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelPolicies.
     */
    cursor?: HotelPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelPolicies.
     */
    skip?: number
    distinct?: HotelPolicyScalarFieldEnum | HotelPolicyScalarFieldEnum[]
  }

  /**
   * HotelPolicy create
   */
  export type HotelPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPolicy
     */
    select?: HotelPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPolicy
     */
    omit?: HotelPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelPolicy.
     */
    data?: XOR<HotelPolicyCreateInput, HotelPolicyUncheckedCreateInput>
  }

  /**
   * HotelPolicy createMany
   */
  export type HotelPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelPolicies.
     */
    data: HotelPolicyCreateManyInput | HotelPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotelPolicy update
   */
  export type HotelPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPolicy
     */
    select?: HotelPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPolicy
     */
    omit?: HotelPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelPolicy.
     */
    data: XOR<HotelPolicyUpdateInput, HotelPolicyUncheckedUpdateInput>
    /**
     * Choose, which HotelPolicy to update.
     */
    where: HotelPolicyWhereUniqueInput
  }

  /**
   * HotelPolicy updateMany
   */
  export type HotelPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelPolicies.
     */
    data: XOR<HotelPolicyUpdateManyMutationInput, HotelPolicyUncheckedUpdateManyInput>
    /**
     * Filter which HotelPolicies to update
     */
    where?: HotelPolicyWhereInput
    /**
     * Limit how many HotelPolicies to update.
     */
    limit?: number
  }

  /**
   * HotelPolicy upsert
   */
  export type HotelPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPolicy
     */
    select?: HotelPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPolicy
     */
    omit?: HotelPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelPolicy to update in case it exists.
     */
    where: HotelPolicyWhereUniqueInput
    /**
     * In case the HotelPolicy found by the `where` argument doesn't exist, create a new HotelPolicy with this data.
     */
    create: XOR<HotelPolicyCreateInput, HotelPolicyUncheckedCreateInput>
    /**
     * In case the HotelPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelPolicyUpdateInput, HotelPolicyUncheckedUpdateInput>
  }

  /**
   * HotelPolicy delete
   */
  export type HotelPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPolicy
     */
    select?: HotelPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPolicy
     */
    omit?: HotelPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPolicyInclude<ExtArgs> | null
    /**
     * Filter which HotelPolicy to delete.
     */
    where: HotelPolicyWhereUniqueInput
  }

  /**
   * HotelPolicy deleteMany
   */
  export type HotelPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelPolicies to delete
     */
    where?: HotelPolicyWhereInput
    /**
     * Limit how many HotelPolicies to delete.
     */
    limit?: number
  }

  /**
   * HotelPolicy.hotel
   */
  export type HotelPolicy$hotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
  }

  /**
   * HotelPolicy without action
   */
  export type HotelPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelPolicy
     */
    select?: HotelPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelPolicy
     */
    omit?: HotelPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelPolicyInclude<ExtArgs> | null
  }


  /**
   * Model PromotionApplied
   */

  export type AggregatePromotionApplied = {
    _count: PromotionAppliedCountAggregateOutputType | null
    _avg: PromotionAppliedAvgAggregateOutputType | null
    _sum: PromotionAppliedSumAggregateOutputType | null
    _min: PromotionAppliedMinAggregateOutputType | null
    _max: PromotionAppliedMaxAggregateOutputType | null
  }

  export type PromotionAppliedAvgAggregateOutputType = {
    id: number | null
    promotionId: number | null
    bookingId: number | null
  }

  export type PromotionAppliedSumAggregateOutputType = {
    id: number | null
    promotionId: number | null
    bookingId: number | null
  }

  export type PromotionAppliedMinAggregateOutputType = {
    id: number | null
    promotionId: number | null
    bookingId: number | null
  }

  export type PromotionAppliedMaxAggregateOutputType = {
    id: number | null
    promotionId: number | null
    bookingId: number | null
  }

  export type PromotionAppliedCountAggregateOutputType = {
    id: number
    promotionId: number
    bookingId: number
    _all: number
  }


  export type PromotionAppliedAvgAggregateInputType = {
    id?: true
    promotionId?: true
    bookingId?: true
  }

  export type PromotionAppliedSumAggregateInputType = {
    id?: true
    promotionId?: true
    bookingId?: true
  }

  export type PromotionAppliedMinAggregateInputType = {
    id?: true
    promotionId?: true
    bookingId?: true
  }

  export type PromotionAppliedMaxAggregateInputType = {
    id?: true
    promotionId?: true
    bookingId?: true
  }

  export type PromotionAppliedCountAggregateInputType = {
    id?: true
    promotionId?: true
    bookingId?: true
    _all?: true
  }

  export type PromotionAppliedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionApplied to aggregate.
     */
    where?: PromotionAppliedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionApplieds to fetch.
     */
    orderBy?: PromotionAppliedOrderByWithRelationInput | PromotionAppliedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionAppliedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionApplieds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionApplieds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromotionApplieds
    **/
    _count?: true | PromotionAppliedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionAppliedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionAppliedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionAppliedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionAppliedMaxAggregateInputType
  }

  export type GetPromotionAppliedAggregateType<T extends PromotionAppliedAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotionApplied]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotionApplied[P]>
      : GetScalarType<T[P], AggregatePromotionApplied[P]>
  }




  export type PromotionAppliedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionAppliedWhereInput
    orderBy?: PromotionAppliedOrderByWithAggregationInput | PromotionAppliedOrderByWithAggregationInput[]
    by: PromotionAppliedScalarFieldEnum[] | PromotionAppliedScalarFieldEnum
    having?: PromotionAppliedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionAppliedCountAggregateInputType | true
    _avg?: PromotionAppliedAvgAggregateInputType
    _sum?: PromotionAppliedSumAggregateInputType
    _min?: PromotionAppliedMinAggregateInputType
    _max?: PromotionAppliedMaxAggregateInputType
  }

  export type PromotionAppliedGroupByOutputType = {
    id: number
    promotionId: number
    bookingId: number | null
    _count: PromotionAppliedCountAggregateOutputType | null
    _avg: PromotionAppliedAvgAggregateOutputType | null
    _sum: PromotionAppliedSumAggregateOutputType | null
    _min: PromotionAppliedMinAggregateOutputType | null
    _max: PromotionAppliedMaxAggregateOutputType | null
  }

  type GetPromotionAppliedGroupByPayload<T extends PromotionAppliedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionAppliedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionAppliedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionAppliedGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionAppliedGroupByOutputType[P]>
        }
      >
    >


  export type PromotionAppliedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    bookingId?: boolean
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    booking?: boolean | PromotionApplied$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["promotionApplied"]>



  export type PromotionAppliedSelectScalar = {
    id?: boolean
    promotionId?: boolean
    bookingId?: boolean
  }

  export type PromotionAppliedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "promotionId" | "bookingId", ExtArgs["result"]["promotionApplied"]>
  export type PromotionAppliedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    booking?: boolean | PromotionApplied$bookingArgs<ExtArgs>
  }

  export type $PromotionAppliedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromotionApplied"
    objects: {
      promotion: Prisma.$PromotionPayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      promotionId: number
      bookingId: number | null
    }, ExtArgs["result"]["promotionApplied"]>
    composites: {}
  }

  type PromotionAppliedGetPayload<S extends boolean | null | undefined | PromotionAppliedDefaultArgs> = $Result.GetResult<Prisma.$PromotionAppliedPayload, S>

  type PromotionAppliedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromotionAppliedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromotionAppliedCountAggregateInputType | true
    }

  export interface PromotionAppliedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromotionApplied'], meta: { name: 'PromotionApplied' } }
    /**
     * Find zero or one PromotionApplied that matches the filter.
     * @param {PromotionAppliedFindUniqueArgs} args - Arguments to find a PromotionApplied
     * @example
     * // Get one PromotionApplied
     * const promotionApplied = await prisma.promotionApplied.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionAppliedFindUniqueArgs>(args: SelectSubset<T, PromotionAppliedFindUniqueArgs<ExtArgs>>): Prisma__PromotionAppliedClient<$Result.GetResult<Prisma.$PromotionAppliedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromotionApplied that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromotionAppliedFindUniqueOrThrowArgs} args - Arguments to find a PromotionApplied
     * @example
     * // Get one PromotionApplied
     * const promotionApplied = await prisma.promotionApplied.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionAppliedFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionAppliedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionAppliedClient<$Result.GetResult<Prisma.$PromotionAppliedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromotionApplied that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAppliedFindFirstArgs} args - Arguments to find a PromotionApplied
     * @example
     * // Get one PromotionApplied
     * const promotionApplied = await prisma.promotionApplied.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionAppliedFindFirstArgs>(args?: SelectSubset<T, PromotionAppliedFindFirstArgs<ExtArgs>>): Prisma__PromotionAppliedClient<$Result.GetResult<Prisma.$PromotionAppliedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromotionApplied that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAppliedFindFirstOrThrowArgs} args - Arguments to find a PromotionApplied
     * @example
     * // Get one PromotionApplied
     * const promotionApplied = await prisma.promotionApplied.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionAppliedFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionAppliedFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionAppliedClient<$Result.GetResult<Prisma.$PromotionAppliedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromotionApplieds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAppliedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromotionApplieds
     * const promotionApplieds = await prisma.promotionApplied.findMany()
     * 
     * // Get first 10 PromotionApplieds
     * const promotionApplieds = await prisma.promotionApplied.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionAppliedWithIdOnly = await prisma.promotionApplied.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionAppliedFindManyArgs>(args?: SelectSubset<T, PromotionAppliedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionAppliedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromotionApplied.
     * @param {PromotionAppliedCreateArgs} args - Arguments to create a PromotionApplied.
     * @example
     * // Create one PromotionApplied
     * const PromotionApplied = await prisma.promotionApplied.create({
     *   data: {
     *     // ... data to create a PromotionApplied
     *   }
     * })
     * 
     */
    create<T extends PromotionAppliedCreateArgs>(args: SelectSubset<T, PromotionAppliedCreateArgs<ExtArgs>>): Prisma__PromotionAppliedClient<$Result.GetResult<Prisma.$PromotionAppliedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromotionApplieds.
     * @param {PromotionAppliedCreateManyArgs} args - Arguments to create many PromotionApplieds.
     * @example
     * // Create many PromotionApplieds
     * const promotionApplied = await prisma.promotionApplied.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionAppliedCreateManyArgs>(args?: SelectSubset<T, PromotionAppliedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PromotionApplied.
     * @param {PromotionAppliedDeleteArgs} args - Arguments to delete one PromotionApplied.
     * @example
     * // Delete one PromotionApplied
     * const PromotionApplied = await prisma.promotionApplied.delete({
     *   where: {
     *     // ... filter to delete one PromotionApplied
     *   }
     * })
     * 
     */
    delete<T extends PromotionAppliedDeleteArgs>(args: SelectSubset<T, PromotionAppliedDeleteArgs<ExtArgs>>): Prisma__PromotionAppliedClient<$Result.GetResult<Prisma.$PromotionAppliedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromotionApplied.
     * @param {PromotionAppliedUpdateArgs} args - Arguments to update one PromotionApplied.
     * @example
     * // Update one PromotionApplied
     * const promotionApplied = await prisma.promotionApplied.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionAppliedUpdateArgs>(args: SelectSubset<T, PromotionAppliedUpdateArgs<ExtArgs>>): Prisma__PromotionAppliedClient<$Result.GetResult<Prisma.$PromotionAppliedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromotionApplieds.
     * @param {PromotionAppliedDeleteManyArgs} args - Arguments to filter PromotionApplieds to delete.
     * @example
     * // Delete a few PromotionApplieds
     * const { count } = await prisma.promotionApplied.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionAppliedDeleteManyArgs>(args?: SelectSubset<T, PromotionAppliedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromotionApplieds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAppliedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromotionApplieds
     * const promotionApplied = await prisma.promotionApplied.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionAppliedUpdateManyArgs>(args: SelectSubset<T, PromotionAppliedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromotionApplied.
     * @param {PromotionAppliedUpsertArgs} args - Arguments to update or create a PromotionApplied.
     * @example
     * // Update or create a PromotionApplied
     * const promotionApplied = await prisma.promotionApplied.upsert({
     *   create: {
     *     // ... data to create a PromotionApplied
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromotionApplied we want to update
     *   }
     * })
     */
    upsert<T extends PromotionAppliedUpsertArgs>(args: SelectSubset<T, PromotionAppliedUpsertArgs<ExtArgs>>): Prisma__PromotionAppliedClient<$Result.GetResult<Prisma.$PromotionAppliedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PromotionApplieds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAppliedCountArgs} args - Arguments to filter PromotionApplieds to count.
     * @example
     * // Count the number of PromotionApplieds
     * const count = await prisma.promotionApplied.count({
     *   where: {
     *     // ... the filter for the PromotionApplieds we want to count
     *   }
     * })
    **/
    count<T extends PromotionAppliedCountArgs>(
      args?: Subset<T, PromotionAppliedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionAppliedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromotionApplied.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAppliedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionAppliedAggregateArgs>(args: Subset<T, PromotionAppliedAggregateArgs>): Prisma.PrismaPromise<GetPromotionAppliedAggregateType<T>>

    /**
     * Group by PromotionApplied.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAppliedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionAppliedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionAppliedGroupByArgs['orderBy'] }
        : { orderBy?: PromotionAppliedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionAppliedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionAppliedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromotionApplied model
   */
  readonly fields: PromotionAppliedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromotionApplied.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionAppliedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    promotion<T extends PromotionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromotionDefaultArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    booking<T extends PromotionApplied$bookingArgs<ExtArgs> = {}>(args?: Subset<T, PromotionApplied$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromotionApplied model
   */
  interface PromotionAppliedFieldRefs {
    readonly id: FieldRef<"PromotionApplied", 'Int'>
    readonly promotionId: FieldRef<"PromotionApplied", 'Int'>
    readonly bookingId: FieldRef<"PromotionApplied", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PromotionApplied findUnique
   */
  export type PromotionAppliedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionApplied
     */
    select?: PromotionAppliedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionApplied
     */
    omit?: PromotionAppliedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionAppliedInclude<ExtArgs> | null
    /**
     * Filter, which PromotionApplied to fetch.
     */
    where: PromotionAppliedWhereUniqueInput
  }

  /**
   * PromotionApplied findUniqueOrThrow
   */
  export type PromotionAppliedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionApplied
     */
    select?: PromotionAppliedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionApplied
     */
    omit?: PromotionAppliedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionAppliedInclude<ExtArgs> | null
    /**
     * Filter, which PromotionApplied to fetch.
     */
    where: PromotionAppliedWhereUniqueInput
  }

  /**
   * PromotionApplied findFirst
   */
  export type PromotionAppliedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionApplied
     */
    select?: PromotionAppliedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionApplied
     */
    omit?: PromotionAppliedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionAppliedInclude<ExtArgs> | null
    /**
     * Filter, which PromotionApplied to fetch.
     */
    where?: PromotionAppliedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionApplieds to fetch.
     */
    orderBy?: PromotionAppliedOrderByWithRelationInput | PromotionAppliedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionApplieds.
     */
    cursor?: PromotionAppliedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionApplieds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionApplieds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionApplieds.
     */
    distinct?: PromotionAppliedScalarFieldEnum | PromotionAppliedScalarFieldEnum[]
  }

  /**
   * PromotionApplied findFirstOrThrow
   */
  export type PromotionAppliedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionApplied
     */
    select?: PromotionAppliedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionApplied
     */
    omit?: PromotionAppliedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionAppliedInclude<ExtArgs> | null
    /**
     * Filter, which PromotionApplied to fetch.
     */
    where?: PromotionAppliedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionApplieds to fetch.
     */
    orderBy?: PromotionAppliedOrderByWithRelationInput | PromotionAppliedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionApplieds.
     */
    cursor?: PromotionAppliedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionApplieds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionApplieds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionApplieds.
     */
    distinct?: PromotionAppliedScalarFieldEnum | PromotionAppliedScalarFieldEnum[]
  }

  /**
   * PromotionApplied findMany
   */
  export type PromotionAppliedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionApplied
     */
    select?: PromotionAppliedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionApplied
     */
    omit?: PromotionAppliedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionAppliedInclude<ExtArgs> | null
    /**
     * Filter, which PromotionApplieds to fetch.
     */
    where?: PromotionAppliedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionApplieds to fetch.
     */
    orderBy?: PromotionAppliedOrderByWithRelationInput | PromotionAppliedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromotionApplieds.
     */
    cursor?: PromotionAppliedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionApplieds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionApplieds.
     */
    skip?: number
    distinct?: PromotionAppliedScalarFieldEnum | PromotionAppliedScalarFieldEnum[]
  }

  /**
   * PromotionApplied create
   */
  export type PromotionAppliedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionApplied
     */
    select?: PromotionAppliedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionApplied
     */
    omit?: PromotionAppliedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionAppliedInclude<ExtArgs> | null
    /**
     * The data needed to create a PromotionApplied.
     */
    data: XOR<PromotionAppliedCreateInput, PromotionAppliedUncheckedCreateInput>
  }

  /**
   * PromotionApplied createMany
   */
  export type PromotionAppliedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromotionApplieds.
     */
    data: PromotionAppliedCreateManyInput | PromotionAppliedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromotionApplied update
   */
  export type PromotionAppliedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionApplied
     */
    select?: PromotionAppliedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionApplied
     */
    omit?: PromotionAppliedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionAppliedInclude<ExtArgs> | null
    /**
     * The data needed to update a PromotionApplied.
     */
    data: XOR<PromotionAppliedUpdateInput, PromotionAppliedUncheckedUpdateInput>
    /**
     * Choose, which PromotionApplied to update.
     */
    where: PromotionAppliedWhereUniqueInput
  }

  /**
   * PromotionApplied updateMany
   */
  export type PromotionAppliedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromotionApplieds.
     */
    data: XOR<PromotionAppliedUpdateManyMutationInput, PromotionAppliedUncheckedUpdateManyInput>
    /**
     * Filter which PromotionApplieds to update
     */
    where?: PromotionAppliedWhereInput
    /**
     * Limit how many PromotionApplieds to update.
     */
    limit?: number
  }

  /**
   * PromotionApplied upsert
   */
  export type PromotionAppliedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionApplied
     */
    select?: PromotionAppliedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionApplied
     */
    omit?: PromotionAppliedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionAppliedInclude<ExtArgs> | null
    /**
     * The filter to search for the PromotionApplied to update in case it exists.
     */
    where: PromotionAppliedWhereUniqueInput
    /**
     * In case the PromotionApplied found by the `where` argument doesn't exist, create a new PromotionApplied with this data.
     */
    create: XOR<PromotionAppliedCreateInput, PromotionAppliedUncheckedCreateInput>
    /**
     * In case the PromotionApplied was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionAppliedUpdateInput, PromotionAppliedUncheckedUpdateInput>
  }

  /**
   * PromotionApplied delete
   */
  export type PromotionAppliedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionApplied
     */
    select?: PromotionAppliedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionApplied
     */
    omit?: PromotionAppliedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionAppliedInclude<ExtArgs> | null
    /**
     * Filter which PromotionApplied to delete.
     */
    where: PromotionAppliedWhereUniqueInput
  }

  /**
   * PromotionApplied deleteMany
   */
  export type PromotionAppliedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionApplieds to delete
     */
    where?: PromotionAppliedWhereInput
    /**
     * Limit how many PromotionApplieds to delete.
     */
    limit?: number
  }

  /**
   * PromotionApplied.booking
   */
  export type PromotionApplied$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * PromotionApplied without action
   */
  export type PromotionAppliedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionApplied
     */
    select?: PromotionAppliedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionApplied
     */
    omit?: PromotionAppliedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionAppliedInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ActivityLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    logDate: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    logDate: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    logDate: number
    _all: number
  }


  export type ActivityLogAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ActivityLogSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ActivityLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    logDate?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    logDate?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    logDate?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _avg?: ActivityLogAvgAggregateInputType
    _sum?: ActivityLogSumAggregateInputType
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: number
    userId: number | null
    action: string | null
    logDate: Date | null
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    logDate?: boolean
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>



  export type ActivityLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    logDate?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "logDate", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      user: Prisma.$CustomerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      action: string | null
      logDate: Date | null
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ActivityLog$userArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$userArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'Int'>
    readonly userId: FieldRef<"ActivityLog", 'Int'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly logDate: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data?: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog.user
   */
  export type ActivityLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model HotelEvent
   */

  export type AggregateHotelEvent = {
    _count: HotelEventCountAggregateOutputType | null
    _avg: HotelEventAvgAggregateOutputType | null
    _sum: HotelEventSumAggregateOutputType | null
    _min: HotelEventMinAggregateOutputType | null
    _max: HotelEventMaxAggregateOutputType | null
  }

  export type HotelEventAvgAggregateOutputType = {
    id: number | null
    hotelId: number | null
  }

  export type HotelEventSumAggregateOutputType = {
    id: number | null
    hotelId: number | null
  }

  export type HotelEventMinAggregateOutputType = {
    id: number | null
    hotelId: number | null
    eventName: string | null
    eventDate: Date | null
    description: string | null
  }

  export type HotelEventMaxAggregateOutputType = {
    id: number | null
    hotelId: number | null
    eventName: string | null
    eventDate: Date | null
    description: string | null
  }

  export type HotelEventCountAggregateOutputType = {
    id: number
    hotelId: number
    eventName: number
    eventDate: number
    description: number
    _all: number
  }


  export type HotelEventAvgAggregateInputType = {
    id?: true
    hotelId?: true
  }

  export type HotelEventSumAggregateInputType = {
    id?: true
    hotelId?: true
  }

  export type HotelEventMinAggregateInputType = {
    id?: true
    hotelId?: true
    eventName?: true
    eventDate?: true
    description?: true
  }

  export type HotelEventMaxAggregateInputType = {
    id?: true
    hotelId?: true
    eventName?: true
    eventDate?: true
    description?: true
  }

  export type HotelEventCountAggregateInputType = {
    id?: true
    hotelId?: true
    eventName?: true
    eventDate?: true
    description?: true
    _all?: true
  }

  export type HotelEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelEvent to aggregate.
     */
    where?: HotelEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelEvents to fetch.
     */
    orderBy?: HotelEventOrderByWithRelationInput | HotelEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelEvents
    **/
    _count?: true | HotelEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelEventMaxAggregateInputType
  }

  export type GetHotelEventAggregateType<T extends HotelEventAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelEvent[P]>
      : GetScalarType<T[P], AggregateHotelEvent[P]>
  }




  export type HotelEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelEventWhereInput
    orderBy?: HotelEventOrderByWithAggregationInput | HotelEventOrderByWithAggregationInput[]
    by: HotelEventScalarFieldEnum[] | HotelEventScalarFieldEnum
    having?: HotelEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelEventCountAggregateInputType | true
    _avg?: HotelEventAvgAggregateInputType
    _sum?: HotelEventSumAggregateInputType
    _min?: HotelEventMinAggregateInputType
    _max?: HotelEventMaxAggregateInputType
  }

  export type HotelEventGroupByOutputType = {
    id: number
    hotelId: number | null
    eventName: string | null
    eventDate: Date | null
    description: string | null
    _count: HotelEventCountAggregateOutputType | null
    _avg: HotelEventAvgAggregateOutputType | null
    _sum: HotelEventSumAggregateOutputType | null
    _min: HotelEventMinAggregateOutputType | null
    _max: HotelEventMaxAggregateOutputType | null
  }

  type GetHotelEventGroupByPayload<T extends HotelEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelEventGroupByOutputType[P]>
            : GetScalarType<T[P], HotelEventGroupByOutputType[P]>
        }
      >
    >


  export type HotelEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    eventName?: boolean
    eventDate?: boolean
    description?: boolean
    hotel?: boolean | HotelEvent$hotelArgs<ExtArgs>
  }, ExtArgs["result"]["hotelEvent"]>



  export type HotelEventSelectScalar = {
    id?: boolean
    hotelId?: boolean
    eventName?: boolean
    eventDate?: boolean
    description?: boolean
  }

  export type HotelEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hotelId" | "eventName" | "eventDate" | "description", ExtArgs["result"]["hotelEvent"]>
  export type HotelEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelEvent$hotelArgs<ExtArgs>
  }

  export type $HotelEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelEvent"
    objects: {
      hotel: Prisma.$HotelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hotelId: number | null
      eventName: string | null
      eventDate: Date | null
      description: string | null
    }, ExtArgs["result"]["hotelEvent"]>
    composites: {}
  }

  type HotelEventGetPayload<S extends boolean | null | undefined | HotelEventDefaultArgs> = $Result.GetResult<Prisma.$HotelEventPayload, S>

  type HotelEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelEventCountAggregateInputType | true
    }

  export interface HotelEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelEvent'], meta: { name: 'HotelEvent' } }
    /**
     * Find zero or one HotelEvent that matches the filter.
     * @param {HotelEventFindUniqueArgs} args - Arguments to find a HotelEvent
     * @example
     * // Get one HotelEvent
     * const hotelEvent = await prisma.hotelEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelEventFindUniqueArgs>(args: SelectSubset<T, HotelEventFindUniqueArgs<ExtArgs>>): Prisma__HotelEventClient<$Result.GetResult<Prisma.$HotelEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelEventFindUniqueOrThrowArgs} args - Arguments to find a HotelEvent
     * @example
     * // Get one HotelEvent
     * const hotelEvent = await prisma.hotelEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelEventFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelEventClient<$Result.GetResult<Prisma.$HotelEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelEventFindFirstArgs} args - Arguments to find a HotelEvent
     * @example
     * // Get one HotelEvent
     * const hotelEvent = await prisma.hotelEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelEventFindFirstArgs>(args?: SelectSubset<T, HotelEventFindFirstArgs<ExtArgs>>): Prisma__HotelEventClient<$Result.GetResult<Prisma.$HotelEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelEventFindFirstOrThrowArgs} args - Arguments to find a HotelEvent
     * @example
     * // Get one HotelEvent
     * const hotelEvent = await prisma.hotelEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelEventFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelEventClient<$Result.GetResult<Prisma.$HotelEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelEvents
     * const hotelEvents = await prisma.hotelEvent.findMany()
     * 
     * // Get first 10 HotelEvents
     * const hotelEvents = await prisma.hotelEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelEventWithIdOnly = await prisma.hotelEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelEventFindManyArgs>(args?: SelectSubset<T, HotelEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelEvent.
     * @param {HotelEventCreateArgs} args - Arguments to create a HotelEvent.
     * @example
     * // Create one HotelEvent
     * const HotelEvent = await prisma.hotelEvent.create({
     *   data: {
     *     // ... data to create a HotelEvent
     *   }
     * })
     * 
     */
    create<T extends HotelEventCreateArgs>(args: SelectSubset<T, HotelEventCreateArgs<ExtArgs>>): Prisma__HotelEventClient<$Result.GetResult<Prisma.$HotelEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelEvents.
     * @param {HotelEventCreateManyArgs} args - Arguments to create many HotelEvents.
     * @example
     * // Create many HotelEvents
     * const hotelEvent = await prisma.hotelEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelEventCreateManyArgs>(args?: SelectSubset<T, HotelEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HotelEvent.
     * @param {HotelEventDeleteArgs} args - Arguments to delete one HotelEvent.
     * @example
     * // Delete one HotelEvent
     * const HotelEvent = await prisma.hotelEvent.delete({
     *   where: {
     *     // ... filter to delete one HotelEvent
     *   }
     * })
     * 
     */
    delete<T extends HotelEventDeleteArgs>(args: SelectSubset<T, HotelEventDeleteArgs<ExtArgs>>): Prisma__HotelEventClient<$Result.GetResult<Prisma.$HotelEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelEvent.
     * @param {HotelEventUpdateArgs} args - Arguments to update one HotelEvent.
     * @example
     * // Update one HotelEvent
     * const hotelEvent = await prisma.hotelEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelEventUpdateArgs>(args: SelectSubset<T, HotelEventUpdateArgs<ExtArgs>>): Prisma__HotelEventClient<$Result.GetResult<Prisma.$HotelEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelEvents.
     * @param {HotelEventDeleteManyArgs} args - Arguments to filter HotelEvents to delete.
     * @example
     * // Delete a few HotelEvents
     * const { count } = await prisma.hotelEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelEventDeleteManyArgs>(args?: SelectSubset<T, HotelEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelEvents
     * const hotelEvent = await prisma.hotelEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelEventUpdateManyArgs>(args: SelectSubset<T, HotelEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotelEvent.
     * @param {HotelEventUpsertArgs} args - Arguments to update or create a HotelEvent.
     * @example
     * // Update or create a HotelEvent
     * const hotelEvent = await prisma.hotelEvent.upsert({
     *   create: {
     *     // ... data to create a HotelEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelEvent we want to update
     *   }
     * })
     */
    upsert<T extends HotelEventUpsertArgs>(args: SelectSubset<T, HotelEventUpsertArgs<ExtArgs>>): Prisma__HotelEventClient<$Result.GetResult<Prisma.$HotelEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelEventCountArgs} args - Arguments to filter HotelEvents to count.
     * @example
     * // Count the number of HotelEvents
     * const count = await prisma.hotelEvent.count({
     *   where: {
     *     // ... the filter for the HotelEvents we want to count
     *   }
     * })
    **/
    count<T extends HotelEventCountArgs>(
      args?: Subset<T, HotelEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelEventAggregateArgs>(args: Subset<T, HotelEventAggregateArgs>): Prisma.PrismaPromise<GetHotelEventAggregateType<T>>

    /**
     * Group by HotelEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelEventGroupByArgs['orderBy'] }
        : { orderBy?: HotelEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelEvent model
   */
  readonly fields: HotelEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends HotelEvent$hotelArgs<ExtArgs> = {}>(args?: Subset<T, HotelEvent$hotelArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelEvent model
   */
  interface HotelEventFieldRefs {
    readonly id: FieldRef<"HotelEvent", 'Int'>
    readonly hotelId: FieldRef<"HotelEvent", 'Int'>
    readonly eventName: FieldRef<"HotelEvent", 'String'>
    readonly eventDate: FieldRef<"HotelEvent", 'DateTime'>
    readonly description: FieldRef<"HotelEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HotelEvent findUnique
   */
  export type HotelEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelEvent
     */
    select?: HotelEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelEvent
     */
    omit?: HotelEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelEventInclude<ExtArgs> | null
    /**
     * Filter, which HotelEvent to fetch.
     */
    where: HotelEventWhereUniqueInput
  }

  /**
   * HotelEvent findUniqueOrThrow
   */
  export type HotelEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelEvent
     */
    select?: HotelEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelEvent
     */
    omit?: HotelEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelEventInclude<ExtArgs> | null
    /**
     * Filter, which HotelEvent to fetch.
     */
    where: HotelEventWhereUniqueInput
  }

  /**
   * HotelEvent findFirst
   */
  export type HotelEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelEvent
     */
    select?: HotelEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelEvent
     */
    omit?: HotelEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelEventInclude<ExtArgs> | null
    /**
     * Filter, which HotelEvent to fetch.
     */
    where?: HotelEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelEvents to fetch.
     */
    orderBy?: HotelEventOrderByWithRelationInput | HotelEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelEvents.
     */
    cursor?: HotelEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelEvents.
     */
    distinct?: HotelEventScalarFieldEnum | HotelEventScalarFieldEnum[]
  }

  /**
   * HotelEvent findFirstOrThrow
   */
  export type HotelEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelEvent
     */
    select?: HotelEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelEvent
     */
    omit?: HotelEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelEventInclude<ExtArgs> | null
    /**
     * Filter, which HotelEvent to fetch.
     */
    where?: HotelEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelEvents to fetch.
     */
    orderBy?: HotelEventOrderByWithRelationInput | HotelEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelEvents.
     */
    cursor?: HotelEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelEvents.
     */
    distinct?: HotelEventScalarFieldEnum | HotelEventScalarFieldEnum[]
  }

  /**
   * HotelEvent findMany
   */
  export type HotelEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelEvent
     */
    select?: HotelEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelEvent
     */
    omit?: HotelEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelEventInclude<ExtArgs> | null
    /**
     * Filter, which HotelEvents to fetch.
     */
    where?: HotelEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelEvents to fetch.
     */
    orderBy?: HotelEventOrderByWithRelationInput | HotelEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelEvents.
     */
    cursor?: HotelEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelEvents.
     */
    skip?: number
    distinct?: HotelEventScalarFieldEnum | HotelEventScalarFieldEnum[]
  }

  /**
   * HotelEvent create
   */
  export type HotelEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelEvent
     */
    select?: HotelEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelEvent
     */
    omit?: HotelEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelEventInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelEvent.
     */
    data?: XOR<HotelEventCreateInput, HotelEventUncheckedCreateInput>
  }

  /**
   * HotelEvent createMany
   */
  export type HotelEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelEvents.
     */
    data: HotelEventCreateManyInput | HotelEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotelEvent update
   */
  export type HotelEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelEvent
     */
    select?: HotelEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelEvent
     */
    omit?: HotelEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelEventInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelEvent.
     */
    data: XOR<HotelEventUpdateInput, HotelEventUncheckedUpdateInput>
    /**
     * Choose, which HotelEvent to update.
     */
    where: HotelEventWhereUniqueInput
  }

  /**
   * HotelEvent updateMany
   */
  export type HotelEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelEvents.
     */
    data: XOR<HotelEventUpdateManyMutationInput, HotelEventUncheckedUpdateManyInput>
    /**
     * Filter which HotelEvents to update
     */
    where?: HotelEventWhereInput
    /**
     * Limit how many HotelEvents to update.
     */
    limit?: number
  }

  /**
   * HotelEvent upsert
   */
  export type HotelEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelEvent
     */
    select?: HotelEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelEvent
     */
    omit?: HotelEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelEventInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelEvent to update in case it exists.
     */
    where: HotelEventWhereUniqueInput
    /**
     * In case the HotelEvent found by the `where` argument doesn't exist, create a new HotelEvent with this data.
     */
    create: XOR<HotelEventCreateInput, HotelEventUncheckedCreateInput>
    /**
     * In case the HotelEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelEventUpdateInput, HotelEventUncheckedUpdateInput>
  }

  /**
   * HotelEvent delete
   */
  export type HotelEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelEvent
     */
    select?: HotelEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelEvent
     */
    omit?: HotelEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelEventInclude<ExtArgs> | null
    /**
     * Filter which HotelEvent to delete.
     */
    where: HotelEventWhereUniqueInput
  }

  /**
   * HotelEvent deleteMany
   */
  export type HotelEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelEvents to delete
     */
    where?: HotelEventWhereInput
    /**
     * Limit how many HotelEvents to delete.
     */
    limit?: number
  }

  /**
   * HotelEvent.hotel
   */
  export type HotelEvent$hotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
  }

  /**
   * HotelEvent without action
   */
  export type HotelEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelEvent
     */
    select?: HotelEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelEvent
     */
    omit?: HotelEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelEventInclude<ExtArgs> | null
  }


  /**
   * Model SystemNotification
   */

  export type AggregateSystemNotification = {
    _count: SystemNotificationCountAggregateOutputType | null
    _avg: SystemNotificationAvgAggregateOutputType | null
    _sum: SystemNotificationSumAggregateOutputType | null
    _min: SystemNotificationMinAggregateOutputType | null
    _max: SystemNotificationMaxAggregateOutputType | null
  }

  export type SystemNotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SystemNotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SystemNotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    message: string | null
    notificationDate: Date | null
  }

  export type SystemNotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    message: string | null
    notificationDate: Date | null
  }

  export type SystemNotificationCountAggregateOutputType = {
    id: number
    userId: number
    message: number
    notificationDate: number
    _all: number
  }


  export type SystemNotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SystemNotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SystemNotificationMinAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    notificationDate?: true
  }

  export type SystemNotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    notificationDate?: true
  }

  export type SystemNotificationCountAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    notificationDate?: true
    _all?: true
  }

  export type SystemNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemNotification to aggregate.
     */
    where?: SystemNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemNotifications to fetch.
     */
    orderBy?: SystemNotificationOrderByWithRelationInput | SystemNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemNotifications
    **/
    _count?: true | SystemNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemNotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemNotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemNotificationMaxAggregateInputType
  }

  export type GetSystemNotificationAggregateType<T extends SystemNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemNotification[P]>
      : GetScalarType<T[P], AggregateSystemNotification[P]>
  }




  export type SystemNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemNotificationWhereInput
    orderBy?: SystemNotificationOrderByWithAggregationInput | SystemNotificationOrderByWithAggregationInput[]
    by: SystemNotificationScalarFieldEnum[] | SystemNotificationScalarFieldEnum
    having?: SystemNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemNotificationCountAggregateInputType | true
    _avg?: SystemNotificationAvgAggregateInputType
    _sum?: SystemNotificationSumAggregateInputType
    _min?: SystemNotificationMinAggregateInputType
    _max?: SystemNotificationMaxAggregateInputType
  }

  export type SystemNotificationGroupByOutputType = {
    id: number
    userId: number | null
    message: string | null
    notificationDate: Date | null
    _count: SystemNotificationCountAggregateOutputType | null
    _avg: SystemNotificationAvgAggregateOutputType | null
    _sum: SystemNotificationSumAggregateOutputType | null
    _min: SystemNotificationMinAggregateOutputType | null
    _max: SystemNotificationMaxAggregateOutputType | null
  }

  type GetSystemNotificationGroupByPayload<T extends SystemNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], SystemNotificationGroupByOutputType[P]>
        }
      >
    >


  export type SystemNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    message?: boolean
    notificationDate?: boolean
    user?: boolean | SystemNotification$userArgs<ExtArgs>
  }, ExtArgs["result"]["systemNotification"]>



  export type SystemNotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    message?: boolean
    notificationDate?: boolean
  }

  export type SystemNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "message" | "notificationDate", ExtArgs["result"]["systemNotification"]>
  export type SystemNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SystemNotification$userArgs<ExtArgs>
  }

  export type $SystemNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemNotification"
    objects: {
      user: Prisma.$CustomerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      message: string | null
      notificationDate: Date | null
    }, ExtArgs["result"]["systemNotification"]>
    composites: {}
  }

  type SystemNotificationGetPayload<S extends boolean | null | undefined | SystemNotificationDefaultArgs> = $Result.GetResult<Prisma.$SystemNotificationPayload, S>

  type SystemNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemNotificationCountAggregateInputType | true
    }

  export interface SystemNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemNotification'], meta: { name: 'SystemNotification' } }
    /**
     * Find zero or one SystemNotification that matches the filter.
     * @param {SystemNotificationFindUniqueArgs} args - Arguments to find a SystemNotification
     * @example
     * // Get one SystemNotification
     * const systemNotification = await prisma.systemNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemNotificationFindUniqueArgs>(args: SelectSubset<T, SystemNotificationFindUniqueArgs<ExtArgs>>): Prisma__SystemNotificationClient<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemNotificationFindUniqueOrThrowArgs} args - Arguments to find a SystemNotification
     * @example
     * // Get one SystemNotification
     * const systemNotification = await prisma.systemNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemNotificationClient<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemNotificationFindFirstArgs} args - Arguments to find a SystemNotification
     * @example
     * // Get one SystemNotification
     * const systemNotification = await prisma.systemNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemNotificationFindFirstArgs>(args?: SelectSubset<T, SystemNotificationFindFirstArgs<ExtArgs>>): Prisma__SystemNotificationClient<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemNotificationFindFirstOrThrowArgs} args - Arguments to find a SystemNotification
     * @example
     * // Get one SystemNotification
     * const systemNotification = await prisma.systemNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemNotificationClient<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemNotifications
     * const systemNotifications = await prisma.systemNotification.findMany()
     * 
     * // Get first 10 SystemNotifications
     * const systemNotifications = await prisma.systemNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemNotificationWithIdOnly = await prisma.systemNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemNotificationFindManyArgs>(args?: SelectSubset<T, SystemNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemNotification.
     * @param {SystemNotificationCreateArgs} args - Arguments to create a SystemNotification.
     * @example
     * // Create one SystemNotification
     * const SystemNotification = await prisma.systemNotification.create({
     *   data: {
     *     // ... data to create a SystemNotification
     *   }
     * })
     * 
     */
    create<T extends SystemNotificationCreateArgs>(args: SelectSubset<T, SystemNotificationCreateArgs<ExtArgs>>): Prisma__SystemNotificationClient<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemNotifications.
     * @param {SystemNotificationCreateManyArgs} args - Arguments to create many SystemNotifications.
     * @example
     * // Create many SystemNotifications
     * const systemNotification = await prisma.systemNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemNotificationCreateManyArgs>(args?: SelectSubset<T, SystemNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemNotification.
     * @param {SystemNotificationDeleteArgs} args - Arguments to delete one SystemNotification.
     * @example
     * // Delete one SystemNotification
     * const SystemNotification = await prisma.systemNotification.delete({
     *   where: {
     *     // ... filter to delete one SystemNotification
     *   }
     * })
     * 
     */
    delete<T extends SystemNotificationDeleteArgs>(args: SelectSubset<T, SystemNotificationDeleteArgs<ExtArgs>>): Prisma__SystemNotificationClient<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemNotification.
     * @param {SystemNotificationUpdateArgs} args - Arguments to update one SystemNotification.
     * @example
     * // Update one SystemNotification
     * const systemNotification = await prisma.systemNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemNotificationUpdateArgs>(args: SelectSubset<T, SystemNotificationUpdateArgs<ExtArgs>>): Prisma__SystemNotificationClient<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemNotifications.
     * @param {SystemNotificationDeleteManyArgs} args - Arguments to filter SystemNotifications to delete.
     * @example
     * // Delete a few SystemNotifications
     * const { count } = await prisma.systemNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemNotificationDeleteManyArgs>(args?: SelectSubset<T, SystemNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemNotifications
     * const systemNotification = await prisma.systemNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemNotificationUpdateManyArgs>(args: SelectSubset<T, SystemNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemNotification.
     * @param {SystemNotificationUpsertArgs} args - Arguments to update or create a SystemNotification.
     * @example
     * // Update or create a SystemNotification
     * const systemNotification = await prisma.systemNotification.upsert({
     *   create: {
     *     // ... data to create a SystemNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemNotification we want to update
     *   }
     * })
     */
    upsert<T extends SystemNotificationUpsertArgs>(args: SelectSubset<T, SystemNotificationUpsertArgs<ExtArgs>>): Prisma__SystemNotificationClient<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemNotificationCountArgs} args - Arguments to filter SystemNotifications to count.
     * @example
     * // Count the number of SystemNotifications
     * const count = await prisma.systemNotification.count({
     *   where: {
     *     // ... the filter for the SystemNotifications we want to count
     *   }
     * })
    **/
    count<T extends SystemNotificationCountArgs>(
      args?: Subset<T, SystemNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemNotificationAggregateArgs>(args: Subset<T, SystemNotificationAggregateArgs>): Prisma.PrismaPromise<GetSystemNotificationAggregateType<T>>

    /**
     * Group by SystemNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemNotificationGroupByArgs['orderBy'] }
        : { orderBy?: SystemNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemNotification model
   */
  readonly fields: SystemNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends SystemNotification$userArgs<ExtArgs> = {}>(args?: Subset<T, SystemNotification$userArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemNotification model
   */
  interface SystemNotificationFieldRefs {
    readonly id: FieldRef<"SystemNotification", 'Int'>
    readonly userId: FieldRef<"SystemNotification", 'Int'>
    readonly message: FieldRef<"SystemNotification", 'String'>
    readonly notificationDate: FieldRef<"SystemNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemNotification findUnique
   */
  export type SystemNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    /**
     * Filter, which SystemNotification to fetch.
     */
    where: SystemNotificationWhereUniqueInput
  }

  /**
   * SystemNotification findUniqueOrThrow
   */
  export type SystemNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    /**
     * Filter, which SystemNotification to fetch.
     */
    where: SystemNotificationWhereUniqueInput
  }

  /**
   * SystemNotification findFirst
   */
  export type SystemNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    /**
     * Filter, which SystemNotification to fetch.
     */
    where?: SystemNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemNotifications to fetch.
     */
    orderBy?: SystemNotificationOrderByWithRelationInput | SystemNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemNotifications.
     */
    cursor?: SystemNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemNotifications.
     */
    distinct?: SystemNotificationScalarFieldEnum | SystemNotificationScalarFieldEnum[]
  }

  /**
   * SystemNotification findFirstOrThrow
   */
  export type SystemNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    /**
     * Filter, which SystemNotification to fetch.
     */
    where?: SystemNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemNotifications to fetch.
     */
    orderBy?: SystemNotificationOrderByWithRelationInput | SystemNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemNotifications.
     */
    cursor?: SystemNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemNotifications.
     */
    distinct?: SystemNotificationScalarFieldEnum | SystemNotificationScalarFieldEnum[]
  }

  /**
   * SystemNotification findMany
   */
  export type SystemNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    /**
     * Filter, which SystemNotifications to fetch.
     */
    where?: SystemNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemNotifications to fetch.
     */
    orderBy?: SystemNotificationOrderByWithRelationInput | SystemNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemNotifications.
     */
    cursor?: SystemNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemNotifications.
     */
    skip?: number
    distinct?: SystemNotificationScalarFieldEnum | SystemNotificationScalarFieldEnum[]
  }

  /**
   * SystemNotification create
   */
  export type SystemNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemNotification.
     */
    data?: XOR<SystemNotificationCreateInput, SystemNotificationUncheckedCreateInput>
  }

  /**
   * SystemNotification createMany
   */
  export type SystemNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemNotifications.
     */
    data: SystemNotificationCreateManyInput | SystemNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemNotification update
   */
  export type SystemNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemNotification.
     */
    data: XOR<SystemNotificationUpdateInput, SystemNotificationUncheckedUpdateInput>
    /**
     * Choose, which SystemNotification to update.
     */
    where: SystemNotificationWhereUniqueInput
  }

  /**
   * SystemNotification updateMany
   */
  export type SystemNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemNotifications.
     */
    data: XOR<SystemNotificationUpdateManyMutationInput, SystemNotificationUncheckedUpdateManyInput>
    /**
     * Filter which SystemNotifications to update
     */
    where?: SystemNotificationWhereInput
    /**
     * Limit how many SystemNotifications to update.
     */
    limit?: number
  }

  /**
   * SystemNotification upsert
   */
  export type SystemNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemNotification to update in case it exists.
     */
    where: SystemNotificationWhereUniqueInput
    /**
     * In case the SystemNotification found by the `where` argument doesn't exist, create a new SystemNotification with this data.
     */
    create: XOR<SystemNotificationCreateInput, SystemNotificationUncheckedCreateInput>
    /**
     * In case the SystemNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemNotificationUpdateInput, SystemNotificationUncheckedUpdateInput>
  }

  /**
   * SystemNotification delete
   */
  export type SystemNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    /**
     * Filter which SystemNotification to delete.
     */
    where: SystemNotificationWhereUniqueInput
  }

  /**
   * SystemNotification deleteMany
   */
  export type SystemNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemNotifications to delete
     */
    where?: SystemNotificationWhereInput
    /**
     * Limit how many SystemNotifications to delete.
     */
    limit?: number
  }

  /**
   * SystemNotification.user
   */
  export type SystemNotification$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * SystemNotification without action
   */
  export type SystemNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
  }


  /**
   * Model RoomAmenitiesLink
   */

  export type AggregateRoomAmenitiesLink = {
    _count: RoomAmenitiesLinkCountAggregateOutputType | null
    _avg: RoomAmenitiesLinkAvgAggregateOutputType | null
    _sum: RoomAmenitiesLinkSumAggregateOutputType | null
    _min: RoomAmenitiesLinkMinAggregateOutputType | null
    _max: RoomAmenitiesLinkMaxAggregateOutputType | null
  }

  export type RoomAmenitiesLinkAvgAggregateOutputType = {
    id: number | null
    roomId: number | null
    amenityId: number | null
  }

  export type RoomAmenitiesLinkSumAggregateOutputType = {
    id: number | null
    roomId: number | null
    amenityId: number | null
  }

  export type RoomAmenitiesLinkMinAggregateOutputType = {
    id: number | null
    roomId: number | null
    amenityId: number | null
  }

  export type RoomAmenitiesLinkMaxAggregateOutputType = {
    id: number | null
    roomId: number | null
    amenityId: number | null
  }

  export type RoomAmenitiesLinkCountAggregateOutputType = {
    id: number
    roomId: number
    amenityId: number
    _all: number
  }


  export type RoomAmenitiesLinkAvgAggregateInputType = {
    id?: true
    roomId?: true
    amenityId?: true
  }

  export type RoomAmenitiesLinkSumAggregateInputType = {
    id?: true
    roomId?: true
    amenityId?: true
  }

  export type RoomAmenitiesLinkMinAggregateInputType = {
    id?: true
    roomId?: true
    amenityId?: true
  }

  export type RoomAmenitiesLinkMaxAggregateInputType = {
    id?: true
    roomId?: true
    amenityId?: true
  }

  export type RoomAmenitiesLinkCountAggregateInputType = {
    id?: true
    roomId?: true
    amenityId?: true
    _all?: true
  }

  export type RoomAmenitiesLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomAmenitiesLink to aggregate.
     */
    where?: RoomAmenitiesLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAmenitiesLinks to fetch.
     */
    orderBy?: RoomAmenitiesLinkOrderByWithRelationInput | RoomAmenitiesLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomAmenitiesLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAmenitiesLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAmenitiesLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomAmenitiesLinks
    **/
    _count?: true | RoomAmenitiesLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAmenitiesLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomAmenitiesLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomAmenitiesLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomAmenitiesLinkMaxAggregateInputType
  }

  export type GetRoomAmenitiesLinkAggregateType<T extends RoomAmenitiesLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomAmenitiesLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomAmenitiesLink[P]>
      : GetScalarType<T[P], AggregateRoomAmenitiesLink[P]>
  }




  export type RoomAmenitiesLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomAmenitiesLinkWhereInput
    orderBy?: RoomAmenitiesLinkOrderByWithAggregationInput | RoomAmenitiesLinkOrderByWithAggregationInput[]
    by: RoomAmenitiesLinkScalarFieldEnum[] | RoomAmenitiesLinkScalarFieldEnum
    having?: RoomAmenitiesLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomAmenitiesLinkCountAggregateInputType | true
    _avg?: RoomAmenitiesLinkAvgAggregateInputType
    _sum?: RoomAmenitiesLinkSumAggregateInputType
    _min?: RoomAmenitiesLinkMinAggregateInputType
    _max?: RoomAmenitiesLinkMaxAggregateInputType
  }

  export type RoomAmenitiesLinkGroupByOutputType = {
    id: number
    roomId: number
    amenityId: number | null
    _count: RoomAmenitiesLinkCountAggregateOutputType | null
    _avg: RoomAmenitiesLinkAvgAggregateOutputType | null
    _sum: RoomAmenitiesLinkSumAggregateOutputType | null
    _min: RoomAmenitiesLinkMinAggregateOutputType | null
    _max: RoomAmenitiesLinkMaxAggregateOutputType | null
  }

  type GetRoomAmenitiesLinkGroupByPayload<T extends RoomAmenitiesLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomAmenitiesLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomAmenitiesLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomAmenitiesLinkGroupByOutputType[P]>
            : GetScalarType<T[P], RoomAmenitiesLinkGroupByOutputType[P]>
        }
      >
    >


  export type RoomAmenitiesLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    amenityId?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    amenity?: boolean | RoomAmenitiesLink$amenityArgs<ExtArgs>
  }, ExtArgs["result"]["roomAmenitiesLink"]>



  export type RoomAmenitiesLinkSelectScalar = {
    id?: boolean
    roomId?: boolean
    amenityId?: boolean
  }

  export type RoomAmenitiesLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "amenityId", ExtArgs["result"]["roomAmenitiesLink"]>
  export type RoomAmenitiesLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    amenity?: boolean | RoomAmenitiesLink$amenityArgs<ExtArgs>
  }

  export type $RoomAmenitiesLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomAmenitiesLink"
    objects: {
      room: Prisma.$RoomPayload<ExtArgs>
      amenity: Prisma.$RoomAmenityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roomId: number
      amenityId: number | null
    }, ExtArgs["result"]["roomAmenitiesLink"]>
    composites: {}
  }

  type RoomAmenitiesLinkGetPayload<S extends boolean | null | undefined | RoomAmenitiesLinkDefaultArgs> = $Result.GetResult<Prisma.$RoomAmenitiesLinkPayload, S>

  type RoomAmenitiesLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomAmenitiesLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomAmenitiesLinkCountAggregateInputType | true
    }

  export interface RoomAmenitiesLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomAmenitiesLink'], meta: { name: 'RoomAmenitiesLink' } }
    /**
     * Find zero or one RoomAmenitiesLink that matches the filter.
     * @param {RoomAmenitiesLinkFindUniqueArgs} args - Arguments to find a RoomAmenitiesLink
     * @example
     * // Get one RoomAmenitiesLink
     * const roomAmenitiesLink = await prisma.roomAmenitiesLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomAmenitiesLinkFindUniqueArgs>(args: SelectSubset<T, RoomAmenitiesLinkFindUniqueArgs<ExtArgs>>): Prisma__RoomAmenitiesLinkClient<$Result.GetResult<Prisma.$RoomAmenitiesLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoomAmenitiesLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomAmenitiesLinkFindUniqueOrThrowArgs} args - Arguments to find a RoomAmenitiesLink
     * @example
     * // Get one RoomAmenitiesLink
     * const roomAmenitiesLink = await prisma.roomAmenitiesLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomAmenitiesLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomAmenitiesLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomAmenitiesLinkClient<$Result.GetResult<Prisma.$RoomAmenitiesLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomAmenitiesLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenitiesLinkFindFirstArgs} args - Arguments to find a RoomAmenitiesLink
     * @example
     * // Get one RoomAmenitiesLink
     * const roomAmenitiesLink = await prisma.roomAmenitiesLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomAmenitiesLinkFindFirstArgs>(args?: SelectSubset<T, RoomAmenitiesLinkFindFirstArgs<ExtArgs>>): Prisma__RoomAmenitiesLinkClient<$Result.GetResult<Prisma.$RoomAmenitiesLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomAmenitiesLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenitiesLinkFindFirstOrThrowArgs} args - Arguments to find a RoomAmenitiesLink
     * @example
     * // Get one RoomAmenitiesLink
     * const roomAmenitiesLink = await prisma.roomAmenitiesLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomAmenitiesLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomAmenitiesLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomAmenitiesLinkClient<$Result.GetResult<Prisma.$RoomAmenitiesLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoomAmenitiesLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenitiesLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomAmenitiesLinks
     * const roomAmenitiesLinks = await prisma.roomAmenitiesLink.findMany()
     * 
     * // Get first 10 RoomAmenitiesLinks
     * const roomAmenitiesLinks = await prisma.roomAmenitiesLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomAmenitiesLinkWithIdOnly = await prisma.roomAmenitiesLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomAmenitiesLinkFindManyArgs>(args?: SelectSubset<T, RoomAmenitiesLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAmenitiesLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoomAmenitiesLink.
     * @param {RoomAmenitiesLinkCreateArgs} args - Arguments to create a RoomAmenitiesLink.
     * @example
     * // Create one RoomAmenitiesLink
     * const RoomAmenitiesLink = await prisma.roomAmenitiesLink.create({
     *   data: {
     *     // ... data to create a RoomAmenitiesLink
     *   }
     * })
     * 
     */
    create<T extends RoomAmenitiesLinkCreateArgs>(args: SelectSubset<T, RoomAmenitiesLinkCreateArgs<ExtArgs>>): Prisma__RoomAmenitiesLinkClient<$Result.GetResult<Prisma.$RoomAmenitiesLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoomAmenitiesLinks.
     * @param {RoomAmenitiesLinkCreateManyArgs} args - Arguments to create many RoomAmenitiesLinks.
     * @example
     * // Create many RoomAmenitiesLinks
     * const roomAmenitiesLink = await prisma.roomAmenitiesLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomAmenitiesLinkCreateManyArgs>(args?: SelectSubset<T, RoomAmenitiesLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoomAmenitiesLink.
     * @param {RoomAmenitiesLinkDeleteArgs} args - Arguments to delete one RoomAmenitiesLink.
     * @example
     * // Delete one RoomAmenitiesLink
     * const RoomAmenitiesLink = await prisma.roomAmenitiesLink.delete({
     *   where: {
     *     // ... filter to delete one RoomAmenitiesLink
     *   }
     * })
     * 
     */
    delete<T extends RoomAmenitiesLinkDeleteArgs>(args: SelectSubset<T, RoomAmenitiesLinkDeleteArgs<ExtArgs>>): Prisma__RoomAmenitiesLinkClient<$Result.GetResult<Prisma.$RoomAmenitiesLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoomAmenitiesLink.
     * @param {RoomAmenitiesLinkUpdateArgs} args - Arguments to update one RoomAmenitiesLink.
     * @example
     * // Update one RoomAmenitiesLink
     * const roomAmenitiesLink = await prisma.roomAmenitiesLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomAmenitiesLinkUpdateArgs>(args: SelectSubset<T, RoomAmenitiesLinkUpdateArgs<ExtArgs>>): Prisma__RoomAmenitiesLinkClient<$Result.GetResult<Prisma.$RoomAmenitiesLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoomAmenitiesLinks.
     * @param {RoomAmenitiesLinkDeleteManyArgs} args - Arguments to filter RoomAmenitiesLinks to delete.
     * @example
     * // Delete a few RoomAmenitiesLinks
     * const { count } = await prisma.roomAmenitiesLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomAmenitiesLinkDeleteManyArgs>(args?: SelectSubset<T, RoomAmenitiesLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomAmenitiesLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenitiesLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomAmenitiesLinks
     * const roomAmenitiesLink = await prisma.roomAmenitiesLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomAmenitiesLinkUpdateManyArgs>(args: SelectSubset<T, RoomAmenitiesLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomAmenitiesLink.
     * @param {RoomAmenitiesLinkUpsertArgs} args - Arguments to update or create a RoomAmenitiesLink.
     * @example
     * // Update or create a RoomAmenitiesLink
     * const roomAmenitiesLink = await prisma.roomAmenitiesLink.upsert({
     *   create: {
     *     // ... data to create a RoomAmenitiesLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomAmenitiesLink we want to update
     *   }
     * })
     */
    upsert<T extends RoomAmenitiesLinkUpsertArgs>(args: SelectSubset<T, RoomAmenitiesLinkUpsertArgs<ExtArgs>>): Prisma__RoomAmenitiesLinkClient<$Result.GetResult<Prisma.$RoomAmenitiesLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoomAmenitiesLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenitiesLinkCountArgs} args - Arguments to filter RoomAmenitiesLinks to count.
     * @example
     * // Count the number of RoomAmenitiesLinks
     * const count = await prisma.roomAmenitiesLink.count({
     *   where: {
     *     // ... the filter for the RoomAmenitiesLinks we want to count
     *   }
     * })
    **/
    count<T extends RoomAmenitiesLinkCountArgs>(
      args?: Subset<T, RoomAmenitiesLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomAmenitiesLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomAmenitiesLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenitiesLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAmenitiesLinkAggregateArgs>(args: Subset<T, RoomAmenitiesLinkAggregateArgs>): Prisma.PrismaPromise<GetRoomAmenitiesLinkAggregateType<T>>

    /**
     * Group by RoomAmenitiesLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenitiesLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomAmenitiesLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomAmenitiesLinkGroupByArgs['orderBy'] }
        : { orderBy?: RoomAmenitiesLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomAmenitiesLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomAmenitiesLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomAmenitiesLink model
   */
  readonly fields: RoomAmenitiesLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomAmenitiesLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomAmenitiesLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    amenity<T extends RoomAmenitiesLink$amenityArgs<ExtArgs> = {}>(args?: Subset<T, RoomAmenitiesLink$amenityArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomAmenitiesLink model
   */
  interface RoomAmenitiesLinkFieldRefs {
    readonly id: FieldRef<"RoomAmenitiesLink", 'Int'>
    readonly roomId: FieldRef<"RoomAmenitiesLink", 'Int'>
    readonly amenityId: FieldRef<"RoomAmenitiesLink", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RoomAmenitiesLink findUnique
   */
  export type RoomAmenitiesLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenitiesLink
     */
    select?: RoomAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenitiesLink
     */
    omit?: RoomAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenitiesLinkInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenitiesLink to fetch.
     */
    where: RoomAmenitiesLinkWhereUniqueInput
  }

  /**
   * RoomAmenitiesLink findUniqueOrThrow
   */
  export type RoomAmenitiesLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenitiesLink
     */
    select?: RoomAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenitiesLink
     */
    omit?: RoomAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenitiesLinkInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenitiesLink to fetch.
     */
    where: RoomAmenitiesLinkWhereUniqueInput
  }

  /**
   * RoomAmenitiesLink findFirst
   */
  export type RoomAmenitiesLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenitiesLink
     */
    select?: RoomAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenitiesLink
     */
    omit?: RoomAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenitiesLinkInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenitiesLink to fetch.
     */
    where?: RoomAmenitiesLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAmenitiesLinks to fetch.
     */
    orderBy?: RoomAmenitiesLinkOrderByWithRelationInput | RoomAmenitiesLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomAmenitiesLinks.
     */
    cursor?: RoomAmenitiesLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAmenitiesLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAmenitiesLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomAmenitiesLinks.
     */
    distinct?: RoomAmenitiesLinkScalarFieldEnum | RoomAmenitiesLinkScalarFieldEnum[]
  }

  /**
   * RoomAmenitiesLink findFirstOrThrow
   */
  export type RoomAmenitiesLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenitiesLink
     */
    select?: RoomAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenitiesLink
     */
    omit?: RoomAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenitiesLinkInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenitiesLink to fetch.
     */
    where?: RoomAmenitiesLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAmenitiesLinks to fetch.
     */
    orderBy?: RoomAmenitiesLinkOrderByWithRelationInput | RoomAmenitiesLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomAmenitiesLinks.
     */
    cursor?: RoomAmenitiesLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAmenitiesLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAmenitiesLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomAmenitiesLinks.
     */
    distinct?: RoomAmenitiesLinkScalarFieldEnum | RoomAmenitiesLinkScalarFieldEnum[]
  }

  /**
   * RoomAmenitiesLink findMany
   */
  export type RoomAmenitiesLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenitiesLink
     */
    select?: RoomAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenitiesLink
     */
    omit?: RoomAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenitiesLinkInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenitiesLinks to fetch.
     */
    where?: RoomAmenitiesLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAmenitiesLinks to fetch.
     */
    orderBy?: RoomAmenitiesLinkOrderByWithRelationInput | RoomAmenitiesLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomAmenitiesLinks.
     */
    cursor?: RoomAmenitiesLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAmenitiesLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAmenitiesLinks.
     */
    skip?: number
    distinct?: RoomAmenitiesLinkScalarFieldEnum | RoomAmenitiesLinkScalarFieldEnum[]
  }

  /**
   * RoomAmenitiesLink create
   */
  export type RoomAmenitiesLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenitiesLink
     */
    select?: RoomAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenitiesLink
     */
    omit?: RoomAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenitiesLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomAmenitiesLink.
     */
    data: XOR<RoomAmenitiesLinkCreateInput, RoomAmenitiesLinkUncheckedCreateInput>
  }

  /**
   * RoomAmenitiesLink createMany
   */
  export type RoomAmenitiesLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomAmenitiesLinks.
     */
    data: RoomAmenitiesLinkCreateManyInput | RoomAmenitiesLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoomAmenitiesLink update
   */
  export type RoomAmenitiesLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenitiesLink
     */
    select?: RoomAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenitiesLink
     */
    omit?: RoomAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenitiesLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomAmenitiesLink.
     */
    data: XOR<RoomAmenitiesLinkUpdateInput, RoomAmenitiesLinkUncheckedUpdateInput>
    /**
     * Choose, which RoomAmenitiesLink to update.
     */
    where: RoomAmenitiesLinkWhereUniqueInput
  }

  /**
   * RoomAmenitiesLink updateMany
   */
  export type RoomAmenitiesLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomAmenitiesLinks.
     */
    data: XOR<RoomAmenitiesLinkUpdateManyMutationInput, RoomAmenitiesLinkUncheckedUpdateManyInput>
    /**
     * Filter which RoomAmenitiesLinks to update
     */
    where?: RoomAmenitiesLinkWhereInput
    /**
     * Limit how many RoomAmenitiesLinks to update.
     */
    limit?: number
  }

  /**
   * RoomAmenitiesLink upsert
   */
  export type RoomAmenitiesLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenitiesLink
     */
    select?: RoomAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenitiesLink
     */
    omit?: RoomAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenitiesLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomAmenitiesLink to update in case it exists.
     */
    where: RoomAmenitiesLinkWhereUniqueInput
    /**
     * In case the RoomAmenitiesLink found by the `where` argument doesn't exist, create a new RoomAmenitiesLink with this data.
     */
    create: XOR<RoomAmenitiesLinkCreateInput, RoomAmenitiesLinkUncheckedCreateInput>
    /**
     * In case the RoomAmenitiesLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomAmenitiesLinkUpdateInput, RoomAmenitiesLinkUncheckedUpdateInput>
  }

  /**
   * RoomAmenitiesLink delete
   */
  export type RoomAmenitiesLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenitiesLink
     */
    select?: RoomAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenitiesLink
     */
    omit?: RoomAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenitiesLinkInclude<ExtArgs> | null
    /**
     * Filter which RoomAmenitiesLink to delete.
     */
    where: RoomAmenitiesLinkWhereUniqueInput
  }

  /**
   * RoomAmenitiesLink deleteMany
   */
  export type RoomAmenitiesLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomAmenitiesLinks to delete
     */
    where?: RoomAmenitiesLinkWhereInput
    /**
     * Limit how many RoomAmenitiesLinks to delete.
     */
    limit?: number
  }

  /**
   * RoomAmenitiesLink.amenity
   */
  export type RoomAmenitiesLink$amenityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    where?: RoomAmenityWhereInput
  }

  /**
   * RoomAmenitiesLink without action
   */
  export type RoomAmenitiesLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenitiesLink
     */
    select?: RoomAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenitiesLink
     */
    omit?: RoomAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenitiesLinkInclude<ExtArgs> | null
  }


  /**
   * Model HotelAmenitiesLink
   */

  export type AggregateHotelAmenitiesLink = {
    _count: HotelAmenitiesLinkCountAggregateOutputType | null
    _avg: HotelAmenitiesLinkAvgAggregateOutputType | null
    _sum: HotelAmenitiesLinkSumAggregateOutputType | null
    _min: HotelAmenitiesLinkMinAggregateOutputType | null
    _max: HotelAmenitiesLinkMaxAggregateOutputType | null
  }

  export type HotelAmenitiesLinkAvgAggregateOutputType = {
    id: number | null
    hotelId: number | null
    amenityId: number | null
  }

  export type HotelAmenitiesLinkSumAggregateOutputType = {
    id: number | null
    hotelId: number | null
    amenityId: number | null
  }

  export type HotelAmenitiesLinkMinAggregateOutputType = {
    id: number | null
    hotelId: number | null
    amenityId: number | null
  }

  export type HotelAmenitiesLinkMaxAggregateOutputType = {
    id: number | null
    hotelId: number | null
    amenityId: number | null
  }

  export type HotelAmenitiesLinkCountAggregateOutputType = {
    id: number
    hotelId: number
    amenityId: number
    _all: number
  }


  export type HotelAmenitiesLinkAvgAggregateInputType = {
    id?: true
    hotelId?: true
    amenityId?: true
  }

  export type HotelAmenitiesLinkSumAggregateInputType = {
    id?: true
    hotelId?: true
    amenityId?: true
  }

  export type HotelAmenitiesLinkMinAggregateInputType = {
    id?: true
    hotelId?: true
    amenityId?: true
  }

  export type HotelAmenitiesLinkMaxAggregateInputType = {
    id?: true
    hotelId?: true
    amenityId?: true
  }

  export type HotelAmenitiesLinkCountAggregateInputType = {
    id?: true
    hotelId?: true
    amenityId?: true
    _all?: true
  }

  export type HotelAmenitiesLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelAmenitiesLink to aggregate.
     */
    where?: HotelAmenitiesLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelAmenitiesLinks to fetch.
     */
    orderBy?: HotelAmenitiesLinkOrderByWithRelationInput | HotelAmenitiesLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelAmenitiesLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelAmenitiesLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelAmenitiesLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelAmenitiesLinks
    **/
    _count?: true | HotelAmenitiesLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelAmenitiesLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelAmenitiesLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelAmenitiesLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelAmenitiesLinkMaxAggregateInputType
  }

  export type GetHotelAmenitiesLinkAggregateType<T extends HotelAmenitiesLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelAmenitiesLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelAmenitiesLink[P]>
      : GetScalarType<T[P], AggregateHotelAmenitiesLink[P]>
  }




  export type HotelAmenitiesLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelAmenitiesLinkWhereInput
    orderBy?: HotelAmenitiesLinkOrderByWithAggregationInput | HotelAmenitiesLinkOrderByWithAggregationInput[]
    by: HotelAmenitiesLinkScalarFieldEnum[] | HotelAmenitiesLinkScalarFieldEnum
    having?: HotelAmenitiesLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelAmenitiesLinkCountAggregateInputType | true
    _avg?: HotelAmenitiesLinkAvgAggregateInputType
    _sum?: HotelAmenitiesLinkSumAggregateInputType
    _min?: HotelAmenitiesLinkMinAggregateInputType
    _max?: HotelAmenitiesLinkMaxAggregateInputType
  }

  export type HotelAmenitiesLinkGroupByOutputType = {
    id: number
    hotelId: number
    amenityId: number | null
    _count: HotelAmenitiesLinkCountAggregateOutputType | null
    _avg: HotelAmenitiesLinkAvgAggregateOutputType | null
    _sum: HotelAmenitiesLinkSumAggregateOutputType | null
    _min: HotelAmenitiesLinkMinAggregateOutputType | null
    _max: HotelAmenitiesLinkMaxAggregateOutputType | null
  }

  type GetHotelAmenitiesLinkGroupByPayload<T extends HotelAmenitiesLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelAmenitiesLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelAmenitiesLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelAmenitiesLinkGroupByOutputType[P]>
            : GetScalarType<T[P], HotelAmenitiesLinkGroupByOutputType[P]>
        }
      >
    >


  export type HotelAmenitiesLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    amenityId?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    amenity?: boolean | HotelAmenitiesLink$amenityArgs<ExtArgs>
  }, ExtArgs["result"]["hotelAmenitiesLink"]>



  export type HotelAmenitiesLinkSelectScalar = {
    id?: boolean
    hotelId?: boolean
    amenityId?: boolean
  }

  export type HotelAmenitiesLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hotelId" | "amenityId", ExtArgs["result"]["hotelAmenitiesLink"]>
  export type HotelAmenitiesLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    amenity?: boolean | HotelAmenitiesLink$amenityArgs<ExtArgs>
  }

  export type $HotelAmenitiesLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelAmenitiesLink"
    objects: {
      hotel: Prisma.$HotelPayload<ExtArgs>
      amenity: Prisma.$HotelAmenityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hotelId: number
      amenityId: number | null
    }, ExtArgs["result"]["hotelAmenitiesLink"]>
    composites: {}
  }

  type HotelAmenitiesLinkGetPayload<S extends boolean | null | undefined | HotelAmenitiesLinkDefaultArgs> = $Result.GetResult<Prisma.$HotelAmenitiesLinkPayload, S>

  type HotelAmenitiesLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelAmenitiesLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelAmenitiesLinkCountAggregateInputType | true
    }

  export interface HotelAmenitiesLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelAmenitiesLink'], meta: { name: 'HotelAmenitiesLink' } }
    /**
     * Find zero or one HotelAmenitiesLink that matches the filter.
     * @param {HotelAmenitiesLinkFindUniqueArgs} args - Arguments to find a HotelAmenitiesLink
     * @example
     * // Get one HotelAmenitiesLink
     * const hotelAmenitiesLink = await prisma.hotelAmenitiesLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelAmenitiesLinkFindUniqueArgs>(args: SelectSubset<T, HotelAmenitiesLinkFindUniqueArgs<ExtArgs>>): Prisma__HotelAmenitiesLinkClient<$Result.GetResult<Prisma.$HotelAmenitiesLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelAmenitiesLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelAmenitiesLinkFindUniqueOrThrowArgs} args - Arguments to find a HotelAmenitiesLink
     * @example
     * // Get one HotelAmenitiesLink
     * const hotelAmenitiesLink = await prisma.hotelAmenitiesLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelAmenitiesLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelAmenitiesLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelAmenitiesLinkClient<$Result.GetResult<Prisma.$HotelAmenitiesLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelAmenitiesLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenitiesLinkFindFirstArgs} args - Arguments to find a HotelAmenitiesLink
     * @example
     * // Get one HotelAmenitiesLink
     * const hotelAmenitiesLink = await prisma.hotelAmenitiesLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelAmenitiesLinkFindFirstArgs>(args?: SelectSubset<T, HotelAmenitiesLinkFindFirstArgs<ExtArgs>>): Prisma__HotelAmenitiesLinkClient<$Result.GetResult<Prisma.$HotelAmenitiesLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelAmenitiesLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenitiesLinkFindFirstOrThrowArgs} args - Arguments to find a HotelAmenitiesLink
     * @example
     * // Get one HotelAmenitiesLink
     * const hotelAmenitiesLink = await prisma.hotelAmenitiesLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelAmenitiesLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelAmenitiesLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelAmenitiesLinkClient<$Result.GetResult<Prisma.$HotelAmenitiesLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelAmenitiesLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenitiesLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelAmenitiesLinks
     * const hotelAmenitiesLinks = await prisma.hotelAmenitiesLink.findMany()
     * 
     * // Get first 10 HotelAmenitiesLinks
     * const hotelAmenitiesLinks = await prisma.hotelAmenitiesLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelAmenitiesLinkWithIdOnly = await prisma.hotelAmenitiesLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelAmenitiesLinkFindManyArgs>(args?: SelectSubset<T, HotelAmenitiesLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelAmenitiesLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelAmenitiesLink.
     * @param {HotelAmenitiesLinkCreateArgs} args - Arguments to create a HotelAmenitiesLink.
     * @example
     * // Create one HotelAmenitiesLink
     * const HotelAmenitiesLink = await prisma.hotelAmenitiesLink.create({
     *   data: {
     *     // ... data to create a HotelAmenitiesLink
     *   }
     * })
     * 
     */
    create<T extends HotelAmenitiesLinkCreateArgs>(args: SelectSubset<T, HotelAmenitiesLinkCreateArgs<ExtArgs>>): Prisma__HotelAmenitiesLinkClient<$Result.GetResult<Prisma.$HotelAmenitiesLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelAmenitiesLinks.
     * @param {HotelAmenitiesLinkCreateManyArgs} args - Arguments to create many HotelAmenitiesLinks.
     * @example
     * // Create many HotelAmenitiesLinks
     * const hotelAmenitiesLink = await prisma.hotelAmenitiesLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelAmenitiesLinkCreateManyArgs>(args?: SelectSubset<T, HotelAmenitiesLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HotelAmenitiesLink.
     * @param {HotelAmenitiesLinkDeleteArgs} args - Arguments to delete one HotelAmenitiesLink.
     * @example
     * // Delete one HotelAmenitiesLink
     * const HotelAmenitiesLink = await prisma.hotelAmenitiesLink.delete({
     *   where: {
     *     // ... filter to delete one HotelAmenitiesLink
     *   }
     * })
     * 
     */
    delete<T extends HotelAmenitiesLinkDeleteArgs>(args: SelectSubset<T, HotelAmenitiesLinkDeleteArgs<ExtArgs>>): Prisma__HotelAmenitiesLinkClient<$Result.GetResult<Prisma.$HotelAmenitiesLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelAmenitiesLink.
     * @param {HotelAmenitiesLinkUpdateArgs} args - Arguments to update one HotelAmenitiesLink.
     * @example
     * // Update one HotelAmenitiesLink
     * const hotelAmenitiesLink = await prisma.hotelAmenitiesLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelAmenitiesLinkUpdateArgs>(args: SelectSubset<T, HotelAmenitiesLinkUpdateArgs<ExtArgs>>): Prisma__HotelAmenitiesLinkClient<$Result.GetResult<Prisma.$HotelAmenitiesLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelAmenitiesLinks.
     * @param {HotelAmenitiesLinkDeleteManyArgs} args - Arguments to filter HotelAmenitiesLinks to delete.
     * @example
     * // Delete a few HotelAmenitiesLinks
     * const { count } = await prisma.hotelAmenitiesLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelAmenitiesLinkDeleteManyArgs>(args?: SelectSubset<T, HotelAmenitiesLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelAmenitiesLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenitiesLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelAmenitiesLinks
     * const hotelAmenitiesLink = await prisma.hotelAmenitiesLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelAmenitiesLinkUpdateManyArgs>(args: SelectSubset<T, HotelAmenitiesLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotelAmenitiesLink.
     * @param {HotelAmenitiesLinkUpsertArgs} args - Arguments to update or create a HotelAmenitiesLink.
     * @example
     * // Update or create a HotelAmenitiesLink
     * const hotelAmenitiesLink = await prisma.hotelAmenitiesLink.upsert({
     *   create: {
     *     // ... data to create a HotelAmenitiesLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelAmenitiesLink we want to update
     *   }
     * })
     */
    upsert<T extends HotelAmenitiesLinkUpsertArgs>(args: SelectSubset<T, HotelAmenitiesLinkUpsertArgs<ExtArgs>>): Prisma__HotelAmenitiesLinkClient<$Result.GetResult<Prisma.$HotelAmenitiesLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelAmenitiesLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenitiesLinkCountArgs} args - Arguments to filter HotelAmenitiesLinks to count.
     * @example
     * // Count the number of HotelAmenitiesLinks
     * const count = await prisma.hotelAmenitiesLink.count({
     *   where: {
     *     // ... the filter for the HotelAmenitiesLinks we want to count
     *   }
     * })
    **/
    count<T extends HotelAmenitiesLinkCountArgs>(
      args?: Subset<T, HotelAmenitiesLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelAmenitiesLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelAmenitiesLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenitiesLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelAmenitiesLinkAggregateArgs>(args: Subset<T, HotelAmenitiesLinkAggregateArgs>): Prisma.PrismaPromise<GetHotelAmenitiesLinkAggregateType<T>>

    /**
     * Group by HotelAmenitiesLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenitiesLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelAmenitiesLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelAmenitiesLinkGroupByArgs['orderBy'] }
        : { orderBy?: HotelAmenitiesLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelAmenitiesLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelAmenitiesLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelAmenitiesLink model
   */
  readonly fields: HotelAmenitiesLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelAmenitiesLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelAmenitiesLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    amenity<T extends HotelAmenitiesLink$amenityArgs<ExtArgs> = {}>(args?: Subset<T, HotelAmenitiesLink$amenityArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelAmenitiesLink model
   */
  interface HotelAmenitiesLinkFieldRefs {
    readonly id: FieldRef<"HotelAmenitiesLink", 'Int'>
    readonly hotelId: FieldRef<"HotelAmenitiesLink", 'Int'>
    readonly amenityId: FieldRef<"HotelAmenitiesLink", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * HotelAmenitiesLink findUnique
   */
  export type HotelAmenitiesLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenitiesLink
     */
    select?: HotelAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenitiesLink
     */
    omit?: HotelAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenitiesLinkInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenitiesLink to fetch.
     */
    where: HotelAmenitiesLinkWhereUniqueInput
  }

  /**
   * HotelAmenitiesLink findUniqueOrThrow
   */
  export type HotelAmenitiesLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenitiesLink
     */
    select?: HotelAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenitiesLink
     */
    omit?: HotelAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenitiesLinkInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenitiesLink to fetch.
     */
    where: HotelAmenitiesLinkWhereUniqueInput
  }

  /**
   * HotelAmenitiesLink findFirst
   */
  export type HotelAmenitiesLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenitiesLink
     */
    select?: HotelAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenitiesLink
     */
    omit?: HotelAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenitiesLinkInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenitiesLink to fetch.
     */
    where?: HotelAmenitiesLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelAmenitiesLinks to fetch.
     */
    orderBy?: HotelAmenitiesLinkOrderByWithRelationInput | HotelAmenitiesLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelAmenitiesLinks.
     */
    cursor?: HotelAmenitiesLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelAmenitiesLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelAmenitiesLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelAmenitiesLinks.
     */
    distinct?: HotelAmenitiesLinkScalarFieldEnum | HotelAmenitiesLinkScalarFieldEnum[]
  }

  /**
   * HotelAmenitiesLink findFirstOrThrow
   */
  export type HotelAmenitiesLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenitiesLink
     */
    select?: HotelAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenitiesLink
     */
    omit?: HotelAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenitiesLinkInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenitiesLink to fetch.
     */
    where?: HotelAmenitiesLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelAmenitiesLinks to fetch.
     */
    orderBy?: HotelAmenitiesLinkOrderByWithRelationInput | HotelAmenitiesLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelAmenitiesLinks.
     */
    cursor?: HotelAmenitiesLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelAmenitiesLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelAmenitiesLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelAmenitiesLinks.
     */
    distinct?: HotelAmenitiesLinkScalarFieldEnum | HotelAmenitiesLinkScalarFieldEnum[]
  }

  /**
   * HotelAmenitiesLink findMany
   */
  export type HotelAmenitiesLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenitiesLink
     */
    select?: HotelAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenitiesLink
     */
    omit?: HotelAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenitiesLinkInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenitiesLinks to fetch.
     */
    where?: HotelAmenitiesLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelAmenitiesLinks to fetch.
     */
    orderBy?: HotelAmenitiesLinkOrderByWithRelationInput | HotelAmenitiesLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelAmenitiesLinks.
     */
    cursor?: HotelAmenitiesLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelAmenitiesLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelAmenitiesLinks.
     */
    skip?: number
    distinct?: HotelAmenitiesLinkScalarFieldEnum | HotelAmenitiesLinkScalarFieldEnum[]
  }

  /**
   * HotelAmenitiesLink create
   */
  export type HotelAmenitiesLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenitiesLink
     */
    select?: HotelAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenitiesLink
     */
    omit?: HotelAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenitiesLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelAmenitiesLink.
     */
    data: XOR<HotelAmenitiesLinkCreateInput, HotelAmenitiesLinkUncheckedCreateInput>
  }

  /**
   * HotelAmenitiesLink createMany
   */
  export type HotelAmenitiesLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelAmenitiesLinks.
     */
    data: HotelAmenitiesLinkCreateManyInput | HotelAmenitiesLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotelAmenitiesLink update
   */
  export type HotelAmenitiesLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenitiesLink
     */
    select?: HotelAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenitiesLink
     */
    omit?: HotelAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenitiesLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelAmenitiesLink.
     */
    data: XOR<HotelAmenitiesLinkUpdateInput, HotelAmenitiesLinkUncheckedUpdateInput>
    /**
     * Choose, which HotelAmenitiesLink to update.
     */
    where: HotelAmenitiesLinkWhereUniqueInput
  }

  /**
   * HotelAmenitiesLink updateMany
   */
  export type HotelAmenitiesLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelAmenitiesLinks.
     */
    data: XOR<HotelAmenitiesLinkUpdateManyMutationInput, HotelAmenitiesLinkUncheckedUpdateManyInput>
    /**
     * Filter which HotelAmenitiesLinks to update
     */
    where?: HotelAmenitiesLinkWhereInput
    /**
     * Limit how many HotelAmenitiesLinks to update.
     */
    limit?: number
  }

  /**
   * HotelAmenitiesLink upsert
   */
  export type HotelAmenitiesLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenitiesLink
     */
    select?: HotelAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenitiesLink
     */
    omit?: HotelAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenitiesLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelAmenitiesLink to update in case it exists.
     */
    where: HotelAmenitiesLinkWhereUniqueInput
    /**
     * In case the HotelAmenitiesLink found by the `where` argument doesn't exist, create a new HotelAmenitiesLink with this data.
     */
    create: XOR<HotelAmenitiesLinkCreateInput, HotelAmenitiesLinkUncheckedCreateInput>
    /**
     * In case the HotelAmenitiesLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelAmenitiesLinkUpdateInput, HotelAmenitiesLinkUncheckedUpdateInput>
  }

  /**
   * HotelAmenitiesLink delete
   */
  export type HotelAmenitiesLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenitiesLink
     */
    select?: HotelAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenitiesLink
     */
    omit?: HotelAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenitiesLinkInclude<ExtArgs> | null
    /**
     * Filter which HotelAmenitiesLink to delete.
     */
    where: HotelAmenitiesLinkWhereUniqueInput
  }

  /**
   * HotelAmenitiesLink deleteMany
   */
  export type HotelAmenitiesLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelAmenitiesLinks to delete
     */
    where?: HotelAmenitiesLinkWhereInput
    /**
     * Limit how many HotelAmenitiesLinks to delete.
     */
    limit?: number
  }

  /**
   * HotelAmenitiesLink.amenity
   */
  export type HotelAmenitiesLink$amenityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    where?: HotelAmenityWhereInput
  }

  /**
   * HotelAmenitiesLink without action
   */
  export type HotelAmenitiesLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenitiesLink
     */
    select?: HotelAmenitiesLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenitiesLink
     */
    omit?: HotelAmenitiesLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenitiesLinkInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    customerId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
    customerId: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
    customerId: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    createdAt: number
    updatedAt: number
    customerId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    customerId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    customerId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string | null
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    customerId: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    customer?: boolean | User$customerArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "role" | "createdAt" | "updatedAt" | "customerId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | User$customerArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string | null
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
      customerId: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends User$customerArgs<ExtArgs> = {}>(args?: Subset<T, User$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly customerId: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.customer
   */
  export type User$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const HotelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    city: 'city',
    rating: 'rating'
  };

  export type HotelScalarFieldEnum = (typeof HotelScalarFieldEnum)[keyof typeof HotelScalarFieldEnum]


  export const RoomTypeScalarFieldEnum: {
    id: 'id',
    typeName: 'typeName',
    description: 'description'
  };

  export type RoomTypeScalarFieldEnum = (typeof RoomTypeScalarFieldEnum)[keyof typeof RoomTypeScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    hotelId: 'hotelId',
    roomTypeId: 'roomTypeId',
    price: 'price',
    availability: 'availability'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const BookingStatusScalarFieldEnum: {
    id: 'id',
    statusName: 'statusName'
  };

  export type BookingStatusScalarFieldEnum = (typeof BookingStatusScalarFieldEnum)[keyof typeof BookingStatusScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    roomId: 'roomId',
    statusId: 'statusId',
    checkIn: 'checkIn',
    checkOut: 'checkOut',
    totalPrice: 'totalPrice'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    serviceName: 'serviceName',
    price: 'price'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const BookingServiceScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    serviceId: 'serviceId',
    quantity: 'quantity'
  };

  export type BookingServiceScalarFieldEnum = (typeof BookingServiceScalarFieldEnum)[keyof typeof BookingServiceScalarFieldEnum]


  export const EmployeeRoleScalarFieldEnum: {
    id: 'id',
    roleName: 'roleName',
    description: 'description'
  };

  export type EmployeeRoleScalarFieldEnum = (typeof EmployeeRoleScalarFieldEnum)[keyof typeof EmployeeRoleScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    departmentName: 'departmentName'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    departmentId: 'departmentId',
    name: 'name',
    position: 'position',
    salary: 'salary'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    amount: 'amount',
    paymentDate: 'paymentDate',
    paymentMethod: 'paymentMethod'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    hotelId: 'hotelId',
    rating: 'rating',
    comments: 'comments',
    reviewDate: 'reviewDate'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const PromotionScalarFieldEnum: {
    id: 'id',
    description: 'description',
    discount: 'discount',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type PromotionScalarFieldEnum = (typeof PromotionScalarFieldEnum)[keyof typeof PromotionScalarFieldEnum]


  export const RoomAmenityScalarFieldEnum: {
    id: 'id',
    amenityName: 'amenityName',
    description: 'description'
  };

  export type RoomAmenityScalarFieldEnum = (typeof RoomAmenityScalarFieldEnum)[keyof typeof RoomAmenityScalarFieldEnum]


  export const HotelAmenityScalarFieldEnum: {
    id: 'id',
    amenityName: 'amenityName',
    description: 'description'
  };

  export type HotelAmenityScalarFieldEnum = (typeof HotelAmenityScalarFieldEnum)[keyof typeof HotelAmenityScalarFieldEnum]


  export const HotelPolicyScalarFieldEnum: {
    id: 'id',
    hotelId: 'hotelId',
    policyDescription: 'policyDescription'
  };

  export type HotelPolicyScalarFieldEnum = (typeof HotelPolicyScalarFieldEnum)[keyof typeof HotelPolicyScalarFieldEnum]


  export const PromotionAppliedScalarFieldEnum: {
    id: 'id',
    promotionId: 'promotionId',
    bookingId: 'bookingId'
  };

  export type PromotionAppliedScalarFieldEnum = (typeof PromotionAppliedScalarFieldEnum)[keyof typeof PromotionAppliedScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    logDate: 'logDate'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const HotelEventScalarFieldEnum: {
    id: 'id',
    hotelId: 'hotelId',
    eventName: 'eventName',
    eventDate: 'eventDate',
    description: 'description'
  };

  export type HotelEventScalarFieldEnum = (typeof HotelEventScalarFieldEnum)[keyof typeof HotelEventScalarFieldEnum]


  export const SystemNotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    message: 'message',
    notificationDate: 'notificationDate'
  };

  export type SystemNotificationScalarFieldEnum = (typeof SystemNotificationScalarFieldEnum)[keyof typeof SystemNotificationScalarFieldEnum]


  export const RoomAmenitiesLinkScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    amenityId: 'amenityId'
  };

  export type RoomAmenitiesLinkScalarFieldEnum = (typeof RoomAmenitiesLinkScalarFieldEnum)[keyof typeof RoomAmenitiesLinkScalarFieldEnum]


  export const HotelAmenitiesLinkScalarFieldEnum: {
    id: 'id',
    hotelId: 'hotelId',
    amenityId: 'amenityId'
  };

  export type HotelAmenitiesLinkScalarFieldEnum = (typeof HotelAmenitiesLinkScalarFieldEnum)[keyof typeof HotelAmenitiesLinkScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    customerId: 'customerId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const CustomerOrderByRelevanceFieldEnum: {
    name: 'name',
    email: 'email',
    phone: 'phone'
  };

  export type CustomerOrderByRelevanceFieldEnum = (typeof CustomerOrderByRelevanceFieldEnum)[keyof typeof CustomerOrderByRelevanceFieldEnum]


  export const HotelOrderByRelevanceFieldEnum: {
    name: 'name',
    address: 'address',
    city: 'city'
  };

  export type HotelOrderByRelevanceFieldEnum = (typeof HotelOrderByRelevanceFieldEnum)[keyof typeof HotelOrderByRelevanceFieldEnum]


  export const RoomTypeOrderByRelevanceFieldEnum: {
    typeName: 'typeName',
    description: 'description'
  };

  export type RoomTypeOrderByRelevanceFieldEnum = (typeof RoomTypeOrderByRelevanceFieldEnum)[keyof typeof RoomTypeOrderByRelevanceFieldEnum]


  export const BookingStatusOrderByRelevanceFieldEnum: {
    statusName: 'statusName'
  };

  export type BookingStatusOrderByRelevanceFieldEnum = (typeof BookingStatusOrderByRelevanceFieldEnum)[keyof typeof BookingStatusOrderByRelevanceFieldEnum]


  export const ServiceOrderByRelevanceFieldEnum: {
    serviceName: 'serviceName'
  };

  export type ServiceOrderByRelevanceFieldEnum = (typeof ServiceOrderByRelevanceFieldEnum)[keyof typeof ServiceOrderByRelevanceFieldEnum]


  export const EmployeeRoleOrderByRelevanceFieldEnum: {
    roleName: 'roleName',
    description: 'description'
  };

  export type EmployeeRoleOrderByRelevanceFieldEnum = (typeof EmployeeRoleOrderByRelevanceFieldEnum)[keyof typeof EmployeeRoleOrderByRelevanceFieldEnum]


  export const DepartmentOrderByRelevanceFieldEnum: {
    departmentName: 'departmentName'
  };

  export type DepartmentOrderByRelevanceFieldEnum = (typeof DepartmentOrderByRelevanceFieldEnum)[keyof typeof DepartmentOrderByRelevanceFieldEnum]


  export const EmployeeOrderByRelevanceFieldEnum: {
    name: 'name',
    position: 'position'
  };

  export type EmployeeOrderByRelevanceFieldEnum = (typeof EmployeeOrderByRelevanceFieldEnum)[keyof typeof EmployeeOrderByRelevanceFieldEnum]


  export const PaymentOrderByRelevanceFieldEnum: {
    paymentMethod: 'paymentMethod'
  };

  export type PaymentOrderByRelevanceFieldEnum = (typeof PaymentOrderByRelevanceFieldEnum)[keyof typeof PaymentOrderByRelevanceFieldEnum]


  export const ReviewOrderByRelevanceFieldEnum: {
    comments: 'comments'
  };

  export type ReviewOrderByRelevanceFieldEnum = (typeof ReviewOrderByRelevanceFieldEnum)[keyof typeof ReviewOrderByRelevanceFieldEnum]


  export const PromotionOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type PromotionOrderByRelevanceFieldEnum = (typeof PromotionOrderByRelevanceFieldEnum)[keyof typeof PromotionOrderByRelevanceFieldEnum]


  export const RoomAmenityOrderByRelevanceFieldEnum: {
    amenityName: 'amenityName',
    description: 'description'
  };

  export type RoomAmenityOrderByRelevanceFieldEnum = (typeof RoomAmenityOrderByRelevanceFieldEnum)[keyof typeof RoomAmenityOrderByRelevanceFieldEnum]


  export const HotelAmenityOrderByRelevanceFieldEnum: {
    amenityName: 'amenityName',
    description: 'description'
  };

  export type HotelAmenityOrderByRelevanceFieldEnum = (typeof HotelAmenityOrderByRelevanceFieldEnum)[keyof typeof HotelAmenityOrderByRelevanceFieldEnum]


  export const HotelPolicyOrderByRelevanceFieldEnum: {
    policyDescription: 'policyDescription'
  };

  export type HotelPolicyOrderByRelevanceFieldEnum = (typeof HotelPolicyOrderByRelevanceFieldEnum)[keyof typeof HotelPolicyOrderByRelevanceFieldEnum]


  export const ActivityLogOrderByRelevanceFieldEnum: {
    action: 'action'
  };

  export type ActivityLogOrderByRelevanceFieldEnum = (typeof ActivityLogOrderByRelevanceFieldEnum)[keyof typeof ActivityLogOrderByRelevanceFieldEnum]


  export const HotelEventOrderByRelevanceFieldEnum: {
    eventName: 'eventName',
    description: 'description'
  };

  export type HotelEventOrderByRelevanceFieldEnum = (typeof HotelEventOrderByRelevanceFieldEnum)[keyof typeof HotelEventOrderByRelevanceFieldEnum]


  export const SystemNotificationOrderByRelevanceFieldEnum: {
    message: 'message'
  };

  export type SystemNotificationOrderByRelevanceFieldEnum = (typeof SystemNotificationOrderByRelevanceFieldEnum)[keyof typeof SystemNotificationOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    email: 'email',
    password: 'password',
    name: 'name'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    
  /**
   * Deep Input Types
   */


  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: IntFilter<"Customer"> | number
    name?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    notifications?: SystemNotificationListRelationFilter
    User?: UserListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    bookings?: BookingOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    notifications?: SystemNotificationOrderByRelationAggregateInput
    User?: UserOrderByRelationAggregateInput
    _relevance?: CustomerOrderByRelevanceInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    notifications?: SystemNotificationListRelationFilter
    User?: UserListRelationFilter
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customer"> | number
    name?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
  }

  export type HotelWhereInput = {
    AND?: HotelWhereInput | HotelWhereInput[]
    OR?: HotelWhereInput[]
    NOT?: HotelWhereInput | HotelWhereInput[]
    id?: IntFilter<"Hotel"> | number
    name?: StringNullableFilter<"Hotel"> | string | null
    address?: StringNullableFilter<"Hotel"> | string | null
    city?: StringNullableFilter<"Hotel"> | string | null
    rating?: FloatNullableFilter<"Hotel"> | number | null
    rooms?: RoomListRelationFilter
    reviews?: ReviewListRelationFilter
    policies?: HotelPolicyListRelationFilter
    events?: HotelEventListRelationFilter
    amenities?: HotelAmenitiesLinkListRelationFilter
  }

  export type HotelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    rooms?: RoomOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    policies?: HotelPolicyOrderByRelationAggregateInput
    events?: HotelEventOrderByRelationAggregateInput
    amenities?: HotelAmenitiesLinkOrderByRelationAggregateInput
    _relevance?: HotelOrderByRelevanceInput
  }

  export type HotelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HotelWhereInput | HotelWhereInput[]
    OR?: HotelWhereInput[]
    NOT?: HotelWhereInput | HotelWhereInput[]
    name?: StringNullableFilter<"Hotel"> | string | null
    address?: StringNullableFilter<"Hotel"> | string | null
    city?: StringNullableFilter<"Hotel"> | string | null
    rating?: FloatNullableFilter<"Hotel"> | number | null
    rooms?: RoomListRelationFilter
    reviews?: ReviewListRelationFilter
    policies?: HotelPolicyListRelationFilter
    events?: HotelEventListRelationFilter
    amenities?: HotelAmenitiesLinkListRelationFilter
  }, "id">

  export type HotelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    _count?: HotelCountOrderByAggregateInput
    _avg?: HotelAvgOrderByAggregateInput
    _max?: HotelMaxOrderByAggregateInput
    _min?: HotelMinOrderByAggregateInput
    _sum?: HotelSumOrderByAggregateInput
  }

  export type HotelScalarWhereWithAggregatesInput = {
    AND?: HotelScalarWhereWithAggregatesInput | HotelScalarWhereWithAggregatesInput[]
    OR?: HotelScalarWhereWithAggregatesInput[]
    NOT?: HotelScalarWhereWithAggregatesInput | HotelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Hotel"> | number
    name?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    address?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    city?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    rating?: FloatNullableWithAggregatesFilter<"Hotel"> | number | null
  }

  export type RoomTypeWhereInput = {
    AND?: RoomTypeWhereInput | RoomTypeWhereInput[]
    OR?: RoomTypeWhereInput[]
    NOT?: RoomTypeWhereInput | RoomTypeWhereInput[]
    id?: IntFilter<"RoomType"> | number
    typeName?: StringNullableFilter<"RoomType"> | string | null
    description?: StringNullableFilter<"RoomType"> | string | null
    rooms?: RoomListRelationFilter
  }

  export type RoomTypeOrderByWithRelationInput = {
    id?: SortOrder
    typeName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    rooms?: RoomOrderByRelationAggregateInput
    _relevance?: RoomTypeOrderByRelevanceInput
  }

  export type RoomTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoomTypeWhereInput | RoomTypeWhereInput[]
    OR?: RoomTypeWhereInput[]
    NOT?: RoomTypeWhereInput | RoomTypeWhereInput[]
    typeName?: StringNullableFilter<"RoomType"> | string | null
    description?: StringNullableFilter<"RoomType"> | string | null
    rooms?: RoomListRelationFilter
  }, "id">

  export type RoomTypeOrderByWithAggregationInput = {
    id?: SortOrder
    typeName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: RoomTypeCountOrderByAggregateInput
    _avg?: RoomTypeAvgOrderByAggregateInput
    _max?: RoomTypeMaxOrderByAggregateInput
    _min?: RoomTypeMinOrderByAggregateInput
    _sum?: RoomTypeSumOrderByAggregateInput
  }

  export type RoomTypeScalarWhereWithAggregatesInput = {
    AND?: RoomTypeScalarWhereWithAggregatesInput | RoomTypeScalarWhereWithAggregatesInput[]
    OR?: RoomTypeScalarWhereWithAggregatesInput[]
    NOT?: RoomTypeScalarWhereWithAggregatesInput | RoomTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoomType"> | number
    typeName?: StringNullableWithAggregatesFilter<"RoomType"> | string | null
    description?: StringNullableWithAggregatesFilter<"RoomType"> | string | null
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: IntFilter<"Room"> | number
    hotelId?: IntNullableFilter<"Room"> | number | null
    roomTypeId?: IntNullableFilter<"Room"> | number | null
    price?: DecimalNullableFilter<"Room"> | Decimal | DecimalJsLike | number | string | null
    availability?: BoolNullableFilter<"Room"> | boolean | null
    hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
    roomType?: XOR<RoomTypeNullableScalarRelationFilter, RoomTypeWhereInput> | null
    bookings?: BookingListRelationFilter
    amenities?: RoomAmenitiesLinkListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    roomTypeId?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    availability?: SortOrderInput | SortOrder
    hotel?: HotelOrderByWithRelationInput
    roomType?: RoomTypeOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
    amenities?: RoomAmenitiesLinkOrderByRelationAggregateInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    hotelId?: IntNullableFilter<"Room"> | number | null
    roomTypeId?: IntNullableFilter<"Room"> | number | null
    price?: DecimalNullableFilter<"Room"> | Decimal | DecimalJsLike | number | string | null
    availability?: BoolNullableFilter<"Room"> | boolean | null
    hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
    roomType?: XOR<RoomTypeNullableScalarRelationFilter, RoomTypeWhereInput> | null
    bookings?: BookingListRelationFilter
    amenities?: RoomAmenitiesLinkListRelationFilter
  }, "id">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    roomTypeId?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    availability?: SortOrderInput | SortOrder
    _count?: RoomCountOrderByAggregateInput
    _avg?: RoomAvgOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
    _sum?: RoomSumOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Room"> | number
    hotelId?: IntNullableWithAggregatesFilter<"Room"> | number | null
    roomTypeId?: IntNullableWithAggregatesFilter<"Room"> | number | null
    price?: DecimalNullableWithAggregatesFilter<"Room"> | Decimal | DecimalJsLike | number | string | null
    availability?: BoolNullableWithAggregatesFilter<"Room"> | boolean | null
  }

  export type BookingStatusWhereInput = {
    AND?: BookingStatusWhereInput | BookingStatusWhereInput[]
    OR?: BookingStatusWhereInput[]
    NOT?: BookingStatusWhereInput | BookingStatusWhereInput[]
    id?: IntFilter<"BookingStatus"> | number
    statusName?: StringNullableFilter<"BookingStatus"> | string | null
    bookings?: BookingListRelationFilter
  }

  export type BookingStatusOrderByWithRelationInput = {
    id?: SortOrder
    statusName?: SortOrderInput | SortOrder
    bookings?: BookingOrderByRelationAggregateInput
    _relevance?: BookingStatusOrderByRelevanceInput
  }

  export type BookingStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookingStatusWhereInput | BookingStatusWhereInput[]
    OR?: BookingStatusWhereInput[]
    NOT?: BookingStatusWhereInput | BookingStatusWhereInput[]
    statusName?: StringNullableFilter<"BookingStatus"> | string | null
    bookings?: BookingListRelationFilter
  }, "id">

  export type BookingStatusOrderByWithAggregationInput = {
    id?: SortOrder
    statusName?: SortOrderInput | SortOrder
    _count?: BookingStatusCountOrderByAggregateInput
    _avg?: BookingStatusAvgOrderByAggregateInput
    _max?: BookingStatusMaxOrderByAggregateInput
    _min?: BookingStatusMinOrderByAggregateInput
    _sum?: BookingStatusSumOrderByAggregateInput
  }

  export type BookingStatusScalarWhereWithAggregatesInput = {
    AND?: BookingStatusScalarWhereWithAggregatesInput | BookingStatusScalarWhereWithAggregatesInput[]
    OR?: BookingStatusScalarWhereWithAggregatesInput[]
    NOT?: BookingStatusScalarWhereWithAggregatesInput | BookingStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BookingStatus"> | number
    statusName?: StringNullableWithAggregatesFilter<"BookingStatus"> | string | null
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: IntFilter<"Booking"> | number
    customerId?: IntNullableFilter<"Booking"> | number | null
    roomId?: IntNullableFilter<"Booking"> | number | null
    statusId?: IntNullableFilter<"Booking"> | number | null
    checkIn?: DateTimeNullableFilter<"Booking"> | Date | string | null
    checkOut?: DateTimeNullableFilter<"Booking"> | Date | string | null
    totalPrice?: DecimalNullableFilter<"Booking"> | Decimal | DecimalJsLike | number | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    room?: XOR<RoomNullableScalarRelationFilter, RoomWhereInput> | null
    status?: XOR<BookingStatusNullableScalarRelationFilter, BookingStatusWhereInput> | null
    services?: BookingServiceListRelationFilter
    payments?: PaymentListRelationFilter
    promotions?: PromotionAppliedListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrderInput | SortOrder
    roomId?: SortOrderInput | SortOrder
    statusId?: SortOrderInput | SortOrder
    checkIn?: SortOrderInput | SortOrder
    checkOut?: SortOrderInput | SortOrder
    totalPrice?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
    status?: BookingStatusOrderByWithRelationInput
    services?: BookingServiceOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    promotions?: PromotionAppliedOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    customerId?: IntNullableFilter<"Booking"> | number | null
    roomId?: IntNullableFilter<"Booking"> | number | null
    statusId?: IntNullableFilter<"Booking"> | number | null
    checkIn?: DateTimeNullableFilter<"Booking"> | Date | string | null
    checkOut?: DateTimeNullableFilter<"Booking"> | Date | string | null
    totalPrice?: DecimalNullableFilter<"Booking"> | Decimal | DecimalJsLike | number | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    room?: XOR<RoomNullableScalarRelationFilter, RoomWhereInput> | null
    status?: XOR<BookingStatusNullableScalarRelationFilter, BookingStatusWhereInput> | null
    services?: BookingServiceListRelationFilter
    payments?: PaymentListRelationFilter
    promotions?: PromotionAppliedListRelationFilter
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrderInput | SortOrder
    roomId?: SortOrderInput | SortOrder
    statusId?: SortOrderInput | SortOrder
    checkIn?: SortOrderInput | SortOrder
    checkOut?: SortOrderInput | SortOrder
    totalPrice?: SortOrderInput | SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Booking"> | number
    customerId?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    roomId?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    statusId?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    checkIn?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    checkOut?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    totalPrice?: DecimalNullableWithAggregatesFilter<"Booking"> | Decimal | DecimalJsLike | number | string | null
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: IntFilter<"Service"> | number
    serviceName?: StringNullableFilter<"Service"> | string | null
    price?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    bookings?: BookingServiceListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    serviceName?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    bookings?: BookingServiceOrderByRelationAggregateInput
    _relevance?: ServiceOrderByRelevanceInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    serviceName?: StringNullableFilter<"Service"> | string | null
    price?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    bookings?: BookingServiceListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    serviceName?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Service"> | number
    serviceName?: StringNullableWithAggregatesFilter<"Service"> | string | null
    price?: DecimalNullableWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
  }

  export type BookingServiceWhereInput = {
    AND?: BookingServiceWhereInput | BookingServiceWhereInput[]
    OR?: BookingServiceWhereInput[]
    NOT?: BookingServiceWhereInput | BookingServiceWhereInput[]
    id?: IntFilter<"BookingService"> | number
    bookingId?: IntFilter<"BookingService"> | number
    serviceId?: IntNullableFilter<"BookingService"> | number | null
    quantity?: IntNullableFilter<"BookingService"> | number | null
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }

  export type BookingServiceOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    booking?: BookingOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type BookingServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookingServiceWhereInput | BookingServiceWhereInput[]
    OR?: BookingServiceWhereInput[]
    NOT?: BookingServiceWhereInput | BookingServiceWhereInput[]
    bookingId?: IntFilter<"BookingService"> | number
    serviceId?: IntNullableFilter<"BookingService"> | number | null
    quantity?: IntNullableFilter<"BookingService"> | number | null
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }, "id">

  export type BookingServiceOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    _count?: BookingServiceCountOrderByAggregateInput
    _avg?: BookingServiceAvgOrderByAggregateInput
    _max?: BookingServiceMaxOrderByAggregateInput
    _min?: BookingServiceMinOrderByAggregateInput
    _sum?: BookingServiceSumOrderByAggregateInput
  }

  export type BookingServiceScalarWhereWithAggregatesInput = {
    AND?: BookingServiceScalarWhereWithAggregatesInput | BookingServiceScalarWhereWithAggregatesInput[]
    OR?: BookingServiceScalarWhereWithAggregatesInput[]
    NOT?: BookingServiceScalarWhereWithAggregatesInput | BookingServiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BookingService"> | number
    bookingId?: IntWithAggregatesFilter<"BookingService"> | number
    serviceId?: IntNullableWithAggregatesFilter<"BookingService"> | number | null
    quantity?: IntNullableWithAggregatesFilter<"BookingService"> | number | null
  }

  export type EmployeeRoleWhereInput = {
    AND?: EmployeeRoleWhereInput | EmployeeRoleWhereInput[]
    OR?: EmployeeRoleWhereInput[]
    NOT?: EmployeeRoleWhereInput | EmployeeRoleWhereInput[]
    id?: IntFilter<"EmployeeRole"> | number
    roleName?: StringNullableFilter<"EmployeeRole"> | string | null
    description?: StringNullableFilter<"EmployeeRole"> | string | null
    employees?: EmployeeListRelationFilter
  }

  export type EmployeeRoleOrderByWithRelationInput = {
    id?: SortOrder
    roleName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
    _relevance?: EmployeeRoleOrderByRelevanceInput
  }

  export type EmployeeRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmployeeRoleWhereInput | EmployeeRoleWhereInput[]
    OR?: EmployeeRoleWhereInput[]
    NOT?: EmployeeRoleWhereInput | EmployeeRoleWhereInput[]
    roleName?: StringNullableFilter<"EmployeeRole"> | string | null
    description?: StringNullableFilter<"EmployeeRole"> | string | null
    employees?: EmployeeListRelationFilter
  }, "id">

  export type EmployeeRoleOrderByWithAggregationInput = {
    id?: SortOrder
    roleName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: EmployeeRoleCountOrderByAggregateInput
    _avg?: EmployeeRoleAvgOrderByAggregateInput
    _max?: EmployeeRoleMaxOrderByAggregateInput
    _min?: EmployeeRoleMinOrderByAggregateInput
    _sum?: EmployeeRoleSumOrderByAggregateInput
  }

  export type EmployeeRoleScalarWhereWithAggregatesInput = {
    AND?: EmployeeRoleScalarWhereWithAggregatesInput | EmployeeRoleScalarWhereWithAggregatesInput[]
    OR?: EmployeeRoleScalarWhereWithAggregatesInput[]
    NOT?: EmployeeRoleScalarWhereWithAggregatesInput | EmployeeRoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmployeeRole"> | number
    roleName?: StringNullableWithAggregatesFilter<"EmployeeRole"> | string | null
    description?: StringNullableWithAggregatesFilter<"EmployeeRole"> | string | null
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: IntFilter<"Department"> | number
    departmentName?: StringNullableFilter<"Department"> | string | null
    employees?: EmployeeListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    departmentName?: SortOrderInput | SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
    _relevance?: DepartmentOrderByRelevanceInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    departmentName?: StringNullableFilter<"Department"> | string | null
    employees?: EmployeeListRelationFilter
  }, "id">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    departmentName?: SortOrderInput | SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _avg?: DepartmentAvgOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
    _sum?: DepartmentSumOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Department"> | number
    departmentName?: StringNullableWithAggregatesFilter<"Department"> | string | null
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: IntFilter<"Employee"> | number
    roleId?: IntNullableFilter<"Employee"> | number | null
    departmentId?: IntNullableFilter<"Employee"> | number | null
    name?: StringNullableFilter<"Employee"> | string | null
    position?: StringNullableFilter<"Employee"> | string | null
    salary?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    role?: XOR<EmployeeRoleNullableScalarRelationFilter, EmployeeRoleWhereInput> | null
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    role?: EmployeeRoleOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    _relevance?: EmployeeOrderByRelevanceInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    roleId?: IntNullableFilter<"Employee"> | number | null
    departmentId?: IntNullableFilter<"Employee"> | number | null
    name?: StringNullableFilter<"Employee"> | string | null
    position?: StringNullableFilter<"Employee"> | string | null
    salary?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    role?: XOR<EmployeeRoleNullableScalarRelationFilter, EmployeeRoleWhereInput> | null
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
  }, "id">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Employee"> | number
    roleId?: IntNullableWithAggregatesFilter<"Employee"> | number | null
    departmentId?: IntNullableWithAggregatesFilter<"Employee"> | number | null
    name?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    position?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    salary?: DecimalNullableWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    bookingId?: IntNullableFilter<"Payment"> | number | null
    amount?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    paymentDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    paymentDate?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    booking?: BookingOrderByWithRelationInput
    _relevance?: PaymentOrderByRelevanceInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    bookingId?: IntNullableFilter<"Payment"> | number | null
    amount?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    paymentDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    paymentDate?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    bookingId?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    amount?: DecimalNullableWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    paymentDate?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"Payment"> | string | null
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: IntFilter<"Review"> | number
    customerId?: IntNullableFilter<"Review"> | number | null
    hotelId?: IntNullableFilter<"Review"> | number | null
    rating?: IntNullableFilter<"Review"> | number | null
    comments?: StringNullableFilter<"Review"> | string | null
    reviewDate?: DateTimeNullableFilter<"Review"> | Date | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrderInput | SortOrder
    hotelId?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    reviewDate?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    hotel?: HotelOrderByWithRelationInput
    _relevance?: ReviewOrderByRelevanceInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    customerId?: IntNullableFilter<"Review"> | number | null
    hotelId?: IntNullableFilter<"Review"> | number | null
    rating?: IntNullableFilter<"Review"> | number | null
    comments?: StringNullableFilter<"Review"> | string | null
    reviewDate?: DateTimeNullableFilter<"Review"> | Date | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrderInput | SortOrder
    hotelId?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    reviewDate?: SortOrderInput | SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Review"> | number
    customerId?: IntNullableWithAggregatesFilter<"Review"> | number | null
    hotelId?: IntNullableWithAggregatesFilter<"Review"> | number | null
    rating?: IntNullableWithAggregatesFilter<"Review"> | number | null
    comments?: StringNullableWithAggregatesFilter<"Review"> | string | null
    reviewDate?: DateTimeNullableWithAggregatesFilter<"Review"> | Date | string | null
  }

  export type PromotionWhereInput = {
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    id?: IntFilter<"Promotion"> | number
    description?: StringNullableFilter<"Promotion"> | string | null
    discount?: DecimalNullableFilter<"Promotion"> | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    bookings?: PromotionAppliedListRelationFilter
  }

  export type PromotionOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    bookings?: PromotionAppliedOrderByRelationAggregateInput
    _relevance?: PromotionOrderByRelevanceInput
  }

  export type PromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    description?: StringNullableFilter<"Promotion"> | string | null
    discount?: DecimalNullableFilter<"Promotion"> | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    bookings?: PromotionAppliedListRelationFilter
  }, "id">

  export type PromotionOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    _count?: PromotionCountOrderByAggregateInput
    _avg?: PromotionAvgOrderByAggregateInput
    _max?: PromotionMaxOrderByAggregateInput
    _min?: PromotionMinOrderByAggregateInput
    _sum?: PromotionSumOrderByAggregateInput
  }

  export type PromotionScalarWhereWithAggregatesInput = {
    AND?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    OR?: PromotionScalarWhereWithAggregatesInput[]
    NOT?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Promotion"> | number
    description?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    discount?: DecimalNullableWithAggregatesFilter<"Promotion"> | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Promotion"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Promotion"> | Date | string | null
  }

  export type RoomAmenityWhereInput = {
    AND?: RoomAmenityWhereInput | RoomAmenityWhereInput[]
    OR?: RoomAmenityWhereInput[]
    NOT?: RoomAmenityWhereInput | RoomAmenityWhereInput[]
    id?: IntFilter<"RoomAmenity"> | number
    amenityName?: StringNullableFilter<"RoomAmenity"> | string | null
    description?: StringNullableFilter<"RoomAmenity"> | string | null
    rooms?: RoomAmenitiesLinkListRelationFilter
  }

  export type RoomAmenityOrderByWithRelationInput = {
    id?: SortOrder
    amenityName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    rooms?: RoomAmenitiesLinkOrderByRelationAggregateInput
    _relevance?: RoomAmenityOrderByRelevanceInput
  }

  export type RoomAmenityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoomAmenityWhereInput | RoomAmenityWhereInput[]
    OR?: RoomAmenityWhereInput[]
    NOT?: RoomAmenityWhereInput | RoomAmenityWhereInput[]
    amenityName?: StringNullableFilter<"RoomAmenity"> | string | null
    description?: StringNullableFilter<"RoomAmenity"> | string | null
    rooms?: RoomAmenitiesLinkListRelationFilter
  }, "id">

  export type RoomAmenityOrderByWithAggregationInput = {
    id?: SortOrder
    amenityName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: RoomAmenityCountOrderByAggregateInput
    _avg?: RoomAmenityAvgOrderByAggregateInput
    _max?: RoomAmenityMaxOrderByAggregateInput
    _min?: RoomAmenityMinOrderByAggregateInput
    _sum?: RoomAmenitySumOrderByAggregateInput
  }

  export type RoomAmenityScalarWhereWithAggregatesInput = {
    AND?: RoomAmenityScalarWhereWithAggregatesInput | RoomAmenityScalarWhereWithAggregatesInput[]
    OR?: RoomAmenityScalarWhereWithAggregatesInput[]
    NOT?: RoomAmenityScalarWhereWithAggregatesInput | RoomAmenityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoomAmenity"> | number
    amenityName?: StringNullableWithAggregatesFilter<"RoomAmenity"> | string | null
    description?: StringNullableWithAggregatesFilter<"RoomAmenity"> | string | null
  }

  export type HotelAmenityWhereInput = {
    AND?: HotelAmenityWhereInput | HotelAmenityWhereInput[]
    OR?: HotelAmenityWhereInput[]
    NOT?: HotelAmenityWhereInput | HotelAmenityWhereInput[]
    id?: IntFilter<"HotelAmenity"> | number
    amenityName?: StringNullableFilter<"HotelAmenity"> | string | null
    description?: StringNullableFilter<"HotelAmenity"> | string | null
    hotels?: HotelAmenitiesLinkListRelationFilter
  }

  export type HotelAmenityOrderByWithRelationInput = {
    id?: SortOrder
    amenityName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    hotels?: HotelAmenitiesLinkOrderByRelationAggregateInput
    _relevance?: HotelAmenityOrderByRelevanceInput
  }

  export type HotelAmenityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HotelAmenityWhereInput | HotelAmenityWhereInput[]
    OR?: HotelAmenityWhereInput[]
    NOT?: HotelAmenityWhereInput | HotelAmenityWhereInput[]
    amenityName?: StringNullableFilter<"HotelAmenity"> | string | null
    description?: StringNullableFilter<"HotelAmenity"> | string | null
    hotels?: HotelAmenitiesLinkListRelationFilter
  }, "id">

  export type HotelAmenityOrderByWithAggregationInput = {
    id?: SortOrder
    amenityName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: HotelAmenityCountOrderByAggregateInput
    _avg?: HotelAmenityAvgOrderByAggregateInput
    _max?: HotelAmenityMaxOrderByAggregateInput
    _min?: HotelAmenityMinOrderByAggregateInput
    _sum?: HotelAmenitySumOrderByAggregateInput
  }

  export type HotelAmenityScalarWhereWithAggregatesInput = {
    AND?: HotelAmenityScalarWhereWithAggregatesInput | HotelAmenityScalarWhereWithAggregatesInput[]
    OR?: HotelAmenityScalarWhereWithAggregatesInput[]
    NOT?: HotelAmenityScalarWhereWithAggregatesInput | HotelAmenityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HotelAmenity"> | number
    amenityName?: StringNullableWithAggregatesFilter<"HotelAmenity"> | string | null
    description?: StringNullableWithAggregatesFilter<"HotelAmenity"> | string | null
  }

  export type HotelPolicyWhereInput = {
    AND?: HotelPolicyWhereInput | HotelPolicyWhereInput[]
    OR?: HotelPolicyWhereInput[]
    NOT?: HotelPolicyWhereInput | HotelPolicyWhereInput[]
    id?: IntFilter<"HotelPolicy"> | number
    hotelId?: IntNullableFilter<"HotelPolicy"> | number | null
    policyDescription?: StringNullableFilter<"HotelPolicy"> | string | null
    hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }

  export type HotelPolicyOrderByWithRelationInput = {
    id?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    policyDescription?: SortOrderInput | SortOrder
    hotel?: HotelOrderByWithRelationInput
    _relevance?: HotelPolicyOrderByRelevanceInput
  }

  export type HotelPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HotelPolicyWhereInput | HotelPolicyWhereInput[]
    OR?: HotelPolicyWhereInput[]
    NOT?: HotelPolicyWhereInput | HotelPolicyWhereInput[]
    hotelId?: IntNullableFilter<"HotelPolicy"> | number | null
    policyDescription?: StringNullableFilter<"HotelPolicy"> | string | null
    hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }, "id">

  export type HotelPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    policyDescription?: SortOrderInput | SortOrder
    _count?: HotelPolicyCountOrderByAggregateInput
    _avg?: HotelPolicyAvgOrderByAggregateInput
    _max?: HotelPolicyMaxOrderByAggregateInput
    _min?: HotelPolicyMinOrderByAggregateInput
    _sum?: HotelPolicySumOrderByAggregateInput
  }

  export type HotelPolicyScalarWhereWithAggregatesInput = {
    AND?: HotelPolicyScalarWhereWithAggregatesInput | HotelPolicyScalarWhereWithAggregatesInput[]
    OR?: HotelPolicyScalarWhereWithAggregatesInput[]
    NOT?: HotelPolicyScalarWhereWithAggregatesInput | HotelPolicyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HotelPolicy"> | number
    hotelId?: IntNullableWithAggregatesFilter<"HotelPolicy"> | number | null
    policyDescription?: StringNullableWithAggregatesFilter<"HotelPolicy"> | string | null
  }

  export type PromotionAppliedWhereInput = {
    AND?: PromotionAppliedWhereInput | PromotionAppliedWhereInput[]
    OR?: PromotionAppliedWhereInput[]
    NOT?: PromotionAppliedWhereInput | PromotionAppliedWhereInput[]
    id?: IntFilter<"PromotionApplied"> | number
    promotionId?: IntFilter<"PromotionApplied"> | number
    bookingId?: IntNullableFilter<"PromotionApplied"> | number | null
    promotion?: XOR<PromotionScalarRelationFilter, PromotionWhereInput>
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
  }

  export type PromotionAppliedOrderByWithRelationInput = {
    id?: SortOrder
    promotionId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    promotion?: PromotionOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
  }

  export type PromotionAppliedWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PromotionAppliedWhereInput | PromotionAppliedWhereInput[]
    OR?: PromotionAppliedWhereInput[]
    NOT?: PromotionAppliedWhereInput | PromotionAppliedWhereInput[]
    promotionId?: IntFilter<"PromotionApplied"> | number
    bookingId?: IntNullableFilter<"PromotionApplied"> | number | null
    promotion?: XOR<PromotionScalarRelationFilter, PromotionWhereInput>
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
  }, "id">

  export type PromotionAppliedOrderByWithAggregationInput = {
    id?: SortOrder
    promotionId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    _count?: PromotionAppliedCountOrderByAggregateInput
    _avg?: PromotionAppliedAvgOrderByAggregateInput
    _max?: PromotionAppliedMaxOrderByAggregateInput
    _min?: PromotionAppliedMinOrderByAggregateInput
    _sum?: PromotionAppliedSumOrderByAggregateInput
  }

  export type PromotionAppliedScalarWhereWithAggregatesInput = {
    AND?: PromotionAppliedScalarWhereWithAggregatesInput | PromotionAppliedScalarWhereWithAggregatesInput[]
    OR?: PromotionAppliedScalarWhereWithAggregatesInput[]
    NOT?: PromotionAppliedScalarWhereWithAggregatesInput | PromotionAppliedScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PromotionApplied"> | number
    promotionId?: IntWithAggregatesFilter<"PromotionApplied"> | number
    bookingId?: IntNullableWithAggregatesFilter<"PromotionApplied"> | number | null
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: IntFilter<"ActivityLog"> | number
    userId?: IntNullableFilter<"ActivityLog"> | number | null
    action?: StringNullableFilter<"ActivityLog"> | string | null
    logDate?: DateTimeNullableFilter<"ActivityLog"> | Date | string | null
    user?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    logDate?: SortOrderInput | SortOrder
    user?: CustomerOrderByWithRelationInput
    _relevance?: ActivityLogOrderByRelevanceInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    userId?: IntNullableFilter<"ActivityLog"> | number | null
    action?: StringNullableFilter<"ActivityLog"> | string | null
    logDate?: DateTimeNullableFilter<"ActivityLog"> | Date | string | null
    user?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    logDate?: SortOrderInput | SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _avg?: ActivityLogAvgOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
    _sum?: ActivityLogSumOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActivityLog"> | number
    userId?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    action?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    logDate?: DateTimeNullableWithAggregatesFilter<"ActivityLog"> | Date | string | null
  }

  export type HotelEventWhereInput = {
    AND?: HotelEventWhereInput | HotelEventWhereInput[]
    OR?: HotelEventWhereInput[]
    NOT?: HotelEventWhereInput | HotelEventWhereInput[]
    id?: IntFilter<"HotelEvent"> | number
    hotelId?: IntNullableFilter<"HotelEvent"> | number | null
    eventName?: StringNullableFilter<"HotelEvent"> | string | null
    eventDate?: DateTimeNullableFilter<"HotelEvent"> | Date | string | null
    description?: StringNullableFilter<"HotelEvent"> | string | null
    hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }

  export type HotelEventOrderByWithRelationInput = {
    id?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    eventName?: SortOrderInput | SortOrder
    eventDate?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    hotel?: HotelOrderByWithRelationInput
    _relevance?: HotelEventOrderByRelevanceInput
  }

  export type HotelEventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HotelEventWhereInput | HotelEventWhereInput[]
    OR?: HotelEventWhereInput[]
    NOT?: HotelEventWhereInput | HotelEventWhereInput[]
    hotelId?: IntNullableFilter<"HotelEvent"> | number | null
    eventName?: StringNullableFilter<"HotelEvent"> | string | null
    eventDate?: DateTimeNullableFilter<"HotelEvent"> | Date | string | null
    description?: StringNullableFilter<"HotelEvent"> | string | null
    hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }, "id">

  export type HotelEventOrderByWithAggregationInput = {
    id?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    eventName?: SortOrderInput | SortOrder
    eventDate?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: HotelEventCountOrderByAggregateInput
    _avg?: HotelEventAvgOrderByAggregateInput
    _max?: HotelEventMaxOrderByAggregateInput
    _min?: HotelEventMinOrderByAggregateInput
    _sum?: HotelEventSumOrderByAggregateInput
  }

  export type HotelEventScalarWhereWithAggregatesInput = {
    AND?: HotelEventScalarWhereWithAggregatesInput | HotelEventScalarWhereWithAggregatesInput[]
    OR?: HotelEventScalarWhereWithAggregatesInput[]
    NOT?: HotelEventScalarWhereWithAggregatesInput | HotelEventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HotelEvent"> | number
    hotelId?: IntNullableWithAggregatesFilter<"HotelEvent"> | number | null
    eventName?: StringNullableWithAggregatesFilter<"HotelEvent"> | string | null
    eventDate?: DateTimeNullableWithAggregatesFilter<"HotelEvent"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"HotelEvent"> | string | null
  }

  export type SystemNotificationWhereInput = {
    AND?: SystemNotificationWhereInput | SystemNotificationWhereInput[]
    OR?: SystemNotificationWhereInput[]
    NOT?: SystemNotificationWhereInput | SystemNotificationWhereInput[]
    id?: IntFilter<"SystemNotification"> | number
    userId?: IntNullableFilter<"SystemNotification"> | number | null
    message?: StringNullableFilter<"SystemNotification"> | string | null
    notificationDate?: DateTimeNullableFilter<"SystemNotification"> | Date | string | null
    user?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }

  export type SystemNotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    notificationDate?: SortOrderInput | SortOrder
    user?: CustomerOrderByWithRelationInput
    _relevance?: SystemNotificationOrderByRelevanceInput
  }

  export type SystemNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SystemNotificationWhereInput | SystemNotificationWhereInput[]
    OR?: SystemNotificationWhereInput[]
    NOT?: SystemNotificationWhereInput | SystemNotificationWhereInput[]
    userId?: IntNullableFilter<"SystemNotification"> | number | null
    message?: StringNullableFilter<"SystemNotification"> | string | null
    notificationDate?: DateTimeNullableFilter<"SystemNotification"> | Date | string | null
    user?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }, "id">

  export type SystemNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    notificationDate?: SortOrderInput | SortOrder
    _count?: SystemNotificationCountOrderByAggregateInput
    _avg?: SystemNotificationAvgOrderByAggregateInput
    _max?: SystemNotificationMaxOrderByAggregateInput
    _min?: SystemNotificationMinOrderByAggregateInput
    _sum?: SystemNotificationSumOrderByAggregateInput
  }

  export type SystemNotificationScalarWhereWithAggregatesInput = {
    AND?: SystemNotificationScalarWhereWithAggregatesInput | SystemNotificationScalarWhereWithAggregatesInput[]
    OR?: SystemNotificationScalarWhereWithAggregatesInput[]
    NOT?: SystemNotificationScalarWhereWithAggregatesInput | SystemNotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SystemNotification"> | number
    userId?: IntNullableWithAggregatesFilter<"SystemNotification"> | number | null
    message?: StringNullableWithAggregatesFilter<"SystemNotification"> | string | null
    notificationDate?: DateTimeNullableWithAggregatesFilter<"SystemNotification"> | Date | string | null
  }

  export type RoomAmenitiesLinkWhereInput = {
    AND?: RoomAmenitiesLinkWhereInput | RoomAmenitiesLinkWhereInput[]
    OR?: RoomAmenitiesLinkWhereInput[]
    NOT?: RoomAmenitiesLinkWhereInput | RoomAmenitiesLinkWhereInput[]
    id?: IntFilter<"RoomAmenitiesLink"> | number
    roomId?: IntFilter<"RoomAmenitiesLink"> | number
    amenityId?: IntNullableFilter<"RoomAmenitiesLink"> | number | null
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    amenity?: XOR<RoomAmenityNullableScalarRelationFilter, RoomAmenityWhereInput> | null
  }

  export type RoomAmenitiesLinkOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    amenityId?: SortOrderInput | SortOrder
    room?: RoomOrderByWithRelationInput
    amenity?: RoomAmenityOrderByWithRelationInput
  }

  export type RoomAmenitiesLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoomAmenitiesLinkWhereInput | RoomAmenitiesLinkWhereInput[]
    OR?: RoomAmenitiesLinkWhereInput[]
    NOT?: RoomAmenitiesLinkWhereInput | RoomAmenitiesLinkWhereInput[]
    roomId?: IntFilter<"RoomAmenitiesLink"> | number
    amenityId?: IntNullableFilter<"RoomAmenitiesLink"> | number | null
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    amenity?: XOR<RoomAmenityNullableScalarRelationFilter, RoomAmenityWhereInput> | null
  }, "id">

  export type RoomAmenitiesLinkOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    amenityId?: SortOrderInput | SortOrder
    _count?: RoomAmenitiesLinkCountOrderByAggregateInput
    _avg?: RoomAmenitiesLinkAvgOrderByAggregateInput
    _max?: RoomAmenitiesLinkMaxOrderByAggregateInput
    _min?: RoomAmenitiesLinkMinOrderByAggregateInput
    _sum?: RoomAmenitiesLinkSumOrderByAggregateInput
  }

  export type RoomAmenitiesLinkScalarWhereWithAggregatesInput = {
    AND?: RoomAmenitiesLinkScalarWhereWithAggregatesInput | RoomAmenitiesLinkScalarWhereWithAggregatesInput[]
    OR?: RoomAmenitiesLinkScalarWhereWithAggregatesInput[]
    NOT?: RoomAmenitiesLinkScalarWhereWithAggregatesInput | RoomAmenitiesLinkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoomAmenitiesLink"> | number
    roomId?: IntWithAggregatesFilter<"RoomAmenitiesLink"> | number
    amenityId?: IntNullableWithAggregatesFilter<"RoomAmenitiesLink"> | number | null
  }

  export type HotelAmenitiesLinkWhereInput = {
    AND?: HotelAmenitiesLinkWhereInput | HotelAmenitiesLinkWhereInput[]
    OR?: HotelAmenitiesLinkWhereInput[]
    NOT?: HotelAmenitiesLinkWhereInput | HotelAmenitiesLinkWhereInput[]
    id?: IntFilter<"HotelAmenitiesLink"> | number
    hotelId?: IntFilter<"HotelAmenitiesLink"> | number
    amenityId?: IntNullableFilter<"HotelAmenitiesLink"> | number | null
    hotel?: XOR<HotelScalarRelationFilter, HotelWhereInput>
    amenity?: XOR<HotelAmenityNullableScalarRelationFilter, HotelAmenityWhereInput> | null
  }

  export type HotelAmenitiesLinkOrderByWithRelationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    amenityId?: SortOrderInput | SortOrder
    hotel?: HotelOrderByWithRelationInput
    amenity?: HotelAmenityOrderByWithRelationInput
  }

  export type HotelAmenitiesLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HotelAmenitiesLinkWhereInput | HotelAmenitiesLinkWhereInput[]
    OR?: HotelAmenitiesLinkWhereInput[]
    NOT?: HotelAmenitiesLinkWhereInput | HotelAmenitiesLinkWhereInput[]
    hotelId?: IntFilter<"HotelAmenitiesLink"> | number
    amenityId?: IntNullableFilter<"HotelAmenitiesLink"> | number | null
    hotel?: XOR<HotelScalarRelationFilter, HotelWhereInput>
    amenity?: XOR<HotelAmenityNullableScalarRelationFilter, HotelAmenityWhereInput> | null
  }, "id">

  export type HotelAmenitiesLinkOrderByWithAggregationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    amenityId?: SortOrderInput | SortOrder
    _count?: HotelAmenitiesLinkCountOrderByAggregateInput
    _avg?: HotelAmenitiesLinkAvgOrderByAggregateInput
    _max?: HotelAmenitiesLinkMaxOrderByAggregateInput
    _min?: HotelAmenitiesLinkMinOrderByAggregateInput
    _sum?: HotelAmenitiesLinkSumOrderByAggregateInput
  }

  export type HotelAmenitiesLinkScalarWhereWithAggregatesInput = {
    AND?: HotelAmenitiesLinkScalarWhereWithAggregatesInput | HotelAmenitiesLinkScalarWhereWithAggregatesInput[]
    OR?: HotelAmenitiesLinkScalarWhereWithAggregatesInput[]
    NOT?: HotelAmenitiesLinkScalarWhereWithAggregatesInput | HotelAmenitiesLinkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HotelAmenitiesLink"> | number
    hotelId?: IntWithAggregatesFilter<"HotelAmenitiesLink"> | number
    amenityId?: IntNullableWithAggregatesFilter<"HotelAmenitiesLink"> | number | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    customerId?: IntNullableFilter<"User"> | number | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    customerId?: number
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }, "id" | "email" | "customerId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    customerId?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type CustomerCreateInput = {
    name?: string | null
    email?: string | null
    phone?: string | null
    bookings?: BookingCreateNestedManyWithoutCustomerInput
    reviews?: ReviewCreateNestedManyWithoutCustomerInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    notifications?: SystemNotificationCreateNestedManyWithoutUserInput
    User?: UserCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone?: string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCustomerInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    User?: UserUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUpdateManyWithoutCustomerNestedInput
    reviews?: ReviewUpdateManyWithoutCustomerNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    notifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    User?: UserUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCustomerNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    User?: UserUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone?: string | null
  }

  export type CustomerUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelCreateInput = {
    name?: string | null
    address?: string | null
    city?: string | null
    rating?: number | null
    rooms?: RoomCreateNestedManyWithoutHotelInput
    reviews?: ReviewCreateNestedManyWithoutHotelInput
    policies?: HotelPolicyCreateNestedManyWithoutHotelInput
    events?: HotelEventCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenitiesLinkCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateInput = {
    id?: number
    name?: string | null
    address?: string | null
    city?: string | null
    rating?: number | null
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHotelInput
    policies?: HotelPolicyUncheckedCreateNestedManyWithoutHotelInput
    events?: HotelEventUncheckedCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenitiesLinkUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    rooms?: RoomUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUpdateManyWithoutHotelNestedInput
    policies?: HotelPolicyUpdateManyWithoutHotelNestedInput
    events?: HotelEventUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenitiesLinkUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHotelNestedInput
    policies?: HotelPolicyUncheckedUpdateManyWithoutHotelNestedInput
    events?: HotelEventUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenitiesLinkUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type HotelCreateManyInput = {
    id?: number
    name?: string | null
    address?: string | null
    city?: string | null
    rating?: number | null
  }

  export type HotelUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type HotelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RoomTypeCreateInput = {
    typeName?: string | null
    description?: string | null
    rooms?: RoomCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateInput = {
    id?: number
    typeName?: string | null
    description?: string | null
    rooms?: RoomUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUpdateInput = {
    typeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rooms?: RoomUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rooms?: RoomUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeCreateManyInput = {
    id?: number
    typeName?: string | null
    description?: string | null
  }

  export type RoomTypeUpdateManyMutationInput = {
    typeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoomTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoomCreateInput = {
    price?: Decimal | DecimalJsLike | number | string | null
    availability?: boolean | null
    hotel?: HotelCreateNestedOneWithoutRoomsInput
    roomType?: RoomTypeCreateNestedOneWithoutRoomsInput
    bookings?: BookingCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenitiesLinkCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id?: number
    hotelId?: number | null
    roomTypeId?: number | null
    price?: Decimal | DecimalJsLike | number | string | null
    availability?: boolean | null
    bookings?: BookingUncheckedCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenitiesLinkUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    availability?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hotel?: HotelUpdateOneWithoutRoomsNestedInput
    roomType?: RoomTypeUpdateOneWithoutRoomsNestedInput
    bookings?: BookingUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenitiesLinkUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    availability?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookings?: BookingUncheckedUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenitiesLinkUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id?: number
    hotelId?: number | null
    roomTypeId?: number | null
    price?: Decimal | DecimalJsLike | number | string | null
    availability?: boolean | null
  }

  export type RoomUpdateManyMutationInput = {
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    availability?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    availability?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BookingStatusCreateInput = {
    statusName?: string | null
    bookings?: BookingCreateNestedManyWithoutStatusInput
  }

  export type BookingStatusUncheckedCreateInput = {
    id?: number
    statusName?: string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutStatusInput
  }

  export type BookingStatusUpdateInput = {
    statusName?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUpdateManyWithoutStatusNestedInput
  }

  export type BookingStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    statusName?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type BookingStatusCreateManyInput = {
    id?: number
    statusName?: string | null
  }

  export type BookingStatusUpdateManyMutationInput = {
    statusName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    statusName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingCreateInput = {
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    customer?: CustomerCreateNestedOneWithoutBookingsInput
    room?: RoomCreateNestedOneWithoutBookingsInput
    status?: BookingStatusCreateNestedOneWithoutBookingsInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    promotions?: PromotionAppliedCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: number
    customerId?: number | null
    roomId?: number | null
    statusId?: number | null
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    promotions?: PromotionAppliedUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customer?: CustomerUpdateOneWithoutBookingsNestedInput
    room?: RoomUpdateOneWithoutBookingsNestedInput
    status?: BookingStatusUpdateOneWithoutBookingsNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    promotions?: PromotionAppliedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    promotions?: PromotionAppliedUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: number
    customerId?: number | null
    roomId?: number | null
    statusId?: number | null
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type BookingUpdateManyMutationInput = {
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ServiceCreateInput = {
    serviceName?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    bookings?: BookingServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: number
    serviceName?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    bookings?: BookingServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bookings?: BookingServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bookings?: BookingServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: number
    serviceName?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
  }

  export type ServiceUpdateManyMutationInput = {
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type BookingServiceCreateInput = {
    quantity?: number | null
    booking: BookingCreateNestedOneWithoutServicesInput
    service?: ServiceCreateNestedOneWithoutBookingsInput
  }

  export type BookingServiceUncheckedCreateInput = {
    id?: number
    bookingId: number
    serviceId?: number | null
    quantity?: number | null
  }

  export type BookingServiceUpdateInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    booking?: BookingUpdateOneRequiredWithoutServicesNestedInput
    service?: ServiceUpdateOneWithoutBookingsNestedInput
  }

  export type BookingServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BookingServiceCreateManyInput = {
    id?: number
    bookingId: number
    serviceId?: number | null
    quantity?: number | null
  }

  export type BookingServiceUpdateManyMutationInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BookingServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeRoleCreateInput = {
    roleName?: string | null
    description?: string | null
    employees?: EmployeeCreateNestedManyWithoutRoleInput
  }

  export type EmployeeRoleUncheckedCreateInput = {
    id?: number
    roleName?: string | null
    description?: string | null
    employees?: EmployeeUncheckedCreateNestedManyWithoutRoleInput
  }

  export type EmployeeRoleUpdateInput = {
    roleName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: EmployeeUpdateManyWithoutRoleNestedInput
  }

  export type EmployeeRoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: EmployeeUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type EmployeeRoleCreateManyInput = {
    id?: number
    roleName?: string | null
    description?: string | null
  }

  export type EmployeeRoleUpdateManyMutationInput = {
    roleName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeRoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DepartmentCreateInput = {
    departmentName?: string | null
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: number
    departmentName?: string | null
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    departmentName?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    departmentName?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: number
    departmentName?: string | null
  }

  export type DepartmentUpdateManyMutationInput = {
    departmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    departmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeCreateInput = {
    name?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    role?: EmployeeRoleCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: number
    roleId?: number | null
    departmentId?: number | null
    name?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
  }

  export type EmployeeUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    role?: EmployeeRoleUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EmployeeCreateManyInput = {
    id?: number
    roleId?: number | null
    departmentId?: number | null
    name?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
  }

  export type EmployeeUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PaymentCreateInput = {
    amount?: Decimal | DecimalJsLike | number | string | null
    paymentDate?: Date | string | null
    paymentMethod?: string | null
    booking?: BookingCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    bookingId?: number | null
    amount?: Decimal | DecimalJsLike | number | string | null
    paymentDate?: Date | string | null
    paymentMethod?: string | null
  }

  export type PaymentUpdateInput = {
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    booking?: BookingUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyInput = {
    id?: number
    bookingId?: number | null
    amount?: Decimal | DecimalJsLike | number | string | null
    paymentDate?: Date | string | null
    paymentMethod?: string | null
  }

  export type PaymentUpdateManyMutationInput = {
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewCreateInput = {
    rating?: number | null
    comments?: string | null
    reviewDate?: Date | string | null
    customer?: CustomerCreateNestedOneWithoutReviewsInput
    hotel?: HotelCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: number
    customerId?: number | null
    hotelId?: number | null
    rating?: number | null
    comments?: string | null
    reviewDate?: Date | string | null
  }

  export type ReviewUpdateInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneWithoutReviewsNestedInput
    hotel?: HotelUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewCreateManyInput = {
    id?: number
    customerId?: number | null
    hotelId?: number | null
    rating?: number | null
    comments?: string | null
    reviewDate?: Date | string | null
  }

  export type ReviewUpdateManyMutationInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PromotionCreateInput = {
    description?: string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    bookings?: PromotionAppliedCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUncheckedCreateInput = {
    id?: number
    description?: string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    bookings?: PromotionAppliedUncheckedCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUpdateInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: PromotionAppliedUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: PromotionAppliedUncheckedUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionCreateManyInput = {
    id?: number
    description?: string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type PromotionUpdateManyMutationInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PromotionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoomAmenityCreateInput = {
    amenityName?: string | null
    description?: string | null
    rooms?: RoomAmenitiesLinkCreateNestedManyWithoutAmenityInput
  }

  export type RoomAmenityUncheckedCreateInput = {
    id?: number
    amenityName?: string | null
    description?: string | null
    rooms?: RoomAmenitiesLinkUncheckedCreateNestedManyWithoutAmenityInput
  }

  export type RoomAmenityUpdateInput = {
    amenityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rooms?: RoomAmenitiesLinkUpdateManyWithoutAmenityNestedInput
  }

  export type RoomAmenityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rooms?: RoomAmenitiesLinkUncheckedUpdateManyWithoutAmenityNestedInput
  }

  export type RoomAmenityCreateManyInput = {
    id?: number
    amenityName?: string | null
    description?: string | null
  }

  export type RoomAmenityUpdateManyMutationInput = {
    amenityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoomAmenityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelAmenityCreateInput = {
    amenityName?: string | null
    description?: string | null
    hotels?: HotelAmenitiesLinkCreateNestedManyWithoutAmenityInput
  }

  export type HotelAmenityUncheckedCreateInput = {
    id?: number
    amenityName?: string | null
    description?: string | null
    hotels?: HotelAmenitiesLinkUncheckedCreateNestedManyWithoutAmenityInput
  }

  export type HotelAmenityUpdateInput = {
    amenityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hotels?: HotelAmenitiesLinkUpdateManyWithoutAmenityNestedInput
  }

  export type HotelAmenityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hotels?: HotelAmenitiesLinkUncheckedUpdateManyWithoutAmenityNestedInput
  }

  export type HotelAmenityCreateManyInput = {
    id?: number
    amenityName?: string | null
    description?: string | null
  }

  export type HotelAmenityUpdateManyMutationInput = {
    amenityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelAmenityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelPolicyCreateInput = {
    policyDescription?: string | null
    hotel?: HotelCreateNestedOneWithoutPoliciesInput
  }

  export type HotelPolicyUncheckedCreateInput = {
    id?: number
    hotelId?: number | null
    policyDescription?: string | null
  }

  export type HotelPolicyUpdateInput = {
    policyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    hotel?: HotelUpdateOneWithoutPoliciesNestedInput
  }

  export type HotelPolicyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    policyDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelPolicyCreateManyInput = {
    id?: number
    hotelId?: number | null
    policyDescription?: string | null
  }

  export type HotelPolicyUpdateManyMutationInput = {
    policyDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelPolicyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    policyDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromotionAppliedCreateInput = {
    promotion: PromotionCreateNestedOneWithoutBookingsInput
    booking?: BookingCreateNestedOneWithoutPromotionsInput
  }

  export type PromotionAppliedUncheckedCreateInput = {
    id?: number
    promotionId: number
    bookingId?: number | null
  }

  export type PromotionAppliedUpdateInput = {
    promotion?: PromotionUpdateOneRequiredWithoutBookingsNestedInput
    booking?: BookingUpdateOneWithoutPromotionsNestedInput
  }

  export type PromotionAppliedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotionId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PromotionAppliedCreateManyInput = {
    id?: number
    promotionId: number
    bookingId?: number | null
  }

  export type PromotionAppliedUpdateManyMutationInput = {

  }

  export type PromotionAppliedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotionId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityLogCreateInput = {
    action?: string | null
    logDate?: Date | string | null
    user?: CustomerCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: number
    userId?: number | null
    action?: string | null
    logDate?: Date | string | null
  }

  export type ActivityLogUpdateInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: CustomerUpdateOneWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityLogCreateManyInput = {
    id?: number
    userId?: number | null
    action?: string | null
    logDate?: Date | string | null
  }

  export type ActivityLogUpdateManyMutationInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HotelEventCreateInput = {
    eventName?: string | null
    eventDate?: Date | string | null
    description?: string | null
    hotel?: HotelCreateNestedOneWithoutEventsInput
  }

  export type HotelEventUncheckedCreateInput = {
    id?: number
    hotelId?: number | null
    eventName?: string | null
    eventDate?: Date | string | null
    description?: string | null
  }

  export type HotelEventUpdateInput = {
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hotel?: HotelUpdateOneWithoutEventsNestedInput
  }

  export type HotelEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelEventCreateManyInput = {
    id?: number
    hotelId?: number | null
    eventName?: string | null
    eventDate?: Date | string | null
    description?: string | null
  }

  export type HotelEventUpdateManyMutationInput = {
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemNotificationCreateInput = {
    message?: string | null
    notificationDate?: Date | string | null
    user?: CustomerCreateNestedOneWithoutNotificationsInput
  }

  export type SystemNotificationUncheckedCreateInput = {
    id?: number
    userId?: number | null
    message?: string | null
    notificationDate?: Date | string | null
  }

  export type SystemNotificationUpdateInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null
    notificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: CustomerUpdateOneWithoutNotificationsNestedInput
  }

  export type SystemNotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    notificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemNotificationCreateManyInput = {
    id?: number
    userId?: number | null
    message?: string | null
    notificationDate?: Date | string | null
  }

  export type SystemNotificationUpdateManyMutationInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null
    notificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemNotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    notificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoomAmenitiesLinkCreateInput = {
    room: RoomCreateNestedOneWithoutAmenitiesInput
    amenity?: RoomAmenityCreateNestedOneWithoutRoomsInput
  }

  export type RoomAmenitiesLinkUncheckedCreateInput = {
    id?: number
    roomId: number
    amenityId?: number | null
  }

  export type RoomAmenitiesLinkUpdateInput = {
    room?: RoomUpdateOneRequiredWithoutAmenitiesNestedInput
    amenity?: RoomAmenityUpdateOneWithoutRoomsNestedInput
  }

  export type RoomAmenitiesLinkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    amenityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomAmenitiesLinkCreateManyInput = {
    id?: number
    roomId: number
    amenityId?: number | null
  }

  export type RoomAmenitiesLinkUpdateManyMutationInput = {

  }

  export type RoomAmenitiesLinkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    amenityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotelAmenitiesLinkCreateInput = {
    hotel: HotelCreateNestedOneWithoutAmenitiesInput
    amenity?: HotelAmenityCreateNestedOneWithoutHotelsInput
  }

  export type HotelAmenitiesLinkUncheckedCreateInput = {
    id?: number
    hotelId: number
    amenityId?: number | null
  }

  export type HotelAmenitiesLinkUpdateInput = {
    hotel?: HotelUpdateOneRequiredWithoutAmenitiesNestedInput
    amenity?: HotelAmenityUpdateOneWithoutHotelsNestedInput
  }

  export type HotelAmenitiesLinkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    amenityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotelAmenitiesLinkCreateManyInput = {
    id?: number
    hotelId: number
    amenityId?: number | null
  }

  export type HotelAmenitiesLinkUpdateManyMutationInput = {

  }

  export type HotelAmenitiesLinkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    amenityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId?: number | null
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId?: number | null
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type SystemNotificationListRelationFilter = {
    every?: SystemNotificationWhereInput
    some?: SystemNotificationWhereInput
    none?: SystemNotificationWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelevanceInput = {
    fields: CustomerOrderByRelevanceFieldEnum | CustomerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type HotelPolicyListRelationFilter = {
    every?: HotelPolicyWhereInput
    some?: HotelPolicyWhereInput
    none?: HotelPolicyWhereInput
  }

  export type HotelEventListRelationFilter = {
    every?: HotelEventWhereInput
    some?: HotelEventWhereInput
    none?: HotelEventWhereInput
  }

  export type HotelAmenitiesLinkListRelationFilter = {
    every?: HotelAmenitiesLinkWhereInput
    some?: HotelAmenitiesLinkWhereInput
    none?: HotelAmenitiesLinkWhereInput
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelPolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelAmenitiesLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelOrderByRelevanceInput = {
    fields: HotelOrderByRelevanceFieldEnum | HotelOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type HotelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    rating?: SortOrder
  }

  export type HotelAvgOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
  }

  export type HotelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    rating?: SortOrder
  }

  export type HotelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    rating?: SortOrder
  }

  export type HotelSumOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type RoomTypeOrderByRelevanceInput = {
    fields: RoomTypeOrderByRelevanceFieldEnum | RoomTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoomTypeCountOrderByAggregateInput = {
    id?: SortOrder
    typeName?: SortOrder
    description?: SortOrder
  }

  export type RoomTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoomTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    typeName?: SortOrder
    description?: SortOrder
  }

  export type RoomTypeMinOrderByAggregateInput = {
    id?: SortOrder
    typeName?: SortOrder
    description?: SortOrder
  }

  export type RoomTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type HotelNullableScalarRelationFilter = {
    is?: HotelWhereInput | null
    isNot?: HotelWhereInput | null
  }

  export type RoomTypeNullableScalarRelationFilter = {
    is?: RoomTypeWhereInput | null
    isNot?: RoomTypeWhereInput | null
  }

  export type RoomAmenitiesLinkListRelationFilter = {
    every?: RoomAmenitiesLinkWhereInput
    some?: RoomAmenitiesLinkWhereInput
    none?: RoomAmenitiesLinkWhereInput
  }

  export type RoomAmenitiesLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrder
    price?: SortOrder
    availability?: SortOrder
  }

  export type RoomAvgOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrder
    price?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrder
    price?: SortOrder
    availability?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrder
    price?: SortOrder
    availability?: SortOrder
  }

  export type RoomSumOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrder
    price?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BookingStatusOrderByRelevanceInput = {
    fields: BookingStatusOrderByRelevanceFieldEnum | BookingStatusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BookingStatusCountOrderByAggregateInput = {
    id?: SortOrder
    statusName?: SortOrder
  }

  export type BookingStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BookingStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    statusName?: SortOrder
  }

  export type BookingStatusMinOrderByAggregateInput = {
    id?: SortOrder
    statusName?: SortOrder
  }

  export type BookingStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type RoomNullableScalarRelationFilter = {
    is?: RoomWhereInput | null
    isNot?: RoomWhereInput | null
  }

  export type BookingStatusNullableScalarRelationFilter = {
    is?: BookingStatusWhereInput | null
    isNot?: BookingStatusWhereInput | null
  }

  export type BookingServiceListRelationFilter = {
    every?: BookingServiceWhereInput
    some?: BookingServiceWhereInput
    none?: BookingServiceWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PromotionAppliedListRelationFilter = {
    every?: PromotionAppliedWhereInput
    some?: PromotionAppliedWhereInput
    none?: PromotionAppliedWhereInput
  }

  export type BookingServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromotionAppliedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    roomId?: SortOrder
    statusId?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    totalPrice?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    roomId?: SortOrder
    statusId?: SortOrder
    totalPrice?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    roomId?: SortOrder
    statusId?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    totalPrice?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    roomId?: SortOrder
    statusId?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    totalPrice?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    roomId?: SortOrder
    statusId?: SortOrder
    totalPrice?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ServiceOrderByRelevanceInput = {
    fields: ServiceOrderByRelevanceFieldEnum | ServiceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    serviceName?: SortOrder
    price?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceName?: SortOrder
    price?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    serviceName?: SortOrder
    price?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type BookingScalarRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type ServiceNullableScalarRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type BookingServiceCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
  }

  export type BookingServiceAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
  }

  export type BookingServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
  }

  export type BookingServiceMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
  }

  export type BookingServiceSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeRoleOrderByRelevanceInput = {
    fields: EmployeeRoleOrderByRelevanceFieldEnum | EmployeeRoleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmployeeRoleCountOrderByAggregateInput = {
    id?: SortOrder
    roleName?: SortOrder
    description?: SortOrder
  }

  export type EmployeeRoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmployeeRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    roleName?: SortOrder
    description?: SortOrder
  }

  export type EmployeeRoleMinOrderByAggregateInput = {
    id?: SortOrder
    roleName?: SortOrder
    description?: SortOrder
  }

  export type EmployeeRoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DepartmentOrderByRelevanceInput = {
    fields: DepartmentOrderByRelevanceFieldEnum | DepartmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    departmentName?: SortOrder
  }

  export type DepartmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    departmentName?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    departmentName?: SortOrder
  }

  export type DepartmentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmployeeRoleNullableScalarRelationFilter = {
    is?: EmployeeRoleWhereInput | null
    isNot?: EmployeeRoleWhereInput | null
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type EmployeeOrderByRelevanceInput = {
    fields: EmployeeOrderByRelevanceFieldEnum | EmployeeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    departmentId?: SortOrder
    name?: SortOrder
    position?: SortOrder
    salary?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    departmentId?: SortOrder
    salary?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    departmentId?: SortOrder
    name?: SortOrder
    position?: SortOrder
    salary?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    departmentId?: SortOrder
    name?: SortOrder
    position?: SortOrder
    salary?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    departmentId?: SortOrder
    salary?: SortOrder
  }

  export type BookingNullableScalarRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type PaymentOrderByRelevanceInput = {
    fields: PaymentOrderByRelevanceFieldEnum | PaymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
  }

  export type ReviewOrderByRelevanceInput = {
    fields: ReviewOrderByRelevanceFieldEnum | ReviewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    hotelId?: SortOrder
    rating?: SortOrder
    comments?: SortOrder
    reviewDate?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    hotelId?: SortOrder
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    hotelId?: SortOrder
    rating?: SortOrder
    comments?: SortOrder
    reviewDate?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    hotelId?: SortOrder
    rating?: SortOrder
    comments?: SortOrder
    reviewDate?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    hotelId?: SortOrder
    rating?: SortOrder
  }

  export type PromotionOrderByRelevanceInput = {
    fields: PromotionOrderByRelevanceFieldEnum | PromotionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PromotionCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    discount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type PromotionAvgOrderByAggregateInput = {
    id?: SortOrder
    discount?: SortOrder
  }

  export type PromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    discount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type PromotionMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    discount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type PromotionSumOrderByAggregateInput = {
    id?: SortOrder
    discount?: SortOrder
  }

  export type RoomAmenityOrderByRelevanceInput = {
    fields: RoomAmenityOrderByRelevanceFieldEnum | RoomAmenityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoomAmenityCountOrderByAggregateInput = {
    id?: SortOrder
    amenityName?: SortOrder
    description?: SortOrder
  }

  export type RoomAmenityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoomAmenityMaxOrderByAggregateInput = {
    id?: SortOrder
    amenityName?: SortOrder
    description?: SortOrder
  }

  export type RoomAmenityMinOrderByAggregateInput = {
    id?: SortOrder
    amenityName?: SortOrder
    description?: SortOrder
  }

  export type RoomAmenitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HotelAmenityOrderByRelevanceInput = {
    fields: HotelAmenityOrderByRelevanceFieldEnum | HotelAmenityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type HotelAmenityCountOrderByAggregateInput = {
    id?: SortOrder
    amenityName?: SortOrder
    description?: SortOrder
  }

  export type HotelAmenityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HotelAmenityMaxOrderByAggregateInput = {
    id?: SortOrder
    amenityName?: SortOrder
    description?: SortOrder
  }

  export type HotelAmenityMinOrderByAggregateInput = {
    id?: SortOrder
    amenityName?: SortOrder
    description?: SortOrder
  }

  export type HotelAmenitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HotelPolicyOrderByRelevanceInput = {
    fields: HotelPolicyOrderByRelevanceFieldEnum | HotelPolicyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type HotelPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    policyDescription?: SortOrder
  }

  export type HotelPolicyAvgOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
  }

  export type HotelPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    policyDescription?: SortOrder
  }

  export type HotelPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    policyDescription?: SortOrder
  }

  export type HotelPolicySumOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
  }

  export type PromotionScalarRelationFilter = {
    is?: PromotionWhereInput
    isNot?: PromotionWhereInput
  }

  export type PromotionAppliedCountOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    bookingId?: SortOrder
  }

  export type PromotionAppliedAvgOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    bookingId?: SortOrder
  }

  export type PromotionAppliedMaxOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    bookingId?: SortOrder
  }

  export type PromotionAppliedMinOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    bookingId?: SortOrder
  }

  export type PromotionAppliedSumOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    bookingId?: SortOrder
  }

  export type ActivityLogOrderByRelevanceInput = {
    fields: ActivityLogOrderByRelevanceFieldEnum | ActivityLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    logDate?: SortOrder
  }

  export type ActivityLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    logDate?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    logDate?: SortOrder
  }

  export type ActivityLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type HotelEventOrderByRelevanceInput = {
    fields: HotelEventOrderByRelevanceFieldEnum | HotelEventOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type HotelEventCountOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    eventName?: SortOrder
    eventDate?: SortOrder
    description?: SortOrder
  }

  export type HotelEventAvgOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
  }

  export type HotelEventMaxOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    eventName?: SortOrder
    eventDate?: SortOrder
    description?: SortOrder
  }

  export type HotelEventMinOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    eventName?: SortOrder
    eventDate?: SortOrder
    description?: SortOrder
  }

  export type HotelEventSumOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
  }

  export type SystemNotificationOrderByRelevanceInput = {
    fields: SystemNotificationOrderByRelevanceFieldEnum | SystemNotificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SystemNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    notificationDate?: SortOrder
  }

  export type SystemNotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SystemNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    notificationDate?: SortOrder
  }

  export type SystemNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    notificationDate?: SortOrder
  }

  export type SystemNotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type RoomScalarRelationFilter = {
    is?: RoomWhereInput
    isNot?: RoomWhereInput
  }

  export type RoomAmenityNullableScalarRelationFilter = {
    is?: RoomAmenityWhereInput | null
    isNot?: RoomAmenityWhereInput | null
  }

  export type RoomAmenitiesLinkCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    amenityId?: SortOrder
  }

  export type RoomAmenitiesLinkAvgOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    amenityId?: SortOrder
  }

  export type RoomAmenitiesLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    amenityId?: SortOrder
  }

  export type RoomAmenitiesLinkMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    amenityId?: SortOrder
  }

  export type RoomAmenitiesLinkSumOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    amenityId?: SortOrder
  }

  export type HotelScalarRelationFilter = {
    is?: HotelWhereInput
    isNot?: HotelWhereInput
  }

  export type HotelAmenityNullableScalarRelationFilter = {
    is?: HotelAmenityWhereInput | null
    isNot?: HotelAmenityWhereInput | null
  }

  export type HotelAmenitiesLinkCountOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    amenityId?: SortOrder
  }

  export type HotelAmenitiesLinkAvgOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    amenityId?: SortOrder
  }

  export type HotelAmenitiesLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    amenityId?: SortOrder
  }

  export type HotelAmenitiesLinkMinOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    amenityId?: SortOrder
  }

  export type HotelAmenitiesLinkSumOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    amenityId?: SortOrder
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BookingCreateNestedManyWithoutCustomerInput = {
    create?: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput> | BookingCreateWithoutCustomerInput[] | BookingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCustomerInput | BookingCreateOrConnectWithoutCustomerInput[]
    createMany?: BookingCreateManyCustomerInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ReviewCreateWithoutCustomerInput, ReviewUncheckedCreateWithoutCustomerInput> | ReviewCreateWithoutCustomerInput[] | ReviewUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCustomerInput | ReviewCreateOrConnectWithoutCustomerInput[]
    createMany?: ReviewCreateManyCustomerInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type SystemNotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<SystemNotificationCreateWithoutUserInput, SystemNotificationUncheckedCreateWithoutUserInput> | SystemNotificationCreateWithoutUserInput[] | SystemNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemNotificationCreateOrConnectWithoutUserInput | SystemNotificationCreateOrConnectWithoutUserInput[]
    createMany?: SystemNotificationCreateManyUserInputEnvelope
    connect?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutCustomerInput = {
    create?: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput> | UserCreateWithoutCustomerInput[] | UserUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCustomerInput | UserCreateOrConnectWithoutCustomerInput[]
    createMany?: UserCreateManyCustomerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput> | BookingCreateWithoutCustomerInput[] | BookingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCustomerInput | BookingCreateOrConnectWithoutCustomerInput[]
    createMany?: BookingCreateManyCustomerInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ReviewCreateWithoutCustomerInput, ReviewUncheckedCreateWithoutCustomerInput> | ReviewCreateWithoutCustomerInput[] | ReviewUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCustomerInput | ReviewCreateOrConnectWithoutCustomerInput[]
    createMany?: ReviewCreateManyCustomerInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type SystemNotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SystemNotificationCreateWithoutUserInput, SystemNotificationUncheckedCreateWithoutUserInput> | SystemNotificationCreateWithoutUserInput[] | SystemNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemNotificationCreateOrConnectWithoutUserInput | SystemNotificationCreateOrConnectWithoutUserInput[]
    createMany?: SystemNotificationCreateManyUserInputEnvelope
    connect?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput> | UserCreateWithoutCustomerInput[] | UserUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCustomerInput | UserCreateOrConnectWithoutCustomerInput[]
    createMany?: UserCreateManyCustomerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BookingUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput> | BookingCreateWithoutCustomerInput[] | BookingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCustomerInput | BookingCreateOrConnectWithoutCustomerInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutCustomerInput | BookingUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: BookingCreateManyCustomerInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutCustomerInput | BookingUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutCustomerInput | BookingUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ReviewCreateWithoutCustomerInput, ReviewUncheckedCreateWithoutCustomerInput> | ReviewCreateWithoutCustomerInput[] | ReviewUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCustomerInput | ReviewCreateOrConnectWithoutCustomerInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutCustomerInput | ReviewUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ReviewCreateManyCustomerInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutCustomerInput | ReviewUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutCustomerInput | ReviewUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type SystemNotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<SystemNotificationCreateWithoutUserInput, SystemNotificationUncheckedCreateWithoutUserInput> | SystemNotificationCreateWithoutUserInput[] | SystemNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemNotificationCreateOrConnectWithoutUserInput | SystemNotificationCreateOrConnectWithoutUserInput[]
    upsert?: SystemNotificationUpsertWithWhereUniqueWithoutUserInput | SystemNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SystemNotificationCreateManyUserInputEnvelope
    set?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
    disconnect?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
    delete?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
    connect?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
    update?: SystemNotificationUpdateWithWhereUniqueWithoutUserInput | SystemNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SystemNotificationUpdateManyWithWhereWithoutUserInput | SystemNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SystemNotificationScalarWhereInput | SystemNotificationScalarWhereInput[]
  }

  export type UserUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput> | UserCreateWithoutCustomerInput[] | UserUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCustomerInput | UserCreateOrConnectWithoutCustomerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCustomerInput | UserUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: UserCreateManyCustomerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCustomerInput | UserUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCustomerInput | UserUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BookingUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput> | BookingCreateWithoutCustomerInput[] | BookingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCustomerInput | BookingCreateOrConnectWithoutCustomerInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutCustomerInput | BookingUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: BookingCreateManyCustomerInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutCustomerInput | BookingUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutCustomerInput | BookingUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ReviewCreateWithoutCustomerInput, ReviewUncheckedCreateWithoutCustomerInput> | ReviewCreateWithoutCustomerInput[] | ReviewUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCustomerInput | ReviewCreateOrConnectWithoutCustomerInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutCustomerInput | ReviewUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ReviewCreateManyCustomerInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutCustomerInput | ReviewUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutCustomerInput | ReviewUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type SystemNotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SystemNotificationCreateWithoutUserInput, SystemNotificationUncheckedCreateWithoutUserInput> | SystemNotificationCreateWithoutUserInput[] | SystemNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemNotificationCreateOrConnectWithoutUserInput | SystemNotificationCreateOrConnectWithoutUserInput[]
    upsert?: SystemNotificationUpsertWithWhereUniqueWithoutUserInput | SystemNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SystemNotificationCreateManyUserInputEnvelope
    set?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
    disconnect?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
    delete?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
    connect?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
    update?: SystemNotificationUpdateWithWhereUniqueWithoutUserInput | SystemNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SystemNotificationUpdateManyWithWhereWithoutUserInput | SystemNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SystemNotificationScalarWhereInput | SystemNotificationScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput> | UserCreateWithoutCustomerInput[] | UserUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCustomerInput | UserCreateOrConnectWithoutCustomerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCustomerInput | UserUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: UserCreateManyCustomerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCustomerInput | UserUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCustomerInput | UserUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoomCreateNestedManyWithoutHotelInput = {
    create?: XOR<RoomCreateWithoutHotelInput, RoomUncheckedCreateWithoutHotelInput> | RoomCreateWithoutHotelInput[] | RoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutHotelInput | RoomCreateOrConnectWithoutHotelInput[]
    createMany?: RoomCreateManyHotelInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutHotelInput = {
    create?: XOR<ReviewCreateWithoutHotelInput, ReviewUncheckedCreateWithoutHotelInput> | ReviewCreateWithoutHotelInput[] | ReviewUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutHotelInput | ReviewCreateOrConnectWithoutHotelInput[]
    createMany?: ReviewCreateManyHotelInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type HotelPolicyCreateNestedManyWithoutHotelInput = {
    create?: XOR<HotelPolicyCreateWithoutHotelInput, HotelPolicyUncheckedCreateWithoutHotelInput> | HotelPolicyCreateWithoutHotelInput[] | HotelPolicyUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelPolicyCreateOrConnectWithoutHotelInput | HotelPolicyCreateOrConnectWithoutHotelInput[]
    createMany?: HotelPolicyCreateManyHotelInputEnvelope
    connect?: HotelPolicyWhereUniqueInput | HotelPolicyWhereUniqueInput[]
  }

  export type HotelEventCreateNestedManyWithoutHotelInput = {
    create?: XOR<HotelEventCreateWithoutHotelInput, HotelEventUncheckedCreateWithoutHotelInput> | HotelEventCreateWithoutHotelInput[] | HotelEventUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelEventCreateOrConnectWithoutHotelInput | HotelEventCreateOrConnectWithoutHotelInput[]
    createMany?: HotelEventCreateManyHotelInputEnvelope
    connect?: HotelEventWhereUniqueInput | HotelEventWhereUniqueInput[]
  }

  export type HotelAmenitiesLinkCreateNestedManyWithoutHotelInput = {
    create?: XOR<HotelAmenitiesLinkCreateWithoutHotelInput, HotelAmenitiesLinkUncheckedCreateWithoutHotelInput> | HotelAmenitiesLinkCreateWithoutHotelInput[] | HotelAmenitiesLinkUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelAmenitiesLinkCreateOrConnectWithoutHotelInput | HotelAmenitiesLinkCreateOrConnectWithoutHotelInput[]
    createMany?: HotelAmenitiesLinkCreateManyHotelInputEnvelope
    connect?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<RoomCreateWithoutHotelInput, RoomUncheckedCreateWithoutHotelInput> | RoomCreateWithoutHotelInput[] | RoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutHotelInput | RoomCreateOrConnectWithoutHotelInput[]
    createMany?: RoomCreateManyHotelInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<ReviewCreateWithoutHotelInput, ReviewUncheckedCreateWithoutHotelInput> | ReviewCreateWithoutHotelInput[] | ReviewUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutHotelInput | ReviewCreateOrConnectWithoutHotelInput[]
    createMany?: ReviewCreateManyHotelInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type HotelPolicyUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<HotelPolicyCreateWithoutHotelInput, HotelPolicyUncheckedCreateWithoutHotelInput> | HotelPolicyCreateWithoutHotelInput[] | HotelPolicyUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelPolicyCreateOrConnectWithoutHotelInput | HotelPolicyCreateOrConnectWithoutHotelInput[]
    createMany?: HotelPolicyCreateManyHotelInputEnvelope
    connect?: HotelPolicyWhereUniqueInput | HotelPolicyWhereUniqueInput[]
  }

  export type HotelEventUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<HotelEventCreateWithoutHotelInput, HotelEventUncheckedCreateWithoutHotelInput> | HotelEventCreateWithoutHotelInput[] | HotelEventUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelEventCreateOrConnectWithoutHotelInput | HotelEventCreateOrConnectWithoutHotelInput[]
    createMany?: HotelEventCreateManyHotelInputEnvelope
    connect?: HotelEventWhereUniqueInput | HotelEventWhereUniqueInput[]
  }

  export type HotelAmenitiesLinkUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<HotelAmenitiesLinkCreateWithoutHotelInput, HotelAmenitiesLinkUncheckedCreateWithoutHotelInput> | HotelAmenitiesLinkCreateWithoutHotelInput[] | HotelAmenitiesLinkUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelAmenitiesLinkCreateOrConnectWithoutHotelInput | HotelAmenitiesLinkCreateOrConnectWithoutHotelInput[]
    createMany?: HotelAmenitiesLinkCreateManyHotelInputEnvelope
    connect?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RoomUpdateManyWithoutHotelNestedInput = {
    create?: XOR<RoomCreateWithoutHotelInput, RoomUncheckedCreateWithoutHotelInput> | RoomCreateWithoutHotelInput[] | RoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutHotelInput | RoomCreateOrConnectWithoutHotelInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutHotelInput | RoomUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: RoomCreateManyHotelInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutHotelInput | RoomUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutHotelInput | RoomUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutHotelNestedInput = {
    create?: XOR<ReviewCreateWithoutHotelInput, ReviewUncheckedCreateWithoutHotelInput> | ReviewCreateWithoutHotelInput[] | ReviewUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutHotelInput | ReviewCreateOrConnectWithoutHotelInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutHotelInput | ReviewUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: ReviewCreateManyHotelInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutHotelInput | ReviewUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutHotelInput | ReviewUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type HotelPolicyUpdateManyWithoutHotelNestedInput = {
    create?: XOR<HotelPolicyCreateWithoutHotelInput, HotelPolicyUncheckedCreateWithoutHotelInput> | HotelPolicyCreateWithoutHotelInput[] | HotelPolicyUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelPolicyCreateOrConnectWithoutHotelInput | HotelPolicyCreateOrConnectWithoutHotelInput[]
    upsert?: HotelPolicyUpsertWithWhereUniqueWithoutHotelInput | HotelPolicyUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: HotelPolicyCreateManyHotelInputEnvelope
    set?: HotelPolicyWhereUniqueInput | HotelPolicyWhereUniqueInput[]
    disconnect?: HotelPolicyWhereUniqueInput | HotelPolicyWhereUniqueInput[]
    delete?: HotelPolicyWhereUniqueInput | HotelPolicyWhereUniqueInput[]
    connect?: HotelPolicyWhereUniqueInput | HotelPolicyWhereUniqueInput[]
    update?: HotelPolicyUpdateWithWhereUniqueWithoutHotelInput | HotelPolicyUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: HotelPolicyUpdateManyWithWhereWithoutHotelInput | HotelPolicyUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: HotelPolicyScalarWhereInput | HotelPolicyScalarWhereInput[]
  }

  export type HotelEventUpdateManyWithoutHotelNestedInput = {
    create?: XOR<HotelEventCreateWithoutHotelInput, HotelEventUncheckedCreateWithoutHotelInput> | HotelEventCreateWithoutHotelInput[] | HotelEventUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelEventCreateOrConnectWithoutHotelInput | HotelEventCreateOrConnectWithoutHotelInput[]
    upsert?: HotelEventUpsertWithWhereUniqueWithoutHotelInput | HotelEventUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: HotelEventCreateManyHotelInputEnvelope
    set?: HotelEventWhereUniqueInput | HotelEventWhereUniqueInput[]
    disconnect?: HotelEventWhereUniqueInput | HotelEventWhereUniqueInput[]
    delete?: HotelEventWhereUniqueInput | HotelEventWhereUniqueInput[]
    connect?: HotelEventWhereUniqueInput | HotelEventWhereUniqueInput[]
    update?: HotelEventUpdateWithWhereUniqueWithoutHotelInput | HotelEventUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: HotelEventUpdateManyWithWhereWithoutHotelInput | HotelEventUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: HotelEventScalarWhereInput | HotelEventScalarWhereInput[]
  }

  export type HotelAmenitiesLinkUpdateManyWithoutHotelNestedInput = {
    create?: XOR<HotelAmenitiesLinkCreateWithoutHotelInput, HotelAmenitiesLinkUncheckedCreateWithoutHotelInput> | HotelAmenitiesLinkCreateWithoutHotelInput[] | HotelAmenitiesLinkUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelAmenitiesLinkCreateOrConnectWithoutHotelInput | HotelAmenitiesLinkCreateOrConnectWithoutHotelInput[]
    upsert?: HotelAmenitiesLinkUpsertWithWhereUniqueWithoutHotelInput | HotelAmenitiesLinkUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: HotelAmenitiesLinkCreateManyHotelInputEnvelope
    set?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
    disconnect?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
    delete?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
    connect?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
    update?: HotelAmenitiesLinkUpdateWithWhereUniqueWithoutHotelInput | HotelAmenitiesLinkUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: HotelAmenitiesLinkUpdateManyWithWhereWithoutHotelInput | HotelAmenitiesLinkUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: HotelAmenitiesLinkScalarWhereInput | HotelAmenitiesLinkScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<RoomCreateWithoutHotelInput, RoomUncheckedCreateWithoutHotelInput> | RoomCreateWithoutHotelInput[] | RoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutHotelInput | RoomCreateOrConnectWithoutHotelInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutHotelInput | RoomUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: RoomCreateManyHotelInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutHotelInput | RoomUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutHotelInput | RoomUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<ReviewCreateWithoutHotelInput, ReviewUncheckedCreateWithoutHotelInput> | ReviewCreateWithoutHotelInput[] | ReviewUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutHotelInput | ReviewCreateOrConnectWithoutHotelInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutHotelInput | ReviewUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: ReviewCreateManyHotelInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutHotelInput | ReviewUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutHotelInput | ReviewUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type HotelPolicyUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<HotelPolicyCreateWithoutHotelInput, HotelPolicyUncheckedCreateWithoutHotelInput> | HotelPolicyCreateWithoutHotelInput[] | HotelPolicyUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelPolicyCreateOrConnectWithoutHotelInput | HotelPolicyCreateOrConnectWithoutHotelInput[]
    upsert?: HotelPolicyUpsertWithWhereUniqueWithoutHotelInput | HotelPolicyUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: HotelPolicyCreateManyHotelInputEnvelope
    set?: HotelPolicyWhereUniqueInput | HotelPolicyWhereUniqueInput[]
    disconnect?: HotelPolicyWhereUniqueInput | HotelPolicyWhereUniqueInput[]
    delete?: HotelPolicyWhereUniqueInput | HotelPolicyWhereUniqueInput[]
    connect?: HotelPolicyWhereUniqueInput | HotelPolicyWhereUniqueInput[]
    update?: HotelPolicyUpdateWithWhereUniqueWithoutHotelInput | HotelPolicyUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: HotelPolicyUpdateManyWithWhereWithoutHotelInput | HotelPolicyUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: HotelPolicyScalarWhereInput | HotelPolicyScalarWhereInput[]
  }

  export type HotelEventUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<HotelEventCreateWithoutHotelInput, HotelEventUncheckedCreateWithoutHotelInput> | HotelEventCreateWithoutHotelInput[] | HotelEventUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelEventCreateOrConnectWithoutHotelInput | HotelEventCreateOrConnectWithoutHotelInput[]
    upsert?: HotelEventUpsertWithWhereUniqueWithoutHotelInput | HotelEventUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: HotelEventCreateManyHotelInputEnvelope
    set?: HotelEventWhereUniqueInput | HotelEventWhereUniqueInput[]
    disconnect?: HotelEventWhereUniqueInput | HotelEventWhereUniqueInput[]
    delete?: HotelEventWhereUniqueInput | HotelEventWhereUniqueInput[]
    connect?: HotelEventWhereUniqueInput | HotelEventWhereUniqueInput[]
    update?: HotelEventUpdateWithWhereUniqueWithoutHotelInput | HotelEventUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: HotelEventUpdateManyWithWhereWithoutHotelInput | HotelEventUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: HotelEventScalarWhereInput | HotelEventScalarWhereInput[]
  }

  export type HotelAmenitiesLinkUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<HotelAmenitiesLinkCreateWithoutHotelInput, HotelAmenitiesLinkUncheckedCreateWithoutHotelInput> | HotelAmenitiesLinkCreateWithoutHotelInput[] | HotelAmenitiesLinkUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelAmenitiesLinkCreateOrConnectWithoutHotelInput | HotelAmenitiesLinkCreateOrConnectWithoutHotelInput[]
    upsert?: HotelAmenitiesLinkUpsertWithWhereUniqueWithoutHotelInput | HotelAmenitiesLinkUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: HotelAmenitiesLinkCreateManyHotelInputEnvelope
    set?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
    disconnect?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
    delete?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
    connect?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
    update?: HotelAmenitiesLinkUpdateWithWhereUniqueWithoutHotelInput | HotelAmenitiesLinkUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: HotelAmenitiesLinkUpdateManyWithWhereWithoutHotelInput | HotelAmenitiesLinkUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: HotelAmenitiesLinkScalarWhereInput | HotelAmenitiesLinkScalarWhereInput[]
  }

  export type RoomCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<RoomCreateWithoutRoomTypeInput, RoomUncheckedCreateWithoutRoomTypeInput> | RoomCreateWithoutRoomTypeInput[] | RoomUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutRoomTypeInput | RoomCreateOrConnectWithoutRoomTypeInput[]
    createMany?: RoomCreateManyRoomTypeInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<RoomCreateWithoutRoomTypeInput, RoomUncheckedCreateWithoutRoomTypeInput> | RoomCreateWithoutRoomTypeInput[] | RoomUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutRoomTypeInput | RoomCreateOrConnectWithoutRoomTypeInput[]
    createMany?: RoomCreateManyRoomTypeInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<RoomCreateWithoutRoomTypeInput, RoomUncheckedCreateWithoutRoomTypeInput> | RoomCreateWithoutRoomTypeInput[] | RoomUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutRoomTypeInput | RoomCreateOrConnectWithoutRoomTypeInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutRoomTypeInput | RoomUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: RoomCreateManyRoomTypeInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutRoomTypeInput | RoomUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutRoomTypeInput | RoomUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<RoomCreateWithoutRoomTypeInput, RoomUncheckedCreateWithoutRoomTypeInput> | RoomCreateWithoutRoomTypeInput[] | RoomUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutRoomTypeInput | RoomCreateOrConnectWithoutRoomTypeInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutRoomTypeInput | RoomUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: RoomCreateManyRoomTypeInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutRoomTypeInput | RoomUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutRoomTypeInput | RoomUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type HotelCreateNestedOneWithoutRoomsInput = {
    create?: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutRoomsInput
    connect?: HotelWhereUniqueInput
  }

  export type RoomTypeCreateNestedOneWithoutRoomsInput = {
    create?: XOR<RoomTypeCreateWithoutRoomsInput, RoomTypeUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutRoomsInput
    connect?: RoomTypeWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutRoomInput = {
    create?: XOR<BookingCreateWithoutRoomInput, BookingUncheckedCreateWithoutRoomInput> | BookingCreateWithoutRoomInput[] | BookingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRoomInput | BookingCreateOrConnectWithoutRoomInput[]
    createMany?: BookingCreateManyRoomInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type RoomAmenitiesLinkCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomAmenitiesLinkCreateWithoutRoomInput, RoomAmenitiesLinkUncheckedCreateWithoutRoomInput> | RoomAmenitiesLinkCreateWithoutRoomInput[] | RoomAmenitiesLinkUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomAmenitiesLinkCreateOrConnectWithoutRoomInput | RoomAmenitiesLinkCreateOrConnectWithoutRoomInput[]
    createMany?: RoomAmenitiesLinkCreateManyRoomInputEnvelope
    connect?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<BookingCreateWithoutRoomInput, BookingUncheckedCreateWithoutRoomInput> | BookingCreateWithoutRoomInput[] | BookingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRoomInput | BookingCreateOrConnectWithoutRoomInput[]
    createMany?: BookingCreateManyRoomInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type RoomAmenitiesLinkUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomAmenitiesLinkCreateWithoutRoomInput, RoomAmenitiesLinkUncheckedCreateWithoutRoomInput> | RoomAmenitiesLinkCreateWithoutRoomInput[] | RoomAmenitiesLinkUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomAmenitiesLinkCreateOrConnectWithoutRoomInput | RoomAmenitiesLinkCreateOrConnectWithoutRoomInput[]
    createMany?: RoomAmenitiesLinkCreateManyRoomInputEnvelope
    connect?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type HotelUpdateOneWithoutRoomsNestedInput = {
    create?: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutRoomsInput
    upsert?: HotelUpsertWithoutRoomsInput
    disconnect?: HotelWhereInput | boolean
    delete?: HotelWhereInput | boolean
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutRoomsInput, HotelUpdateWithoutRoomsInput>, HotelUncheckedUpdateWithoutRoomsInput>
  }

  export type RoomTypeUpdateOneWithoutRoomsNestedInput = {
    create?: XOR<RoomTypeCreateWithoutRoomsInput, RoomTypeUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutRoomsInput
    upsert?: RoomTypeUpsertWithoutRoomsInput
    disconnect?: RoomTypeWhereInput | boolean
    delete?: RoomTypeWhereInput | boolean
    connect?: RoomTypeWhereUniqueInput
    update?: XOR<XOR<RoomTypeUpdateToOneWithWhereWithoutRoomsInput, RoomTypeUpdateWithoutRoomsInput>, RoomTypeUncheckedUpdateWithoutRoomsInput>
  }

  export type BookingUpdateManyWithoutRoomNestedInput = {
    create?: XOR<BookingCreateWithoutRoomInput, BookingUncheckedCreateWithoutRoomInput> | BookingCreateWithoutRoomInput[] | BookingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRoomInput | BookingCreateOrConnectWithoutRoomInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutRoomInput | BookingUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: BookingCreateManyRoomInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutRoomInput | BookingUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutRoomInput | BookingUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type RoomAmenitiesLinkUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomAmenitiesLinkCreateWithoutRoomInput, RoomAmenitiesLinkUncheckedCreateWithoutRoomInput> | RoomAmenitiesLinkCreateWithoutRoomInput[] | RoomAmenitiesLinkUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomAmenitiesLinkCreateOrConnectWithoutRoomInput | RoomAmenitiesLinkCreateOrConnectWithoutRoomInput[]
    upsert?: RoomAmenitiesLinkUpsertWithWhereUniqueWithoutRoomInput | RoomAmenitiesLinkUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomAmenitiesLinkCreateManyRoomInputEnvelope
    set?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
    disconnect?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
    delete?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
    connect?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
    update?: RoomAmenitiesLinkUpdateWithWhereUniqueWithoutRoomInput | RoomAmenitiesLinkUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomAmenitiesLinkUpdateManyWithWhereWithoutRoomInput | RoomAmenitiesLinkUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomAmenitiesLinkScalarWhereInput | RoomAmenitiesLinkScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BookingUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<BookingCreateWithoutRoomInput, BookingUncheckedCreateWithoutRoomInput> | BookingCreateWithoutRoomInput[] | BookingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRoomInput | BookingCreateOrConnectWithoutRoomInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutRoomInput | BookingUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: BookingCreateManyRoomInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutRoomInput | BookingUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutRoomInput | BookingUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type RoomAmenitiesLinkUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomAmenitiesLinkCreateWithoutRoomInput, RoomAmenitiesLinkUncheckedCreateWithoutRoomInput> | RoomAmenitiesLinkCreateWithoutRoomInput[] | RoomAmenitiesLinkUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomAmenitiesLinkCreateOrConnectWithoutRoomInput | RoomAmenitiesLinkCreateOrConnectWithoutRoomInput[]
    upsert?: RoomAmenitiesLinkUpsertWithWhereUniqueWithoutRoomInput | RoomAmenitiesLinkUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomAmenitiesLinkCreateManyRoomInputEnvelope
    set?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
    disconnect?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
    delete?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
    connect?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
    update?: RoomAmenitiesLinkUpdateWithWhereUniqueWithoutRoomInput | RoomAmenitiesLinkUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomAmenitiesLinkUpdateManyWithWhereWithoutRoomInput | RoomAmenitiesLinkUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomAmenitiesLinkScalarWhereInput | RoomAmenitiesLinkScalarWhereInput[]
  }

  export type BookingCreateNestedManyWithoutStatusInput = {
    create?: XOR<BookingCreateWithoutStatusInput, BookingUncheckedCreateWithoutStatusInput> | BookingCreateWithoutStatusInput[] | BookingUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutStatusInput | BookingCreateOrConnectWithoutStatusInput[]
    createMany?: BookingCreateManyStatusInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<BookingCreateWithoutStatusInput, BookingUncheckedCreateWithoutStatusInput> | BookingCreateWithoutStatusInput[] | BookingUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutStatusInput | BookingCreateOrConnectWithoutStatusInput[]
    createMany?: BookingCreateManyStatusInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUpdateManyWithoutStatusNestedInput = {
    create?: XOR<BookingCreateWithoutStatusInput, BookingUncheckedCreateWithoutStatusInput> | BookingCreateWithoutStatusInput[] | BookingUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutStatusInput | BookingCreateOrConnectWithoutStatusInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutStatusInput | BookingUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: BookingCreateManyStatusInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutStatusInput | BookingUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutStatusInput | BookingUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<BookingCreateWithoutStatusInput, BookingUncheckedCreateWithoutStatusInput> | BookingCreateWithoutStatusInput[] | BookingUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutStatusInput | BookingCreateOrConnectWithoutStatusInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutStatusInput | BookingUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: BookingCreateManyStatusInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutStatusInput | BookingUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutStatusInput | BookingUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutBookingsInput = {
    create?: XOR<CustomerCreateWithoutBookingsInput, CustomerUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutBookingsInput
    connect?: CustomerWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutBookingsInput = {
    create?: XOR<RoomCreateWithoutBookingsInput, RoomUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutBookingsInput
    connect?: RoomWhereUniqueInput
  }

  export type BookingStatusCreateNestedOneWithoutBookingsInput = {
    create?: XOR<BookingStatusCreateWithoutBookingsInput, BookingStatusUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: BookingStatusCreateOrConnectWithoutBookingsInput
    connect?: BookingStatusWhereUniqueInput
  }

  export type BookingServiceCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingServiceCreateWithoutBookingInput, BookingServiceUncheckedCreateWithoutBookingInput> | BookingServiceCreateWithoutBookingInput[] | BookingServiceUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutBookingInput | BookingServiceCreateOrConnectWithoutBookingInput[]
    createMany?: BookingServiceCreateManyBookingInputEnvelope
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PromotionAppliedCreateNestedManyWithoutBookingInput = {
    create?: XOR<PromotionAppliedCreateWithoutBookingInput, PromotionAppliedUncheckedCreateWithoutBookingInput> | PromotionAppliedCreateWithoutBookingInput[] | PromotionAppliedUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PromotionAppliedCreateOrConnectWithoutBookingInput | PromotionAppliedCreateOrConnectWithoutBookingInput[]
    createMany?: PromotionAppliedCreateManyBookingInputEnvelope
    connect?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
  }

  export type BookingServiceUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingServiceCreateWithoutBookingInput, BookingServiceUncheckedCreateWithoutBookingInput> | BookingServiceCreateWithoutBookingInput[] | BookingServiceUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutBookingInput | BookingServiceCreateOrConnectWithoutBookingInput[]
    createMany?: BookingServiceCreateManyBookingInputEnvelope
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PromotionAppliedUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<PromotionAppliedCreateWithoutBookingInput, PromotionAppliedUncheckedCreateWithoutBookingInput> | PromotionAppliedCreateWithoutBookingInput[] | PromotionAppliedUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PromotionAppliedCreateOrConnectWithoutBookingInput | PromotionAppliedCreateOrConnectWithoutBookingInput[]
    createMany?: PromotionAppliedCreateManyBookingInputEnvelope
    connect?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CustomerUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<CustomerCreateWithoutBookingsInput, CustomerUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutBookingsInput
    upsert?: CustomerUpsertWithoutBookingsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutBookingsInput, CustomerUpdateWithoutBookingsInput>, CustomerUncheckedUpdateWithoutBookingsInput>
  }

  export type RoomUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<RoomCreateWithoutBookingsInput, RoomUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutBookingsInput
    upsert?: RoomUpsertWithoutBookingsInput
    disconnect?: RoomWhereInput | boolean
    delete?: RoomWhereInput | boolean
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutBookingsInput, RoomUpdateWithoutBookingsInput>, RoomUncheckedUpdateWithoutBookingsInput>
  }

  export type BookingStatusUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<BookingStatusCreateWithoutBookingsInput, BookingStatusUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: BookingStatusCreateOrConnectWithoutBookingsInput
    upsert?: BookingStatusUpsertWithoutBookingsInput
    disconnect?: BookingStatusWhereInput | boolean
    delete?: BookingStatusWhereInput | boolean
    connect?: BookingStatusWhereUniqueInput
    update?: XOR<XOR<BookingStatusUpdateToOneWithWhereWithoutBookingsInput, BookingStatusUpdateWithoutBookingsInput>, BookingStatusUncheckedUpdateWithoutBookingsInput>
  }

  export type BookingServiceUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingServiceCreateWithoutBookingInput, BookingServiceUncheckedCreateWithoutBookingInput> | BookingServiceCreateWithoutBookingInput[] | BookingServiceUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutBookingInput | BookingServiceCreateOrConnectWithoutBookingInput[]
    upsert?: BookingServiceUpsertWithWhereUniqueWithoutBookingInput | BookingServiceUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingServiceCreateManyBookingInputEnvelope
    set?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    disconnect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    delete?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    update?: BookingServiceUpdateWithWhereUniqueWithoutBookingInput | BookingServiceUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingServiceUpdateManyWithWhereWithoutBookingInput | BookingServiceUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingServiceScalarWhereInput | BookingServiceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PromotionAppliedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PromotionAppliedCreateWithoutBookingInput, PromotionAppliedUncheckedCreateWithoutBookingInput> | PromotionAppliedCreateWithoutBookingInput[] | PromotionAppliedUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PromotionAppliedCreateOrConnectWithoutBookingInput | PromotionAppliedCreateOrConnectWithoutBookingInput[]
    upsert?: PromotionAppliedUpsertWithWhereUniqueWithoutBookingInput | PromotionAppliedUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PromotionAppliedCreateManyBookingInputEnvelope
    set?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
    disconnect?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
    delete?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
    connect?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
    update?: PromotionAppliedUpdateWithWhereUniqueWithoutBookingInput | PromotionAppliedUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PromotionAppliedUpdateManyWithWhereWithoutBookingInput | PromotionAppliedUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PromotionAppliedScalarWhereInput | PromotionAppliedScalarWhereInput[]
  }

  export type BookingServiceUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingServiceCreateWithoutBookingInput, BookingServiceUncheckedCreateWithoutBookingInput> | BookingServiceCreateWithoutBookingInput[] | BookingServiceUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutBookingInput | BookingServiceCreateOrConnectWithoutBookingInput[]
    upsert?: BookingServiceUpsertWithWhereUniqueWithoutBookingInput | BookingServiceUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingServiceCreateManyBookingInputEnvelope
    set?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    disconnect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    delete?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    update?: BookingServiceUpdateWithWhereUniqueWithoutBookingInput | BookingServiceUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingServiceUpdateManyWithWhereWithoutBookingInput | BookingServiceUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingServiceScalarWhereInput | BookingServiceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PromotionAppliedUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PromotionAppliedCreateWithoutBookingInput, PromotionAppliedUncheckedCreateWithoutBookingInput> | PromotionAppliedCreateWithoutBookingInput[] | PromotionAppliedUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PromotionAppliedCreateOrConnectWithoutBookingInput | PromotionAppliedCreateOrConnectWithoutBookingInput[]
    upsert?: PromotionAppliedUpsertWithWhereUniqueWithoutBookingInput | PromotionAppliedUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PromotionAppliedCreateManyBookingInputEnvelope
    set?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
    disconnect?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
    delete?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
    connect?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
    update?: PromotionAppliedUpdateWithWhereUniqueWithoutBookingInput | PromotionAppliedUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PromotionAppliedUpdateManyWithWhereWithoutBookingInput | PromotionAppliedUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PromotionAppliedScalarWhereInput | PromotionAppliedScalarWhereInput[]
  }

  export type BookingServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingServiceCreateWithoutServiceInput, BookingServiceUncheckedCreateWithoutServiceInput> | BookingServiceCreateWithoutServiceInput[] | BookingServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutServiceInput | BookingServiceCreateOrConnectWithoutServiceInput[]
    createMany?: BookingServiceCreateManyServiceInputEnvelope
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
  }

  export type BookingServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingServiceCreateWithoutServiceInput, BookingServiceUncheckedCreateWithoutServiceInput> | BookingServiceCreateWithoutServiceInput[] | BookingServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutServiceInput | BookingServiceCreateOrConnectWithoutServiceInput[]
    createMany?: BookingServiceCreateManyServiceInputEnvelope
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
  }

  export type BookingServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingServiceCreateWithoutServiceInput, BookingServiceUncheckedCreateWithoutServiceInput> | BookingServiceCreateWithoutServiceInput[] | BookingServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutServiceInput | BookingServiceCreateOrConnectWithoutServiceInput[]
    upsert?: BookingServiceUpsertWithWhereUniqueWithoutServiceInput | BookingServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingServiceCreateManyServiceInputEnvelope
    set?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    disconnect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    delete?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    update?: BookingServiceUpdateWithWhereUniqueWithoutServiceInput | BookingServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingServiceUpdateManyWithWhereWithoutServiceInput | BookingServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingServiceScalarWhereInput | BookingServiceScalarWhereInput[]
  }

  export type BookingServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingServiceCreateWithoutServiceInput, BookingServiceUncheckedCreateWithoutServiceInput> | BookingServiceCreateWithoutServiceInput[] | BookingServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutServiceInput | BookingServiceCreateOrConnectWithoutServiceInput[]
    upsert?: BookingServiceUpsertWithWhereUniqueWithoutServiceInput | BookingServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingServiceCreateManyServiceInputEnvelope
    set?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    disconnect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    delete?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    update?: BookingServiceUpdateWithWhereUniqueWithoutServiceInput | BookingServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingServiceUpdateManyWithWhereWithoutServiceInput | BookingServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingServiceScalarWhereInput | BookingServiceScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutServicesInput = {
    create?: XOR<BookingCreateWithoutServicesInput, BookingUncheckedCreateWithoutServicesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutServicesInput
    connect?: BookingWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    connect?: ServiceWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<BookingCreateWithoutServicesInput, BookingUncheckedCreateWithoutServicesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutServicesInput
    upsert?: BookingUpsertWithoutServicesInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutServicesInput, BookingUpdateWithoutServicesInput>, BookingUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    upsert?: ServiceUpsertWithoutBookingsInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutBookingsInput, ServiceUpdateWithoutBookingsInput>, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type EmployeeCreateNestedManyWithoutRoleInput = {
    create?: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput> | EmployeeCreateWithoutRoleInput[] | EmployeeUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutRoleInput | EmployeeCreateOrConnectWithoutRoleInput[]
    createMany?: EmployeeCreateManyRoleInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput> | EmployeeCreateWithoutRoleInput[] | EmployeeUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutRoleInput | EmployeeCreateOrConnectWithoutRoleInput[]
    createMany?: EmployeeCreateManyRoleInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUpdateManyWithoutRoleNestedInput = {
    create?: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput> | EmployeeCreateWithoutRoleInput[] | EmployeeUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutRoleInput | EmployeeCreateOrConnectWithoutRoleInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutRoleInput | EmployeeUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: EmployeeCreateManyRoleInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutRoleInput | EmployeeUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutRoleInput | EmployeeUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput> | EmployeeCreateWithoutRoleInput[] | EmployeeUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutRoleInput | EmployeeCreateOrConnectWithoutRoleInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutRoleInput | EmployeeUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: EmployeeCreateManyRoleInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutRoleInput | EmployeeUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutRoleInput | EmployeeUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDepartmentInput | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDepartmentInput | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDepartmentInput | EmployeeUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDepartmentInput | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDepartmentInput | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDepartmentInput | EmployeeUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeRoleCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<EmployeeRoleCreateWithoutEmployeesInput, EmployeeRoleUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: EmployeeRoleCreateOrConnectWithoutEmployeesInput
    connect?: EmployeeRoleWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEmployeesInput
    connect?: DepartmentWhereUniqueInput
  }

  export type EmployeeRoleUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<EmployeeRoleCreateWithoutEmployeesInput, EmployeeRoleUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: EmployeeRoleCreateOrConnectWithoutEmployeesInput
    upsert?: EmployeeRoleUpsertWithoutEmployeesInput
    disconnect?: EmployeeRoleWhereInput | boolean
    delete?: EmployeeRoleWhereInput | boolean
    connect?: EmployeeRoleWhereUniqueInput
    update?: XOR<XOR<EmployeeRoleUpdateToOneWithWhereWithoutEmployeesInput, EmployeeRoleUpdateWithoutEmployeesInput>, EmployeeRoleUncheckedUpdateWithoutEmployeesInput>
  }

  export type DepartmentUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEmployeesInput
    upsert?: DepartmentUpsertWithoutEmployeesInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutEmployeesInput, DepartmentUpdateWithoutEmployeesInput>, DepartmentUncheckedUpdateWithoutEmployeesInput>
  }

  export type BookingCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    connect?: BookingWhereUniqueInput
  }

  export type BookingUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    upsert?: BookingUpsertWithoutPaymentsInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPaymentsInput, BookingUpdateWithoutPaymentsInput>, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type CustomerCreateNestedOneWithoutReviewsInput = {
    create?: XOR<CustomerCreateWithoutReviewsInput, CustomerUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutReviewsInput
    connect?: CustomerWhereUniqueInput
  }

  export type HotelCreateNestedOneWithoutReviewsInput = {
    create?: XOR<HotelCreateWithoutReviewsInput, HotelUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutReviewsInput
    connect?: HotelWhereUniqueInput
  }

  export type CustomerUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<CustomerCreateWithoutReviewsInput, CustomerUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutReviewsInput
    upsert?: CustomerUpsertWithoutReviewsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutReviewsInput, CustomerUpdateWithoutReviewsInput>, CustomerUncheckedUpdateWithoutReviewsInput>
  }

  export type HotelUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<HotelCreateWithoutReviewsInput, HotelUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutReviewsInput
    upsert?: HotelUpsertWithoutReviewsInput
    disconnect?: HotelWhereInput | boolean
    delete?: HotelWhereInput | boolean
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutReviewsInput, HotelUpdateWithoutReviewsInput>, HotelUncheckedUpdateWithoutReviewsInput>
  }

  export type PromotionAppliedCreateNestedManyWithoutPromotionInput = {
    create?: XOR<PromotionAppliedCreateWithoutPromotionInput, PromotionAppliedUncheckedCreateWithoutPromotionInput> | PromotionAppliedCreateWithoutPromotionInput[] | PromotionAppliedUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionAppliedCreateOrConnectWithoutPromotionInput | PromotionAppliedCreateOrConnectWithoutPromotionInput[]
    createMany?: PromotionAppliedCreateManyPromotionInputEnvelope
    connect?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
  }

  export type PromotionAppliedUncheckedCreateNestedManyWithoutPromotionInput = {
    create?: XOR<PromotionAppliedCreateWithoutPromotionInput, PromotionAppliedUncheckedCreateWithoutPromotionInput> | PromotionAppliedCreateWithoutPromotionInput[] | PromotionAppliedUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionAppliedCreateOrConnectWithoutPromotionInput | PromotionAppliedCreateOrConnectWithoutPromotionInput[]
    createMany?: PromotionAppliedCreateManyPromotionInputEnvelope
    connect?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
  }

  export type PromotionAppliedUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<PromotionAppliedCreateWithoutPromotionInput, PromotionAppliedUncheckedCreateWithoutPromotionInput> | PromotionAppliedCreateWithoutPromotionInput[] | PromotionAppliedUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionAppliedCreateOrConnectWithoutPromotionInput | PromotionAppliedCreateOrConnectWithoutPromotionInput[]
    upsert?: PromotionAppliedUpsertWithWhereUniqueWithoutPromotionInput | PromotionAppliedUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: PromotionAppliedCreateManyPromotionInputEnvelope
    set?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
    disconnect?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
    delete?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
    connect?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
    update?: PromotionAppliedUpdateWithWhereUniqueWithoutPromotionInput | PromotionAppliedUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: PromotionAppliedUpdateManyWithWhereWithoutPromotionInput | PromotionAppliedUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: PromotionAppliedScalarWhereInput | PromotionAppliedScalarWhereInput[]
  }

  export type PromotionAppliedUncheckedUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<PromotionAppliedCreateWithoutPromotionInput, PromotionAppliedUncheckedCreateWithoutPromotionInput> | PromotionAppliedCreateWithoutPromotionInput[] | PromotionAppliedUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionAppliedCreateOrConnectWithoutPromotionInput | PromotionAppliedCreateOrConnectWithoutPromotionInput[]
    upsert?: PromotionAppliedUpsertWithWhereUniqueWithoutPromotionInput | PromotionAppliedUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: PromotionAppliedCreateManyPromotionInputEnvelope
    set?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
    disconnect?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
    delete?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
    connect?: PromotionAppliedWhereUniqueInput | PromotionAppliedWhereUniqueInput[]
    update?: PromotionAppliedUpdateWithWhereUniqueWithoutPromotionInput | PromotionAppliedUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: PromotionAppliedUpdateManyWithWhereWithoutPromotionInput | PromotionAppliedUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: PromotionAppliedScalarWhereInput | PromotionAppliedScalarWhereInput[]
  }

  export type RoomAmenitiesLinkCreateNestedManyWithoutAmenityInput = {
    create?: XOR<RoomAmenitiesLinkCreateWithoutAmenityInput, RoomAmenitiesLinkUncheckedCreateWithoutAmenityInput> | RoomAmenitiesLinkCreateWithoutAmenityInput[] | RoomAmenitiesLinkUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: RoomAmenitiesLinkCreateOrConnectWithoutAmenityInput | RoomAmenitiesLinkCreateOrConnectWithoutAmenityInput[]
    createMany?: RoomAmenitiesLinkCreateManyAmenityInputEnvelope
    connect?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
  }

  export type RoomAmenitiesLinkUncheckedCreateNestedManyWithoutAmenityInput = {
    create?: XOR<RoomAmenitiesLinkCreateWithoutAmenityInput, RoomAmenitiesLinkUncheckedCreateWithoutAmenityInput> | RoomAmenitiesLinkCreateWithoutAmenityInput[] | RoomAmenitiesLinkUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: RoomAmenitiesLinkCreateOrConnectWithoutAmenityInput | RoomAmenitiesLinkCreateOrConnectWithoutAmenityInput[]
    createMany?: RoomAmenitiesLinkCreateManyAmenityInputEnvelope
    connect?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
  }

  export type RoomAmenitiesLinkUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<RoomAmenitiesLinkCreateWithoutAmenityInput, RoomAmenitiesLinkUncheckedCreateWithoutAmenityInput> | RoomAmenitiesLinkCreateWithoutAmenityInput[] | RoomAmenitiesLinkUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: RoomAmenitiesLinkCreateOrConnectWithoutAmenityInput | RoomAmenitiesLinkCreateOrConnectWithoutAmenityInput[]
    upsert?: RoomAmenitiesLinkUpsertWithWhereUniqueWithoutAmenityInput | RoomAmenitiesLinkUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: RoomAmenitiesLinkCreateManyAmenityInputEnvelope
    set?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
    disconnect?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
    delete?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
    connect?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
    update?: RoomAmenitiesLinkUpdateWithWhereUniqueWithoutAmenityInput | RoomAmenitiesLinkUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: RoomAmenitiesLinkUpdateManyWithWhereWithoutAmenityInput | RoomAmenitiesLinkUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: RoomAmenitiesLinkScalarWhereInput | RoomAmenitiesLinkScalarWhereInput[]
  }

  export type RoomAmenitiesLinkUncheckedUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<RoomAmenitiesLinkCreateWithoutAmenityInput, RoomAmenitiesLinkUncheckedCreateWithoutAmenityInput> | RoomAmenitiesLinkCreateWithoutAmenityInput[] | RoomAmenitiesLinkUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: RoomAmenitiesLinkCreateOrConnectWithoutAmenityInput | RoomAmenitiesLinkCreateOrConnectWithoutAmenityInput[]
    upsert?: RoomAmenitiesLinkUpsertWithWhereUniqueWithoutAmenityInput | RoomAmenitiesLinkUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: RoomAmenitiesLinkCreateManyAmenityInputEnvelope
    set?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
    disconnect?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
    delete?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
    connect?: RoomAmenitiesLinkWhereUniqueInput | RoomAmenitiesLinkWhereUniqueInput[]
    update?: RoomAmenitiesLinkUpdateWithWhereUniqueWithoutAmenityInput | RoomAmenitiesLinkUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: RoomAmenitiesLinkUpdateManyWithWhereWithoutAmenityInput | RoomAmenitiesLinkUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: RoomAmenitiesLinkScalarWhereInput | RoomAmenitiesLinkScalarWhereInput[]
  }

  export type HotelAmenitiesLinkCreateNestedManyWithoutAmenityInput = {
    create?: XOR<HotelAmenitiesLinkCreateWithoutAmenityInput, HotelAmenitiesLinkUncheckedCreateWithoutAmenityInput> | HotelAmenitiesLinkCreateWithoutAmenityInput[] | HotelAmenitiesLinkUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: HotelAmenitiesLinkCreateOrConnectWithoutAmenityInput | HotelAmenitiesLinkCreateOrConnectWithoutAmenityInput[]
    createMany?: HotelAmenitiesLinkCreateManyAmenityInputEnvelope
    connect?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
  }

  export type HotelAmenitiesLinkUncheckedCreateNestedManyWithoutAmenityInput = {
    create?: XOR<HotelAmenitiesLinkCreateWithoutAmenityInput, HotelAmenitiesLinkUncheckedCreateWithoutAmenityInput> | HotelAmenitiesLinkCreateWithoutAmenityInput[] | HotelAmenitiesLinkUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: HotelAmenitiesLinkCreateOrConnectWithoutAmenityInput | HotelAmenitiesLinkCreateOrConnectWithoutAmenityInput[]
    createMany?: HotelAmenitiesLinkCreateManyAmenityInputEnvelope
    connect?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
  }

  export type HotelAmenitiesLinkUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<HotelAmenitiesLinkCreateWithoutAmenityInput, HotelAmenitiesLinkUncheckedCreateWithoutAmenityInput> | HotelAmenitiesLinkCreateWithoutAmenityInput[] | HotelAmenitiesLinkUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: HotelAmenitiesLinkCreateOrConnectWithoutAmenityInput | HotelAmenitiesLinkCreateOrConnectWithoutAmenityInput[]
    upsert?: HotelAmenitiesLinkUpsertWithWhereUniqueWithoutAmenityInput | HotelAmenitiesLinkUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: HotelAmenitiesLinkCreateManyAmenityInputEnvelope
    set?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
    disconnect?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
    delete?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
    connect?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
    update?: HotelAmenitiesLinkUpdateWithWhereUniqueWithoutAmenityInput | HotelAmenitiesLinkUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: HotelAmenitiesLinkUpdateManyWithWhereWithoutAmenityInput | HotelAmenitiesLinkUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: HotelAmenitiesLinkScalarWhereInput | HotelAmenitiesLinkScalarWhereInput[]
  }

  export type HotelAmenitiesLinkUncheckedUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<HotelAmenitiesLinkCreateWithoutAmenityInput, HotelAmenitiesLinkUncheckedCreateWithoutAmenityInput> | HotelAmenitiesLinkCreateWithoutAmenityInput[] | HotelAmenitiesLinkUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: HotelAmenitiesLinkCreateOrConnectWithoutAmenityInput | HotelAmenitiesLinkCreateOrConnectWithoutAmenityInput[]
    upsert?: HotelAmenitiesLinkUpsertWithWhereUniqueWithoutAmenityInput | HotelAmenitiesLinkUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: HotelAmenitiesLinkCreateManyAmenityInputEnvelope
    set?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
    disconnect?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
    delete?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
    connect?: HotelAmenitiesLinkWhereUniqueInput | HotelAmenitiesLinkWhereUniqueInput[]
    update?: HotelAmenitiesLinkUpdateWithWhereUniqueWithoutAmenityInput | HotelAmenitiesLinkUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: HotelAmenitiesLinkUpdateManyWithWhereWithoutAmenityInput | HotelAmenitiesLinkUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: HotelAmenitiesLinkScalarWhereInput | HotelAmenitiesLinkScalarWhereInput[]
  }

  export type HotelCreateNestedOneWithoutPoliciesInput = {
    create?: XOR<HotelCreateWithoutPoliciesInput, HotelUncheckedCreateWithoutPoliciesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutPoliciesInput
    connect?: HotelWhereUniqueInput
  }

  export type HotelUpdateOneWithoutPoliciesNestedInput = {
    create?: XOR<HotelCreateWithoutPoliciesInput, HotelUncheckedCreateWithoutPoliciesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutPoliciesInput
    upsert?: HotelUpsertWithoutPoliciesInput
    disconnect?: HotelWhereInput | boolean
    delete?: HotelWhereInput | boolean
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutPoliciesInput, HotelUpdateWithoutPoliciesInput>, HotelUncheckedUpdateWithoutPoliciesInput>
  }

  export type PromotionCreateNestedOneWithoutBookingsInput = {
    create?: XOR<PromotionCreateWithoutBookingsInput, PromotionUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutBookingsInput
    connect?: PromotionWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutPromotionsInput = {
    create?: XOR<BookingCreateWithoutPromotionsInput, BookingUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPromotionsInput
    connect?: BookingWhereUniqueInput
  }

  export type PromotionUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<PromotionCreateWithoutBookingsInput, PromotionUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutBookingsInput
    upsert?: PromotionUpsertWithoutBookingsInput
    connect?: PromotionWhereUniqueInput
    update?: XOR<XOR<PromotionUpdateToOneWithWhereWithoutBookingsInput, PromotionUpdateWithoutBookingsInput>, PromotionUncheckedUpdateWithoutBookingsInput>
  }

  export type BookingUpdateOneWithoutPromotionsNestedInput = {
    create?: XOR<BookingCreateWithoutPromotionsInput, BookingUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPromotionsInput
    upsert?: BookingUpsertWithoutPromotionsInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPromotionsInput, BookingUpdateWithoutPromotionsInput>, BookingUncheckedUpdateWithoutPromotionsInput>
  }

  export type CustomerCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<CustomerCreateWithoutActivityLogsInput, CustomerUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutActivityLogsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneWithoutActivityLogsNestedInput = {
    create?: XOR<CustomerCreateWithoutActivityLogsInput, CustomerUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutActivityLogsInput
    upsert?: CustomerUpsertWithoutActivityLogsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutActivityLogsInput, CustomerUpdateWithoutActivityLogsInput>, CustomerUncheckedUpdateWithoutActivityLogsInput>
  }

  export type HotelCreateNestedOneWithoutEventsInput = {
    create?: XOR<HotelCreateWithoutEventsInput, HotelUncheckedCreateWithoutEventsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutEventsInput
    connect?: HotelWhereUniqueInput
  }

  export type HotelUpdateOneWithoutEventsNestedInput = {
    create?: XOR<HotelCreateWithoutEventsInput, HotelUncheckedCreateWithoutEventsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutEventsInput
    upsert?: HotelUpsertWithoutEventsInput
    disconnect?: HotelWhereInput | boolean
    delete?: HotelWhereInput | boolean
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutEventsInput, HotelUpdateWithoutEventsInput>, HotelUncheckedUpdateWithoutEventsInput>
  }

  export type CustomerCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<CustomerCreateWithoutNotificationsInput, CustomerUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutNotificationsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<CustomerCreateWithoutNotificationsInput, CustomerUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutNotificationsInput
    upsert?: CustomerUpsertWithoutNotificationsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutNotificationsInput, CustomerUpdateWithoutNotificationsInput>, CustomerUncheckedUpdateWithoutNotificationsInput>
  }

  export type RoomCreateNestedOneWithoutAmenitiesInput = {
    create?: XOR<RoomCreateWithoutAmenitiesInput, RoomUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutAmenitiesInput
    connect?: RoomWhereUniqueInput
  }

  export type RoomAmenityCreateNestedOneWithoutRoomsInput = {
    create?: XOR<RoomAmenityCreateWithoutRoomsInput, RoomAmenityUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: RoomAmenityCreateOrConnectWithoutRoomsInput
    connect?: RoomAmenityWhereUniqueInput
  }

  export type RoomUpdateOneRequiredWithoutAmenitiesNestedInput = {
    create?: XOR<RoomCreateWithoutAmenitiesInput, RoomUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutAmenitiesInput
    upsert?: RoomUpsertWithoutAmenitiesInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutAmenitiesInput, RoomUpdateWithoutAmenitiesInput>, RoomUncheckedUpdateWithoutAmenitiesInput>
  }

  export type RoomAmenityUpdateOneWithoutRoomsNestedInput = {
    create?: XOR<RoomAmenityCreateWithoutRoomsInput, RoomAmenityUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: RoomAmenityCreateOrConnectWithoutRoomsInput
    upsert?: RoomAmenityUpsertWithoutRoomsInput
    disconnect?: RoomAmenityWhereInput | boolean
    delete?: RoomAmenityWhereInput | boolean
    connect?: RoomAmenityWhereUniqueInput
    update?: XOR<XOR<RoomAmenityUpdateToOneWithWhereWithoutRoomsInput, RoomAmenityUpdateWithoutRoomsInput>, RoomAmenityUncheckedUpdateWithoutRoomsInput>
  }

  export type HotelCreateNestedOneWithoutAmenitiesInput = {
    create?: XOR<HotelCreateWithoutAmenitiesInput, HotelUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutAmenitiesInput
    connect?: HotelWhereUniqueInput
  }

  export type HotelAmenityCreateNestedOneWithoutHotelsInput = {
    create?: XOR<HotelAmenityCreateWithoutHotelsInput, HotelAmenityUncheckedCreateWithoutHotelsInput>
    connectOrCreate?: HotelAmenityCreateOrConnectWithoutHotelsInput
    connect?: HotelAmenityWhereUniqueInput
  }

  export type HotelUpdateOneRequiredWithoutAmenitiesNestedInput = {
    create?: XOR<HotelCreateWithoutAmenitiesInput, HotelUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutAmenitiesInput
    upsert?: HotelUpsertWithoutAmenitiesInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutAmenitiesInput, HotelUpdateWithoutAmenitiesInput>, HotelUncheckedUpdateWithoutAmenitiesInput>
  }

  export type HotelAmenityUpdateOneWithoutHotelsNestedInput = {
    create?: XOR<HotelAmenityCreateWithoutHotelsInput, HotelAmenityUncheckedCreateWithoutHotelsInput>
    connectOrCreate?: HotelAmenityCreateOrConnectWithoutHotelsInput
    upsert?: HotelAmenityUpsertWithoutHotelsInput
    disconnect?: HotelAmenityWhereInput | boolean
    delete?: HotelAmenityWhereInput | boolean
    connect?: HotelAmenityWhereUniqueInput
    update?: XOR<XOR<HotelAmenityUpdateToOneWithWhereWithoutHotelsInput, HotelAmenityUpdateWithoutHotelsInput>, HotelAmenityUncheckedUpdateWithoutHotelsInput>
  }

  export type CustomerCreateNestedOneWithoutUserInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput
    connect?: CustomerWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CustomerUpdateOneWithoutUserNestedInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput
    upsert?: CustomerUpsertWithoutUserInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutUserInput, CustomerUpdateWithoutUserInput>, CustomerUncheckedUpdateWithoutUserInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BookingCreateWithoutCustomerInput = {
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    room?: RoomCreateNestedOneWithoutBookingsInput
    status?: BookingStatusCreateNestedOneWithoutBookingsInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    promotions?: PromotionAppliedCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutCustomerInput = {
    id?: number
    roomId?: number | null
    statusId?: number | null
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    promotions?: PromotionAppliedUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutCustomerInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput>
  }

  export type BookingCreateManyCustomerInputEnvelope = {
    data: BookingCreateManyCustomerInput | BookingCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutCustomerInput = {
    rating?: number | null
    comments?: string | null
    reviewDate?: Date | string | null
    hotel?: HotelCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutCustomerInput = {
    id?: number
    hotelId?: number | null
    rating?: number | null
    comments?: string | null
    reviewDate?: Date | string | null
  }

  export type ReviewCreateOrConnectWithoutCustomerInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutCustomerInput, ReviewUncheckedCreateWithoutCustomerInput>
  }

  export type ReviewCreateManyCustomerInputEnvelope = {
    data: ReviewCreateManyCustomerInput | ReviewCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutUserInput = {
    action?: string | null
    logDate?: Date | string | null
  }

  export type ActivityLogUncheckedCreateWithoutUserInput = {
    id?: number
    action?: string | null
    logDate?: Date | string | null
  }

  export type ActivityLogCreateOrConnectWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogCreateManyUserInputEnvelope = {
    data: ActivityLogCreateManyUserInput | ActivityLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SystemNotificationCreateWithoutUserInput = {
    message?: string | null
    notificationDate?: Date | string | null
  }

  export type SystemNotificationUncheckedCreateWithoutUserInput = {
    id?: number
    message?: string | null
    notificationDate?: Date | string | null
  }

  export type SystemNotificationCreateOrConnectWithoutUserInput = {
    where: SystemNotificationWhereUniqueInput
    create: XOR<SystemNotificationCreateWithoutUserInput, SystemNotificationUncheckedCreateWithoutUserInput>
  }

  export type SystemNotificationCreateManyUserInputEnvelope = {
    data: SystemNotificationCreateManyUserInput | SystemNotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCustomerInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutCustomerInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutCustomerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
  }

  export type UserCreateManyCustomerInputEnvelope = {
    data: UserCreateManyCustomerInput | UserCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithWhereUniqueWithoutCustomerInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutCustomerInput, BookingUncheckedUpdateWithoutCustomerInput>
    create: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutCustomerInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutCustomerInput, BookingUncheckedUpdateWithoutCustomerInput>
  }

  export type BookingUpdateManyWithWhereWithoutCustomerInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutCustomerInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: IntFilter<"Booking"> | number
    customerId?: IntNullableFilter<"Booking"> | number | null
    roomId?: IntNullableFilter<"Booking"> | number | null
    statusId?: IntNullableFilter<"Booking"> | number | null
    checkIn?: DateTimeNullableFilter<"Booking"> | Date | string | null
    checkOut?: DateTimeNullableFilter<"Booking"> | Date | string | null
    totalPrice?: DecimalNullableFilter<"Booking"> | Decimal | DecimalJsLike | number | string | null
  }

  export type ReviewUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutCustomerInput, ReviewUncheckedUpdateWithoutCustomerInput>
    create: XOR<ReviewCreateWithoutCustomerInput, ReviewUncheckedCreateWithoutCustomerInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutCustomerInput, ReviewUncheckedUpdateWithoutCustomerInput>
  }

  export type ReviewUpdateManyWithWhereWithoutCustomerInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: IntFilter<"Review"> | number
    customerId?: IntNullableFilter<"Review"> | number | null
    hotelId?: IntNullableFilter<"Review"> | number | null
    rating?: IntNullableFilter<"Review"> | number | null
    comments?: StringNullableFilter<"Review"> | string | null
    reviewDate?: DateTimeNullableFilter<"Review"> | Date | string | null
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: IntFilter<"ActivityLog"> | number
    userId?: IntNullableFilter<"ActivityLog"> | number | null
    action?: StringNullableFilter<"ActivityLog"> | string | null
    logDate?: DateTimeNullableFilter<"ActivityLog"> | Date | string | null
  }

  export type SystemNotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: SystemNotificationWhereUniqueInput
    update: XOR<SystemNotificationUpdateWithoutUserInput, SystemNotificationUncheckedUpdateWithoutUserInput>
    create: XOR<SystemNotificationCreateWithoutUserInput, SystemNotificationUncheckedCreateWithoutUserInput>
  }

  export type SystemNotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: SystemNotificationWhereUniqueInput
    data: XOR<SystemNotificationUpdateWithoutUserInput, SystemNotificationUncheckedUpdateWithoutUserInput>
  }

  export type SystemNotificationUpdateManyWithWhereWithoutUserInput = {
    where: SystemNotificationScalarWhereInput
    data: XOR<SystemNotificationUpdateManyMutationInput, SystemNotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type SystemNotificationScalarWhereInput = {
    AND?: SystemNotificationScalarWhereInput | SystemNotificationScalarWhereInput[]
    OR?: SystemNotificationScalarWhereInput[]
    NOT?: SystemNotificationScalarWhereInput | SystemNotificationScalarWhereInput[]
    id?: IntFilter<"SystemNotification"> | number
    userId?: IntNullableFilter<"SystemNotification"> | number | null
    message?: StringNullableFilter<"SystemNotification"> | string | null
    notificationDate?: DateTimeNullableFilter<"SystemNotification"> | Date | string | null
  }

  export type UserUpsertWithWhereUniqueWithoutCustomerInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCustomerInput, UserUncheckedUpdateWithoutCustomerInput>
    create: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCustomerInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCustomerInput, UserUncheckedUpdateWithoutCustomerInput>
  }

  export type UserUpdateManyWithWhereWithoutCustomerInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCustomerInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    customerId?: IntNullableFilter<"User"> | number | null
  }

  export type RoomCreateWithoutHotelInput = {
    price?: Decimal | DecimalJsLike | number | string | null
    availability?: boolean | null
    roomType?: RoomTypeCreateNestedOneWithoutRoomsInput
    bookings?: BookingCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenitiesLinkCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutHotelInput = {
    id?: number
    roomTypeId?: number | null
    price?: Decimal | DecimalJsLike | number | string | null
    availability?: boolean | null
    bookings?: BookingUncheckedCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenitiesLinkUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutHotelInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutHotelInput, RoomUncheckedCreateWithoutHotelInput>
  }

  export type RoomCreateManyHotelInputEnvelope = {
    data: RoomCreateManyHotelInput | RoomCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutHotelInput = {
    rating?: number | null
    comments?: string | null
    reviewDate?: Date | string | null
    customer?: CustomerCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutHotelInput = {
    id?: number
    customerId?: number | null
    rating?: number | null
    comments?: string | null
    reviewDate?: Date | string | null
  }

  export type ReviewCreateOrConnectWithoutHotelInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutHotelInput, ReviewUncheckedCreateWithoutHotelInput>
  }

  export type ReviewCreateManyHotelInputEnvelope = {
    data: ReviewCreateManyHotelInput | ReviewCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type HotelPolicyCreateWithoutHotelInput = {
    policyDescription?: string | null
  }

  export type HotelPolicyUncheckedCreateWithoutHotelInput = {
    id?: number
    policyDescription?: string | null
  }

  export type HotelPolicyCreateOrConnectWithoutHotelInput = {
    where: HotelPolicyWhereUniqueInput
    create: XOR<HotelPolicyCreateWithoutHotelInput, HotelPolicyUncheckedCreateWithoutHotelInput>
  }

  export type HotelPolicyCreateManyHotelInputEnvelope = {
    data: HotelPolicyCreateManyHotelInput | HotelPolicyCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type HotelEventCreateWithoutHotelInput = {
    eventName?: string | null
    eventDate?: Date | string | null
    description?: string | null
  }

  export type HotelEventUncheckedCreateWithoutHotelInput = {
    id?: number
    eventName?: string | null
    eventDate?: Date | string | null
    description?: string | null
  }

  export type HotelEventCreateOrConnectWithoutHotelInput = {
    where: HotelEventWhereUniqueInput
    create: XOR<HotelEventCreateWithoutHotelInput, HotelEventUncheckedCreateWithoutHotelInput>
  }

  export type HotelEventCreateManyHotelInputEnvelope = {
    data: HotelEventCreateManyHotelInput | HotelEventCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type HotelAmenitiesLinkCreateWithoutHotelInput = {
    amenity?: HotelAmenityCreateNestedOneWithoutHotelsInput
  }

  export type HotelAmenitiesLinkUncheckedCreateWithoutHotelInput = {
    id?: number
    amenityId?: number | null
  }

  export type HotelAmenitiesLinkCreateOrConnectWithoutHotelInput = {
    where: HotelAmenitiesLinkWhereUniqueInput
    create: XOR<HotelAmenitiesLinkCreateWithoutHotelInput, HotelAmenitiesLinkUncheckedCreateWithoutHotelInput>
  }

  export type HotelAmenitiesLinkCreateManyHotelInputEnvelope = {
    data: HotelAmenitiesLinkCreateManyHotelInput | HotelAmenitiesLinkCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type RoomUpsertWithWhereUniqueWithoutHotelInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutHotelInput, RoomUncheckedUpdateWithoutHotelInput>
    create: XOR<RoomCreateWithoutHotelInput, RoomUncheckedCreateWithoutHotelInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutHotelInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutHotelInput, RoomUncheckedUpdateWithoutHotelInput>
  }

  export type RoomUpdateManyWithWhereWithoutHotelInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutHotelInput>
  }

  export type RoomScalarWhereInput = {
    AND?: RoomScalarWhereInput | RoomScalarWhereInput[]
    OR?: RoomScalarWhereInput[]
    NOT?: RoomScalarWhereInput | RoomScalarWhereInput[]
    id?: IntFilter<"Room"> | number
    hotelId?: IntNullableFilter<"Room"> | number | null
    roomTypeId?: IntNullableFilter<"Room"> | number | null
    price?: DecimalNullableFilter<"Room"> | Decimal | DecimalJsLike | number | string | null
    availability?: BoolNullableFilter<"Room"> | boolean | null
  }

  export type ReviewUpsertWithWhereUniqueWithoutHotelInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutHotelInput, ReviewUncheckedUpdateWithoutHotelInput>
    create: XOR<ReviewCreateWithoutHotelInput, ReviewUncheckedCreateWithoutHotelInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutHotelInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutHotelInput, ReviewUncheckedUpdateWithoutHotelInput>
  }

  export type ReviewUpdateManyWithWhereWithoutHotelInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutHotelInput>
  }

  export type HotelPolicyUpsertWithWhereUniqueWithoutHotelInput = {
    where: HotelPolicyWhereUniqueInput
    update: XOR<HotelPolicyUpdateWithoutHotelInput, HotelPolicyUncheckedUpdateWithoutHotelInput>
    create: XOR<HotelPolicyCreateWithoutHotelInput, HotelPolicyUncheckedCreateWithoutHotelInput>
  }

  export type HotelPolicyUpdateWithWhereUniqueWithoutHotelInput = {
    where: HotelPolicyWhereUniqueInput
    data: XOR<HotelPolicyUpdateWithoutHotelInput, HotelPolicyUncheckedUpdateWithoutHotelInput>
  }

  export type HotelPolicyUpdateManyWithWhereWithoutHotelInput = {
    where: HotelPolicyScalarWhereInput
    data: XOR<HotelPolicyUpdateManyMutationInput, HotelPolicyUncheckedUpdateManyWithoutHotelInput>
  }

  export type HotelPolicyScalarWhereInput = {
    AND?: HotelPolicyScalarWhereInput | HotelPolicyScalarWhereInput[]
    OR?: HotelPolicyScalarWhereInput[]
    NOT?: HotelPolicyScalarWhereInput | HotelPolicyScalarWhereInput[]
    id?: IntFilter<"HotelPolicy"> | number
    hotelId?: IntNullableFilter<"HotelPolicy"> | number | null
    policyDescription?: StringNullableFilter<"HotelPolicy"> | string | null
  }

  export type HotelEventUpsertWithWhereUniqueWithoutHotelInput = {
    where: HotelEventWhereUniqueInput
    update: XOR<HotelEventUpdateWithoutHotelInput, HotelEventUncheckedUpdateWithoutHotelInput>
    create: XOR<HotelEventCreateWithoutHotelInput, HotelEventUncheckedCreateWithoutHotelInput>
  }

  export type HotelEventUpdateWithWhereUniqueWithoutHotelInput = {
    where: HotelEventWhereUniqueInput
    data: XOR<HotelEventUpdateWithoutHotelInput, HotelEventUncheckedUpdateWithoutHotelInput>
  }

  export type HotelEventUpdateManyWithWhereWithoutHotelInput = {
    where: HotelEventScalarWhereInput
    data: XOR<HotelEventUpdateManyMutationInput, HotelEventUncheckedUpdateManyWithoutHotelInput>
  }

  export type HotelEventScalarWhereInput = {
    AND?: HotelEventScalarWhereInput | HotelEventScalarWhereInput[]
    OR?: HotelEventScalarWhereInput[]
    NOT?: HotelEventScalarWhereInput | HotelEventScalarWhereInput[]
    id?: IntFilter<"HotelEvent"> | number
    hotelId?: IntNullableFilter<"HotelEvent"> | number | null
    eventName?: StringNullableFilter<"HotelEvent"> | string | null
    eventDate?: DateTimeNullableFilter<"HotelEvent"> | Date | string | null
    description?: StringNullableFilter<"HotelEvent"> | string | null
  }

  export type HotelAmenitiesLinkUpsertWithWhereUniqueWithoutHotelInput = {
    where: HotelAmenitiesLinkWhereUniqueInput
    update: XOR<HotelAmenitiesLinkUpdateWithoutHotelInput, HotelAmenitiesLinkUncheckedUpdateWithoutHotelInput>
    create: XOR<HotelAmenitiesLinkCreateWithoutHotelInput, HotelAmenitiesLinkUncheckedCreateWithoutHotelInput>
  }

  export type HotelAmenitiesLinkUpdateWithWhereUniqueWithoutHotelInput = {
    where: HotelAmenitiesLinkWhereUniqueInput
    data: XOR<HotelAmenitiesLinkUpdateWithoutHotelInput, HotelAmenitiesLinkUncheckedUpdateWithoutHotelInput>
  }

  export type HotelAmenitiesLinkUpdateManyWithWhereWithoutHotelInput = {
    where: HotelAmenitiesLinkScalarWhereInput
    data: XOR<HotelAmenitiesLinkUpdateManyMutationInput, HotelAmenitiesLinkUncheckedUpdateManyWithoutHotelInput>
  }

  export type HotelAmenitiesLinkScalarWhereInput = {
    AND?: HotelAmenitiesLinkScalarWhereInput | HotelAmenitiesLinkScalarWhereInput[]
    OR?: HotelAmenitiesLinkScalarWhereInput[]
    NOT?: HotelAmenitiesLinkScalarWhereInput | HotelAmenitiesLinkScalarWhereInput[]
    id?: IntFilter<"HotelAmenitiesLink"> | number
    hotelId?: IntFilter<"HotelAmenitiesLink"> | number
    amenityId?: IntNullableFilter<"HotelAmenitiesLink"> | number | null
  }

  export type RoomCreateWithoutRoomTypeInput = {
    price?: Decimal | DecimalJsLike | number | string | null
    availability?: boolean | null
    hotel?: HotelCreateNestedOneWithoutRoomsInput
    bookings?: BookingCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenitiesLinkCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutRoomTypeInput = {
    id?: number
    hotelId?: number | null
    price?: Decimal | DecimalJsLike | number | string | null
    availability?: boolean | null
    bookings?: BookingUncheckedCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenitiesLinkUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutRoomTypeInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutRoomTypeInput, RoomUncheckedCreateWithoutRoomTypeInput>
  }

  export type RoomCreateManyRoomTypeInputEnvelope = {
    data: RoomCreateManyRoomTypeInput | RoomCreateManyRoomTypeInput[]
    skipDuplicates?: boolean
  }

  export type RoomUpsertWithWhereUniqueWithoutRoomTypeInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutRoomTypeInput, RoomUncheckedUpdateWithoutRoomTypeInput>
    create: XOR<RoomCreateWithoutRoomTypeInput, RoomUncheckedCreateWithoutRoomTypeInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutRoomTypeInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutRoomTypeInput, RoomUncheckedUpdateWithoutRoomTypeInput>
  }

  export type RoomUpdateManyWithWhereWithoutRoomTypeInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutRoomTypeInput>
  }

  export type HotelCreateWithoutRoomsInput = {
    name?: string | null
    address?: string | null
    city?: string | null
    rating?: number | null
    reviews?: ReviewCreateNestedManyWithoutHotelInput
    policies?: HotelPolicyCreateNestedManyWithoutHotelInput
    events?: HotelEventCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenitiesLinkCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutRoomsInput = {
    id?: number
    name?: string | null
    address?: string | null
    city?: string | null
    rating?: number | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutHotelInput
    policies?: HotelPolicyUncheckedCreateNestedManyWithoutHotelInput
    events?: HotelEventUncheckedCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenitiesLinkUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutRoomsInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
  }

  export type RoomTypeCreateWithoutRoomsInput = {
    typeName?: string | null
    description?: string | null
  }

  export type RoomTypeUncheckedCreateWithoutRoomsInput = {
    id?: number
    typeName?: string | null
    description?: string | null
  }

  export type RoomTypeCreateOrConnectWithoutRoomsInput = {
    where: RoomTypeWhereUniqueInput
    create: XOR<RoomTypeCreateWithoutRoomsInput, RoomTypeUncheckedCreateWithoutRoomsInput>
  }

  export type BookingCreateWithoutRoomInput = {
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    customer?: CustomerCreateNestedOneWithoutBookingsInput
    status?: BookingStatusCreateNestedOneWithoutBookingsInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    promotions?: PromotionAppliedCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutRoomInput = {
    id?: number
    customerId?: number | null
    statusId?: number | null
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    promotions?: PromotionAppliedUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutRoomInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutRoomInput, BookingUncheckedCreateWithoutRoomInput>
  }

  export type BookingCreateManyRoomInputEnvelope = {
    data: BookingCreateManyRoomInput | BookingCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type RoomAmenitiesLinkCreateWithoutRoomInput = {
    amenity?: RoomAmenityCreateNestedOneWithoutRoomsInput
  }

  export type RoomAmenitiesLinkUncheckedCreateWithoutRoomInput = {
    id?: number
    amenityId?: number | null
  }

  export type RoomAmenitiesLinkCreateOrConnectWithoutRoomInput = {
    where: RoomAmenitiesLinkWhereUniqueInput
    create: XOR<RoomAmenitiesLinkCreateWithoutRoomInput, RoomAmenitiesLinkUncheckedCreateWithoutRoomInput>
  }

  export type RoomAmenitiesLinkCreateManyRoomInputEnvelope = {
    data: RoomAmenitiesLinkCreateManyRoomInput | RoomAmenitiesLinkCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type HotelUpsertWithoutRoomsInput = {
    update: XOR<HotelUpdateWithoutRoomsInput, HotelUncheckedUpdateWithoutRoomsInput>
    create: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutRoomsInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutRoomsInput, HotelUncheckedUpdateWithoutRoomsInput>
  }

  export type HotelUpdateWithoutRoomsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviews?: ReviewUpdateManyWithoutHotelNestedInput
    policies?: HotelPolicyUpdateManyWithoutHotelNestedInput
    events?: HotelEventUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenitiesLinkUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviews?: ReviewUncheckedUpdateManyWithoutHotelNestedInput
    policies?: HotelPolicyUncheckedUpdateManyWithoutHotelNestedInput
    events?: HotelEventUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenitiesLinkUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type RoomTypeUpsertWithoutRoomsInput = {
    update: XOR<RoomTypeUpdateWithoutRoomsInput, RoomTypeUncheckedUpdateWithoutRoomsInput>
    create: XOR<RoomTypeCreateWithoutRoomsInput, RoomTypeUncheckedCreateWithoutRoomsInput>
    where?: RoomTypeWhereInput
  }

  export type RoomTypeUpdateToOneWithWhereWithoutRoomsInput = {
    where?: RoomTypeWhereInput
    data: XOR<RoomTypeUpdateWithoutRoomsInput, RoomTypeUncheckedUpdateWithoutRoomsInput>
  }

  export type RoomTypeUpdateWithoutRoomsInput = {
    typeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoomTypeUncheckedUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingUpsertWithWhereUniqueWithoutRoomInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutRoomInput, BookingUncheckedUpdateWithoutRoomInput>
    create: XOR<BookingCreateWithoutRoomInput, BookingUncheckedCreateWithoutRoomInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutRoomInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutRoomInput, BookingUncheckedUpdateWithoutRoomInput>
  }

  export type BookingUpdateManyWithWhereWithoutRoomInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutRoomInput>
  }

  export type RoomAmenitiesLinkUpsertWithWhereUniqueWithoutRoomInput = {
    where: RoomAmenitiesLinkWhereUniqueInput
    update: XOR<RoomAmenitiesLinkUpdateWithoutRoomInput, RoomAmenitiesLinkUncheckedUpdateWithoutRoomInput>
    create: XOR<RoomAmenitiesLinkCreateWithoutRoomInput, RoomAmenitiesLinkUncheckedCreateWithoutRoomInput>
  }

  export type RoomAmenitiesLinkUpdateWithWhereUniqueWithoutRoomInput = {
    where: RoomAmenitiesLinkWhereUniqueInput
    data: XOR<RoomAmenitiesLinkUpdateWithoutRoomInput, RoomAmenitiesLinkUncheckedUpdateWithoutRoomInput>
  }

  export type RoomAmenitiesLinkUpdateManyWithWhereWithoutRoomInput = {
    where: RoomAmenitiesLinkScalarWhereInput
    data: XOR<RoomAmenitiesLinkUpdateManyMutationInput, RoomAmenitiesLinkUncheckedUpdateManyWithoutRoomInput>
  }

  export type RoomAmenitiesLinkScalarWhereInput = {
    AND?: RoomAmenitiesLinkScalarWhereInput | RoomAmenitiesLinkScalarWhereInput[]
    OR?: RoomAmenitiesLinkScalarWhereInput[]
    NOT?: RoomAmenitiesLinkScalarWhereInput | RoomAmenitiesLinkScalarWhereInput[]
    id?: IntFilter<"RoomAmenitiesLink"> | number
    roomId?: IntFilter<"RoomAmenitiesLink"> | number
    amenityId?: IntNullableFilter<"RoomAmenitiesLink"> | number | null
  }

  export type BookingCreateWithoutStatusInput = {
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    customer?: CustomerCreateNestedOneWithoutBookingsInput
    room?: RoomCreateNestedOneWithoutBookingsInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    promotions?: PromotionAppliedCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutStatusInput = {
    id?: number
    customerId?: number | null
    roomId?: number | null
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    promotions?: PromotionAppliedUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutStatusInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutStatusInput, BookingUncheckedCreateWithoutStatusInput>
  }

  export type BookingCreateManyStatusInputEnvelope = {
    data: BookingCreateManyStatusInput | BookingCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithWhereUniqueWithoutStatusInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutStatusInput, BookingUncheckedUpdateWithoutStatusInput>
    create: XOR<BookingCreateWithoutStatusInput, BookingUncheckedCreateWithoutStatusInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutStatusInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutStatusInput, BookingUncheckedUpdateWithoutStatusInput>
  }

  export type BookingUpdateManyWithWhereWithoutStatusInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutStatusInput>
  }

  export type CustomerCreateWithoutBookingsInput = {
    name?: string | null
    email?: string | null
    phone?: string | null
    reviews?: ReviewCreateNestedManyWithoutCustomerInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    notifications?: SystemNotificationCreateNestedManyWithoutUserInput
    User?: UserCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutBookingsInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone?: string | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutCustomerInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    User?: UserUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutBookingsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutBookingsInput, CustomerUncheckedCreateWithoutBookingsInput>
  }

  export type RoomCreateWithoutBookingsInput = {
    price?: Decimal | DecimalJsLike | number | string | null
    availability?: boolean | null
    hotel?: HotelCreateNestedOneWithoutRoomsInput
    roomType?: RoomTypeCreateNestedOneWithoutRoomsInput
    amenities?: RoomAmenitiesLinkCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutBookingsInput = {
    id?: number
    hotelId?: number | null
    roomTypeId?: number | null
    price?: Decimal | DecimalJsLike | number | string | null
    availability?: boolean | null
    amenities?: RoomAmenitiesLinkUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutBookingsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutBookingsInput, RoomUncheckedCreateWithoutBookingsInput>
  }

  export type BookingStatusCreateWithoutBookingsInput = {
    statusName?: string | null
  }

  export type BookingStatusUncheckedCreateWithoutBookingsInput = {
    id?: number
    statusName?: string | null
  }

  export type BookingStatusCreateOrConnectWithoutBookingsInput = {
    where: BookingStatusWhereUniqueInput
    create: XOR<BookingStatusCreateWithoutBookingsInput, BookingStatusUncheckedCreateWithoutBookingsInput>
  }

  export type BookingServiceCreateWithoutBookingInput = {
    quantity?: number | null
    service?: ServiceCreateNestedOneWithoutBookingsInput
  }

  export type BookingServiceUncheckedCreateWithoutBookingInput = {
    id?: number
    serviceId?: number | null
    quantity?: number | null
  }

  export type BookingServiceCreateOrConnectWithoutBookingInput = {
    where: BookingServiceWhereUniqueInput
    create: XOR<BookingServiceCreateWithoutBookingInput, BookingServiceUncheckedCreateWithoutBookingInput>
  }

  export type BookingServiceCreateManyBookingInputEnvelope = {
    data: BookingServiceCreateManyBookingInput | BookingServiceCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutBookingInput = {
    amount?: Decimal | DecimalJsLike | number | string | null
    paymentDate?: Date | string | null
    paymentMethod?: string | null
  }

  export type PaymentUncheckedCreateWithoutBookingInput = {
    id?: number
    amount?: Decimal | DecimalJsLike | number | string | null
    paymentDate?: Date | string | null
    paymentMethod?: string | null
  }

  export type PaymentCreateOrConnectWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentCreateManyBookingInputEnvelope = {
    data: PaymentCreateManyBookingInput | PaymentCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type PromotionAppliedCreateWithoutBookingInput = {
    promotion: PromotionCreateNestedOneWithoutBookingsInput
  }

  export type PromotionAppliedUncheckedCreateWithoutBookingInput = {
    id?: number
    promotionId: number
  }

  export type PromotionAppliedCreateOrConnectWithoutBookingInput = {
    where: PromotionAppliedWhereUniqueInput
    create: XOR<PromotionAppliedCreateWithoutBookingInput, PromotionAppliedUncheckedCreateWithoutBookingInput>
  }

  export type PromotionAppliedCreateManyBookingInputEnvelope = {
    data: PromotionAppliedCreateManyBookingInput | PromotionAppliedCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutBookingsInput = {
    update: XOR<CustomerUpdateWithoutBookingsInput, CustomerUncheckedUpdateWithoutBookingsInput>
    create: XOR<CustomerCreateWithoutBookingsInput, CustomerUncheckedCreateWithoutBookingsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutBookingsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutBookingsInput, CustomerUncheckedUpdateWithoutBookingsInput>
  }

  export type CustomerUpdateWithoutBookingsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    reviews?: ReviewUpdateManyWithoutCustomerNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    notifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    User?: UserUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    reviews?: ReviewUncheckedUpdateManyWithoutCustomerNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    User?: UserUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type RoomUpsertWithoutBookingsInput = {
    update: XOR<RoomUpdateWithoutBookingsInput, RoomUncheckedUpdateWithoutBookingsInput>
    create: XOR<RoomCreateWithoutBookingsInput, RoomUncheckedCreateWithoutBookingsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutBookingsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutBookingsInput, RoomUncheckedUpdateWithoutBookingsInput>
  }

  export type RoomUpdateWithoutBookingsInput = {
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    availability?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hotel?: HotelUpdateOneWithoutRoomsNestedInput
    roomType?: RoomTypeUpdateOneWithoutRoomsNestedInput
    amenities?: RoomAmenitiesLinkUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    availability?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amenities?: RoomAmenitiesLinkUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type BookingStatusUpsertWithoutBookingsInput = {
    update: XOR<BookingStatusUpdateWithoutBookingsInput, BookingStatusUncheckedUpdateWithoutBookingsInput>
    create: XOR<BookingStatusCreateWithoutBookingsInput, BookingStatusUncheckedCreateWithoutBookingsInput>
    where?: BookingStatusWhereInput
  }

  export type BookingStatusUpdateToOneWithWhereWithoutBookingsInput = {
    where?: BookingStatusWhereInput
    data: XOR<BookingStatusUpdateWithoutBookingsInput, BookingStatusUncheckedUpdateWithoutBookingsInput>
  }

  export type BookingStatusUpdateWithoutBookingsInput = {
    statusName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingStatusUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    statusName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingServiceUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingServiceWhereUniqueInput
    update: XOR<BookingServiceUpdateWithoutBookingInput, BookingServiceUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingServiceCreateWithoutBookingInput, BookingServiceUncheckedCreateWithoutBookingInput>
  }

  export type BookingServiceUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingServiceWhereUniqueInput
    data: XOR<BookingServiceUpdateWithoutBookingInput, BookingServiceUncheckedUpdateWithoutBookingInput>
  }

  export type BookingServiceUpdateManyWithWhereWithoutBookingInput = {
    where: BookingServiceScalarWhereInput
    data: XOR<BookingServiceUpdateManyMutationInput, BookingServiceUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingServiceScalarWhereInput = {
    AND?: BookingServiceScalarWhereInput | BookingServiceScalarWhereInput[]
    OR?: BookingServiceScalarWhereInput[]
    NOT?: BookingServiceScalarWhereInput | BookingServiceScalarWhereInput[]
    id?: IntFilter<"BookingService"> | number
    bookingId?: IntFilter<"BookingService"> | number
    serviceId?: IntNullableFilter<"BookingService"> | number | null
    quantity?: IntNullableFilter<"BookingService"> | number | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUpdateManyWithWhereWithoutBookingInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutBookingInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    bookingId?: IntNullableFilter<"Payment"> | number | null
    amount?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    paymentDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
  }

  export type PromotionAppliedUpsertWithWhereUniqueWithoutBookingInput = {
    where: PromotionAppliedWhereUniqueInput
    update: XOR<PromotionAppliedUpdateWithoutBookingInput, PromotionAppliedUncheckedUpdateWithoutBookingInput>
    create: XOR<PromotionAppliedCreateWithoutBookingInput, PromotionAppliedUncheckedCreateWithoutBookingInput>
  }

  export type PromotionAppliedUpdateWithWhereUniqueWithoutBookingInput = {
    where: PromotionAppliedWhereUniqueInput
    data: XOR<PromotionAppliedUpdateWithoutBookingInput, PromotionAppliedUncheckedUpdateWithoutBookingInput>
  }

  export type PromotionAppliedUpdateManyWithWhereWithoutBookingInput = {
    where: PromotionAppliedScalarWhereInput
    data: XOR<PromotionAppliedUpdateManyMutationInput, PromotionAppliedUncheckedUpdateManyWithoutBookingInput>
  }

  export type PromotionAppliedScalarWhereInput = {
    AND?: PromotionAppliedScalarWhereInput | PromotionAppliedScalarWhereInput[]
    OR?: PromotionAppliedScalarWhereInput[]
    NOT?: PromotionAppliedScalarWhereInput | PromotionAppliedScalarWhereInput[]
    id?: IntFilter<"PromotionApplied"> | number
    promotionId?: IntFilter<"PromotionApplied"> | number
    bookingId?: IntNullableFilter<"PromotionApplied"> | number | null
  }

  export type BookingServiceCreateWithoutServiceInput = {
    quantity?: number | null
    booking: BookingCreateNestedOneWithoutServicesInput
  }

  export type BookingServiceUncheckedCreateWithoutServiceInput = {
    id?: number
    bookingId: number
    quantity?: number | null
  }

  export type BookingServiceCreateOrConnectWithoutServiceInput = {
    where: BookingServiceWhereUniqueInput
    create: XOR<BookingServiceCreateWithoutServiceInput, BookingServiceUncheckedCreateWithoutServiceInput>
  }

  export type BookingServiceCreateManyServiceInputEnvelope = {
    data: BookingServiceCreateManyServiceInput | BookingServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type BookingServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: BookingServiceWhereUniqueInput
    update: XOR<BookingServiceUpdateWithoutServiceInput, BookingServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<BookingServiceCreateWithoutServiceInput, BookingServiceUncheckedCreateWithoutServiceInput>
  }

  export type BookingServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: BookingServiceWhereUniqueInput
    data: XOR<BookingServiceUpdateWithoutServiceInput, BookingServiceUncheckedUpdateWithoutServiceInput>
  }

  export type BookingServiceUpdateManyWithWhereWithoutServiceInput = {
    where: BookingServiceScalarWhereInput
    data: XOR<BookingServiceUpdateManyMutationInput, BookingServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type BookingCreateWithoutServicesInput = {
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    customer?: CustomerCreateNestedOneWithoutBookingsInput
    room?: RoomCreateNestedOneWithoutBookingsInput
    status?: BookingStatusCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    promotions?: PromotionAppliedCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutServicesInput = {
    id?: number
    customerId?: number | null
    roomId?: number | null
    statusId?: number | null
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    promotions?: PromotionAppliedUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutServicesInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutServicesInput, BookingUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCreateWithoutBookingsInput = {
    serviceName?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
  }

  export type ServiceUncheckedCreateWithoutBookingsInput = {
    id?: number
    serviceName?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
  }

  export type ServiceCreateOrConnectWithoutBookingsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
  }

  export type BookingUpsertWithoutServicesInput = {
    update: XOR<BookingUpdateWithoutServicesInput, BookingUncheckedUpdateWithoutServicesInput>
    create: XOR<BookingCreateWithoutServicesInput, BookingUncheckedCreateWithoutServicesInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutServicesInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutServicesInput, BookingUncheckedUpdateWithoutServicesInput>
  }

  export type BookingUpdateWithoutServicesInput = {
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customer?: CustomerUpdateOneWithoutBookingsNestedInput
    room?: RoomUpdateOneWithoutBookingsNestedInput
    status?: BookingStatusUpdateOneWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    promotions?: PromotionAppliedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    promotions?: PromotionAppliedUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ServiceUpsertWithoutBookingsInput = {
    update: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type ServiceUpdateWithoutBookingsInput = {
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ServiceUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EmployeeCreateWithoutRoleInput = {
    name?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeeUncheckedCreateWithoutRoleInput = {
    id?: number
    departmentId?: number | null
    name?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
  }

  export type EmployeeCreateOrConnectWithoutRoleInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput>
  }

  export type EmployeeCreateManyRoleInputEnvelope = {
    data: EmployeeCreateManyRoleInput | EmployeeCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutRoleInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutRoleInput, EmployeeUncheckedUpdateWithoutRoleInput>
    create: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutRoleInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutRoleInput, EmployeeUncheckedUpdateWithoutRoleInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutRoleInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutRoleInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: IntFilter<"Employee"> | number
    roleId?: IntNullableFilter<"Employee"> | number | null
    departmentId?: IntNullableFilter<"Employee"> | number | null
    name?: StringNullableFilter<"Employee"> | string | null
    position?: StringNullableFilter<"Employee"> | string | null
    salary?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
  }

  export type EmployeeCreateWithoutDepartmentInput = {
    name?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    role?: EmployeeRoleCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeeUncheckedCreateWithoutDepartmentInput = {
    id?: number
    roleId?: number | null
    name?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
  }

  export type EmployeeCreateOrConnectWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeCreateManyDepartmentInputEnvelope = {
    data: EmployeeCreateManyDepartmentInput | EmployeeCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutDepartmentInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type EmployeeRoleCreateWithoutEmployeesInput = {
    roleName?: string | null
    description?: string | null
  }

  export type EmployeeRoleUncheckedCreateWithoutEmployeesInput = {
    id?: number
    roleName?: string | null
    description?: string | null
  }

  export type EmployeeRoleCreateOrConnectWithoutEmployeesInput = {
    where: EmployeeRoleWhereUniqueInput
    create: XOR<EmployeeRoleCreateWithoutEmployeesInput, EmployeeRoleUncheckedCreateWithoutEmployeesInput>
  }

  export type DepartmentCreateWithoutEmployeesInput = {
    departmentName?: string | null
  }

  export type DepartmentUncheckedCreateWithoutEmployeesInput = {
    id?: number
    departmentName?: string | null
  }

  export type DepartmentCreateOrConnectWithoutEmployeesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
  }

  export type EmployeeRoleUpsertWithoutEmployeesInput = {
    update: XOR<EmployeeRoleUpdateWithoutEmployeesInput, EmployeeRoleUncheckedUpdateWithoutEmployeesInput>
    create: XOR<EmployeeRoleCreateWithoutEmployeesInput, EmployeeRoleUncheckedCreateWithoutEmployeesInput>
    where?: EmployeeRoleWhereInput
  }

  export type EmployeeRoleUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: EmployeeRoleWhereInput
    data: XOR<EmployeeRoleUpdateWithoutEmployeesInput, EmployeeRoleUncheckedUpdateWithoutEmployeesInput>
  }

  export type EmployeeRoleUpdateWithoutEmployeesInput = {
    roleName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeRoleUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DepartmentUpsertWithoutEmployeesInput = {
    update: XOR<DepartmentUpdateWithoutEmployeesInput, DepartmentUncheckedUpdateWithoutEmployeesInput>
    create: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutEmployeesInput, DepartmentUncheckedUpdateWithoutEmployeesInput>
  }

  export type DepartmentUpdateWithoutEmployeesInput = {
    departmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DepartmentUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    departmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingCreateWithoutPaymentsInput = {
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    customer?: CustomerCreateNestedOneWithoutBookingsInput
    room?: RoomCreateNestedOneWithoutBookingsInput
    status?: BookingStatusCreateNestedOneWithoutBookingsInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
    promotions?: PromotionAppliedCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPaymentsInput = {
    id?: number
    customerId?: number | null
    roomId?: number | null
    statusId?: number | null
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
    promotions?: PromotionAppliedUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPaymentsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
  }

  export type BookingUpsertWithoutPaymentsInput = {
    update: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type BookingUpdateWithoutPaymentsInput = {
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customer?: CustomerUpdateOneWithoutBookingsNestedInput
    room?: RoomUpdateOneWithoutBookingsNestedInput
    status?: BookingStatusUpdateOneWithoutBookingsNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
    promotions?: PromotionAppliedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
    promotions?: PromotionAppliedUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type CustomerCreateWithoutReviewsInput = {
    name?: string | null
    email?: string | null
    phone?: string | null
    bookings?: BookingCreateNestedManyWithoutCustomerInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    notifications?: SystemNotificationCreateNestedManyWithoutUserInput
    User?: UserCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutReviewsInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone?: string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    User?: UserUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutReviewsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutReviewsInput, CustomerUncheckedCreateWithoutReviewsInput>
  }

  export type HotelCreateWithoutReviewsInput = {
    name?: string | null
    address?: string | null
    city?: string | null
    rating?: number | null
    rooms?: RoomCreateNestedManyWithoutHotelInput
    policies?: HotelPolicyCreateNestedManyWithoutHotelInput
    events?: HotelEventCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenitiesLinkCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutReviewsInput = {
    id?: number
    name?: string | null
    address?: string | null
    city?: string | null
    rating?: number | null
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
    policies?: HotelPolicyUncheckedCreateNestedManyWithoutHotelInput
    events?: HotelEventUncheckedCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenitiesLinkUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutReviewsInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutReviewsInput, HotelUncheckedCreateWithoutReviewsInput>
  }

  export type CustomerUpsertWithoutReviewsInput = {
    update: XOR<CustomerUpdateWithoutReviewsInput, CustomerUncheckedUpdateWithoutReviewsInput>
    create: XOR<CustomerCreateWithoutReviewsInput, CustomerUncheckedCreateWithoutReviewsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutReviewsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutReviewsInput, CustomerUncheckedUpdateWithoutReviewsInput>
  }

  export type CustomerUpdateWithoutReviewsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUpdateManyWithoutCustomerNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    notifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    User?: UserUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    User?: UserUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type HotelUpsertWithoutReviewsInput = {
    update: XOR<HotelUpdateWithoutReviewsInput, HotelUncheckedUpdateWithoutReviewsInput>
    create: XOR<HotelCreateWithoutReviewsInput, HotelUncheckedCreateWithoutReviewsInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutReviewsInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutReviewsInput, HotelUncheckedUpdateWithoutReviewsInput>
  }

  export type HotelUpdateWithoutReviewsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    rooms?: RoomUpdateManyWithoutHotelNestedInput
    policies?: HotelPolicyUpdateManyWithoutHotelNestedInput
    events?: HotelEventUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenitiesLinkUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
    policies?: HotelPolicyUncheckedUpdateManyWithoutHotelNestedInput
    events?: HotelEventUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenitiesLinkUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type PromotionAppliedCreateWithoutPromotionInput = {
    booking?: BookingCreateNestedOneWithoutPromotionsInput
  }

  export type PromotionAppliedUncheckedCreateWithoutPromotionInput = {
    id?: number
    bookingId?: number | null
  }

  export type PromotionAppliedCreateOrConnectWithoutPromotionInput = {
    where: PromotionAppliedWhereUniqueInput
    create: XOR<PromotionAppliedCreateWithoutPromotionInput, PromotionAppliedUncheckedCreateWithoutPromotionInput>
  }

  export type PromotionAppliedCreateManyPromotionInputEnvelope = {
    data: PromotionAppliedCreateManyPromotionInput | PromotionAppliedCreateManyPromotionInput[]
    skipDuplicates?: boolean
  }

  export type PromotionAppliedUpsertWithWhereUniqueWithoutPromotionInput = {
    where: PromotionAppliedWhereUniqueInput
    update: XOR<PromotionAppliedUpdateWithoutPromotionInput, PromotionAppliedUncheckedUpdateWithoutPromotionInput>
    create: XOR<PromotionAppliedCreateWithoutPromotionInput, PromotionAppliedUncheckedCreateWithoutPromotionInput>
  }

  export type PromotionAppliedUpdateWithWhereUniqueWithoutPromotionInput = {
    where: PromotionAppliedWhereUniqueInput
    data: XOR<PromotionAppliedUpdateWithoutPromotionInput, PromotionAppliedUncheckedUpdateWithoutPromotionInput>
  }

  export type PromotionAppliedUpdateManyWithWhereWithoutPromotionInput = {
    where: PromotionAppliedScalarWhereInput
    data: XOR<PromotionAppliedUpdateManyMutationInput, PromotionAppliedUncheckedUpdateManyWithoutPromotionInput>
  }

  export type RoomAmenitiesLinkCreateWithoutAmenityInput = {
    room: RoomCreateNestedOneWithoutAmenitiesInput
  }

  export type RoomAmenitiesLinkUncheckedCreateWithoutAmenityInput = {
    id?: number
    roomId: number
  }

  export type RoomAmenitiesLinkCreateOrConnectWithoutAmenityInput = {
    where: RoomAmenitiesLinkWhereUniqueInput
    create: XOR<RoomAmenitiesLinkCreateWithoutAmenityInput, RoomAmenitiesLinkUncheckedCreateWithoutAmenityInput>
  }

  export type RoomAmenitiesLinkCreateManyAmenityInputEnvelope = {
    data: RoomAmenitiesLinkCreateManyAmenityInput | RoomAmenitiesLinkCreateManyAmenityInput[]
    skipDuplicates?: boolean
  }

  export type RoomAmenitiesLinkUpsertWithWhereUniqueWithoutAmenityInput = {
    where: RoomAmenitiesLinkWhereUniqueInput
    update: XOR<RoomAmenitiesLinkUpdateWithoutAmenityInput, RoomAmenitiesLinkUncheckedUpdateWithoutAmenityInput>
    create: XOR<RoomAmenitiesLinkCreateWithoutAmenityInput, RoomAmenitiesLinkUncheckedCreateWithoutAmenityInput>
  }

  export type RoomAmenitiesLinkUpdateWithWhereUniqueWithoutAmenityInput = {
    where: RoomAmenitiesLinkWhereUniqueInput
    data: XOR<RoomAmenitiesLinkUpdateWithoutAmenityInput, RoomAmenitiesLinkUncheckedUpdateWithoutAmenityInput>
  }

  export type RoomAmenitiesLinkUpdateManyWithWhereWithoutAmenityInput = {
    where: RoomAmenitiesLinkScalarWhereInput
    data: XOR<RoomAmenitiesLinkUpdateManyMutationInput, RoomAmenitiesLinkUncheckedUpdateManyWithoutAmenityInput>
  }

  export type HotelAmenitiesLinkCreateWithoutAmenityInput = {
    hotel: HotelCreateNestedOneWithoutAmenitiesInput
  }

  export type HotelAmenitiesLinkUncheckedCreateWithoutAmenityInput = {
    id?: number
    hotelId: number
  }

  export type HotelAmenitiesLinkCreateOrConnectWithoutAmenityInput = {
    where: HotelAmenitiesLinkWhereUniqueInput
    create: XOR<HotelAmenitiesLinkCreateWithoutAmenityInput, HotelAmenitiesLinkUncheckedCreateWithoutAmenityInput>
  }

  export type HotelAmenitiesLinkCreateManyAmenityInputEnvelope = {
    data: HotelAmenitiesLinkCreateManyAmenityInput | HotelAmenitiesLinkCreateManyAmenityInput[]
    skipDuplicates?: boolean
  }

  export type HotelAmenitiesLinkUpsertWithWhereUniqueWithoutAmenityInput = {
    where: HotelAmenitiesLinkWhereUniqueInput
    update: XOR<HotelAmenitiesLinkUpdateWithoutAmenityInput, HotelAmenitiesLinkUncheckedUpdateWithoutAmenityInput>
    create: XOR<HotelAmenitiesLinkCreateWithoutAmenityInput, HotelAmenitiesLinkUncheckedCreateWithoutAmenityInput>
  }

  export type HotelAmenitiesLinkUpdateWithWhereUniqueWithoutAmenityInput = {
    where: HotelAmenitiesLinkWhereUniqueInput
    data: XOR<HotelAmenitiesLinkUpdateWithoutAmenityInput, HotelAmenitiesLinkUncheckedUpdateWithoutAmenityInput>
  }

  export type HotelAmenitiesLinkUpdateManyWithWhereWithoutAmenityInput = {
    where: HotelAmenitiesLinkScalarWhereInput
    data: XOR<HotelAmenitiesLinkUpdateManyMutationInput, HotelAmenitiesLinkUncheckedUpdateManyWithoutAmenityInput>
  }

  export type HotelCreateWithoutPoliciesInput = {
    name?: string | null
    address?: string | null
    city?: string | null
    rating?: number | null
    rooms?: RoomCreateNestedManyWithoutHotelInput
    reviews?: ReviewCreateNestedManyWithoutHotelInput
    events?: HotelEventCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenitiesLinkCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutPoliciesInput = {
    id?: number
    name?: string | null
    address?: string | null
    city?: string | null
    rating?: number | null
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHotelInput
    events?: HotelEventUncheckedCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenitiesLinkUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutPoliciesInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutPoliciesInput, HotelUncheckedCreateWithoutPoliciesInput>
  }

  export type HotelUpsertWithoutPoliciesInput = {
    update: XOR<HotelUpdateWithoutPoliciesInput, HotelUncheckedUpdateWithoutPoliciesInput>
    create: XOR<HotelCreateWithoutPoliciesInput, HotelUncheckedCreateWithoutPoliciesInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutPoliciesInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutPoliciesInput, HotelUncheckedUpdateWithoutPoliciesInput>
  }

  export type HotelUpdateWithoutPoliciesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    rooms?: RoomUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUpdateManyWithoutHotelNestedInput
    events?: HotelEventUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenitiesLinkUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutPoliciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHotelNestedInput
    events?: HotelEventUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenitiesLinkUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type PromotionCreateWithoutBookingsInput = {
    description?: string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type PromotionUncheckedCreateWithoutBookingsInput = {
    id?: number
    description?: string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type PromotionCreateOrConnectWithoutBookingsInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutBookingsInput, PromotionUncheckedCreateWithoutBookingsInput>
  }

  export type BookingCreateWithoutPromotionsInput = {
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    customer?: CustomerCreateNestedOneWithoutBookingsInput
    room?: RoomCreateNestedOneWithoutBookingsInput
    status?: BookingStatusCreateNestedOneWithoutBookingsInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPromotionsInput = {
    id?: number
    customerId?: number | null
    roomId?: number | null
    statusId?: number | null
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPromotionsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPromotionsInput, BookingUncheckedCreateWithoutPromotionsInput>
  }

  export type PromotionUpsertWithoutBookingsInput = {
    update: XOR<PromotionUpdateWithoutBookingsInput, PromotionUncheckedUpdateWithoutBookingsInput>
    create: XOR<PromotionCreateWithoutBookingsInput, PromotionUncheckedCreateWithoutBookingsInput>
    where?: PromotionWhereInput
  }

  export type PromotionUpdateToOneWithWhereWithoutBookingsInput = {
    where?: PromotionWhereInput
    data: XOR<PromotionUpdateWithoutBookingsInput, PromotionUncheckedUpdateWithoutBookingsInput>
  }

  export type PromotionUpdateWithoutBookingsInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PromotionUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingUpsertWithoutPromotionsInput = {
    update: XOR<BookingUpdateWithoutPromotionsInput, BookingUncheckedUpdateWithoutPromotionsInput>
    create: XOR<BookingCreateWithoutPromotionsInput, BookingUncheckedCreateWithoutPromotionsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPromotionsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPromotionsInput, BookingUncheckedUpdateWithoutPromotionsInput>
  }

  export type BookingUpdateWithoutPromotionsInput = {
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customer?: CustomerUpdateOneWithoutBookingsNestedInput
    room?: RoomUpdateOneWithoutBookingsNestedInput
    status?: BookingStatusUpdateOneWithoutBookingsNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPromotionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type CustomerCreateWithoutActivityLogsInput = {
    name?: string | null
    email?: string | null
    phone?: string | null
    bookings?: BookingCreateNestedManyWithoutCustomerInput
    reviews?: ReviewCreateNestedManyWithoutCustomerInput
    notifications?: SystemNotificationCreateNestedManyWithoutUserInput
    User?: UserCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutActivityLogsInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone?: string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCustomerInput
    notifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    User?: UserUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutActivityLogsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutActivityLogsInput, CustomerUncheckedCreateWithoutActivityLogsInput>
  }

  export type CustomerUpsertWithoutActivityLogsInput = {
    update: XOR<CustomerUpdateWithoutActivityLogsInput, CustomerUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<CustomerCreateWithoutActivityLogsInput, CustomerUncheckedCreateWithoutActivityLogsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutActivityLogsInput, CustomerUncheckedUpdateWithoutActivityLogsInput>
  }

  export type CustomerUpdateWithoutActivityLogsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUpdateManyWithoutCustomerNestedInput
    reviews?: ReviewUpdateManyWithoutCustomerNestedInput
    notifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    User?: UserUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutActivityLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCustomerNestedInput
    notifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    User?: UserUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type HotelCreateWithoutEventsInput = {
    name?: string | null
    address?: string | null
    city?: string | null
    rating?: number | null
    rooms?: RoomCreateNestedManyWithoutHotelInput
    reviews?: ReviewCreateNestedManyWithoutHotelInput
    policies?: HotelPolicyCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenitiesLinkCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutEventsInput = {
    id?: number
    name?: string | null
    address?: string | null
    city?: string | null
    rating?: number | null
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHotelInput
    policies?: HotelPolicyUncheckedCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenitiesLinkUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutEventsInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutEventsInput, HotelUncheckedCreateWithoutEventsInput>
  }

  export type HotelUpsertWithoutEventsInput = {
    update: XOR<HotelUpdateWithoutEventsInput, HotelUncheckedUpdateWithoutEventsInput>
    create: XOR<HotelCreateWithoutEventsInput, HotelUncheckedCreateWithoutEventsInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutEventsInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutEventsInput, HotelUncheckedUpdateWithoutEventsInput>
  }

  export type HotelUpdateWithoutEventsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    rooms?: RoomUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUpdateManyWithoutHotelNestedInput
    policies?: HotelPolicyUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenitiesLinkUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHotelNestedInput
    policies?: HotelPolicyUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenitiesLinkUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type CustomerCreateWithoutNotificationsInput = {
    name?: string | null
    email?: string | null
    phone?: string | null
    bookings?: BookingCreateNestedManyWithoutCustomerInput
    reviews?: ReviewCreateNestedManyWithoutCustomerInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    User?: UserCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutNotificationsInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone?: string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCustomerInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    User?: UserUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutNotificationsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutNotificationsInput, CustomerUncheckedCreateWithoutNotificationsInput>
  }

  export type CustomerUpsertWithoutNotificationsInput = {
    update: XOR<CustomerUpdateWithoutNotificationsInput, CustomerUncheckedUpdateWithoutNotificationsInput>
    create: XOR<CustomerCreateWithoutNotificationsInput, CustomerUncheckedCreateWithoutNotificationsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutNotificationsInput, CustomerUncheckedUpdateWithoutNotificationsInput>
  }

  export type CustomerUpdateWithoutNotificationsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUpdateManyWithoutCustomerNestedInput
    reviews?: ReviewUpdateManyWithoutCustomerNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    User?: UserUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCustomerNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    User?: UserUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type RoomCreateWithoutAmenitiesInput = {
    price?: Decimal | DecimalJsLike | number | string | null
    availability?: boolean | null
    hotel?: HotelCreateNestedOneWithoutRoomsInput
    roomType?: RoomTypeCreateNestedOneWithoutRoomsInput
    bookings?: BookingCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutAmenitiesInput = {
    id?: number
    hotelId?: number | null
    roomTypeId?: number | null
    price?: Decimal | DecimalJsLike | number | string | null
    availability?: boolean | null
    bookings?: BookingUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutAmenitiesInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutAmenitiesInput, RoomUncheckedCreateWithoutAmenitiesInput>
  }

  export type RoomAmenityCreateWithoutRoomsInput = {
    amenityName?: string | null
    description?: string | null
  }

  export type RoomAmenityUncheckedCreateWithoutRoomsInput = {
    id?: number
    amenityName?: string | null
    description?: string | null
  }

  export type RoomAmenityCreateOrConnectWithoutRoomsInput = {
    where: RoomAmenityWhereUniqueInput
    create: XOR<RoomAmenityCreateWithoutRoomsInput, RoomAmenityUncheckedCreateWithoutRoomsInput>
  }

  export type RoomUpsertWithoutAmenitiesInput = {
    update: XOR<RoomUpdateWithoutAmenitiesInput, RoomUncheckedUpdateWithoutAmenitiesInput>
    create: XOR<RoomCreateWithoutAmenitiesInput, RoomUncheckedCreateWithoutAmenitiesInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutAmenitiesInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutAmenitiesInput, RoomUncheckedUpdateWithoutAmenitiesInput>
  }

  export type RoomUpdateWithoutAmenitiesInput = {
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    availability?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hotel?: HotelUpdateOneWithoutRoomsNestedInput
    roomType?: RoomTypeUpdateOneWithoutRoomsNestedInput
    bookings?: BookingUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutAmenitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    availability?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookings?: BookingUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomAmenityUpsertWithoutRoomsInput = {
    update: XOR<RoomAmenityUpdateWithoutRoomsInput, RoomAmenityUncheckedUpdateWithoutRoomsInput>
    create: XOR<RoomAmenityCreateWithoutRoomsInput, RoomAmenityUncheckedCreateWithoutRoomsInput>
    where?: RoomAmenityWhereInput
  }

  export type RoomAmenityUpdateToOneWithWhereWithoutRoomsInput = {
    where?: RoomAmenityWhereInput
    data: XOR<RoomAmenityUpdateWithoutRoomsInput, RoomAmenityUncheckedUpdateWithoutRoomsInput>
  }

  export type RoomAmenityUpdateWithoutRoomsInput = {
    amenityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoomAmenityUncheckedUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelCreateWithoutAmenitiesInput = {
    name?: string | null
    address?: string | null
    city?: string | null
    rating?: number | null
    rooms?: RoomCreateNestedManyWithoutHotelInput
    reviews?: ReviewCreateNestedManyWithoutHotelInput
    policies?: HotelPolicyCreateNestedManyWithoutHotelInput
    events?: HotelEventCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutAmenitiesInput = {
    id?: number
    name?: string | null
    address?: string | null
    city?: string | null
    rating?: number | null
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHotelInput
    policies?: HotelPolicyUncheckedCreateNestedManyWithoutHotelInput
    events?: HotelEventUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutAmenitiesInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutAmenitiesInput, HotelUncheckedCreateWithoutAmenitiesInput>
  }

  export type HotelAmenityCreateWithoutHotelsInput = {
    amenityName?: string | null
    description?: string | null
  }

  export type HotelAmenityUncheckedCreateWithoutHotelsInput = {
    id?: number
    amenityName?: string | null
    description?: string | null
  }

  export type HotelAmenityCreateOrConnectWithoutHotelsInput = {
    where: HotelAmenityWhereUniqueInput
    create: XOR<HotelAmenityCreateWithoutHotelsInput, HotelAmenityUncheckedCreateWithoutHotelsInput>
  }

  export type HotelUpsertWithoutAmenitiesInput = {
    update: XOR<HotelUpdateWithoutAmenitiesInput, HotelUncheckedUpdateWithoutAmenitiesInput>
    create: XOR<HotelCreateWithoutAmenitiesInput, HotelUncheckedCreateWithoutAmenitiesInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutAmenitiesInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutAmenitiesInput, HotelUncheckedUpdateWithoutAmenitiesInput>
  }

  export type HotelUpdateWithoutAmenitiesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    rooms?: RoomUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUpdateManyWithoutHotelNestedInput
    policies?: HotelPolicyUpdateManyWithoutHotelNestedInput
    events?: HotelEventUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutAmenitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHotelNestedInput
    policies?: HotelPolicyUncheckedUpdateManyWithoutHotelNestedInput
    events?: HotelEventUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type HotelAmenityUpsertWithoutHotelsInput = {
    update: XOR<HotelAmenityUpdateWithoutHotelsInput, HotelAmenityUncheckedUpdateWithoutHotelsInput>
    create: XOR<HotelAmenityCreateWithoutHotelsInput, HotelAmenityUncheckedCreateWithoutHotelsInput>
    where?: HotelAmenityWhereInput
  }

  export type HotelAmenityUpdateToOneWithWhereWithoutHotelsInput = {
    where?: HotelAmenityWhereInput
    data: XOR<HotelAmenityUpdateWithoutHotelsInput, HotelAmenityUncheckedUpdateWithoutHotelsInput>
  }

  export type HotelAmenityUpdateWithoutHotelsInput = {
    amenityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelAmenityUncheckedUpdateWithoutHotelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerCreateWithoutUserInput = {
    name?: string | null
    email?: string | null
    phone?: string | null
    bookings?: BookingCreateNestedManyWithoutCustomerInput
    reviews?: ReviewCreateNestedManyWithoutCustomerInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    notifications?: SystemNotificationCreateNestedManyWithoutUserInput
  }

  export type CustomerUncheckedCreateWithoutUserInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone?: string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCustomerInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type CustomerCreateOrConnectWithoutUserInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
  }

  export type CustomerUpsertWithoutUserInput = {
    update: XOR<CustomerUpdateWithoutUserInput, CustomerUncheckedUpdateWithoutUserInput>
    create: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutUserInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutUserInput, CustomerUncheckedUpdateWithoutUserInput>
  }

  export type CustomerUpdateWithoutUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUpdateManyWithoutCustomerNestedInput
    reviews?: ReviewUpdateManyWithoutCustomerNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    notifications?: SystemNotificationUpdateManyWithoutUserNestedInput
  }

  export type CustomerUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCustomerNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookingCreateManyCustomerInput = {
    id?: number
    roomId?: number | null
    statusId?: number | null
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type ReviewCreateManyCustomerInput = {
    id?: number
    hotelId?: number | null
    rating?: number | null
    comments?: string | null
    reviewDate?: Date | string | null
  }

  export type ActivityLogCreateManyUserInput = {
    id?: number
    action?: string | null
    logDate?: Date | string | null
  }

  export type SystemNotificationCreateManyUserInput = {
    id?: number
    message?: string | null
    notificationDate?: Date | string | null
  }

  export type UserCreateManyCustomerInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateWithoutCustomerInput = {
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    room?: RoomUpdateOneWithoutBookingsNestedInput
    status?: BookingStatusUpdateOneWithoutBookingsNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    promotions?: PromotionAppliedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    promotions?: PromotionAppliedUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ReviewUpdateWithoutCustomerInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotel?: HotelUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityLogUpdateWithoutUserInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemNotificationUpdateWithoutUserInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null
    notificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemNotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    notificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemNotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    notificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpdateWithoutCustomerInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateManyHotelInput = {
    id?: number
    roomTypeId?: number | null
    price?: Decimal | DecimalJsLike | number | string | null
    availability?: boolean | null
  }

  export type ReviewCreateManyHotelInput = {
    id?: number
    customerId?: number | null
    rating?: number | null
    comments?: string | null
    reviewDate?: Date | string | null
  }

  export type HotelPolicyCreateManyHotelInput = {
    id?: number
    policyDescription?: string | null
  }

  export type HotelEventCreateManyHotelInput = {
    id?: number
    eventName?: string | null
    eventDate?: Date | string | null
    description?: string | null
  }

  export type HotelAmenitiesLinkCreateManyHotelInput = {
    id?: number
    amenityId?: number | null
  }

  export type RoomUpdateWithoutHotelInput = {
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    availability?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roomType?: RoomTypeUpdateOneWithoutRoomsNestedInput
    bookings?: BookingUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenitiesLinkUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    availability?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookings?: BookingUncheckedUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenitiesLinkUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    availability?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ReviewUpdateWithoutHotelInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HotelPolicyUpdateWithoutHotelInput = {
    policyDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelPolicyUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    policyDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelPolicyUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    policyDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelEventUpdateWithoutHotelInput = {
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelEventUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelEventUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelAmenitiesLinkUpdateWithoutHotelInput = {
    amenity?: HotelAmenityUpdateOneWithoutHotelsNestedInput
  }

  export type HotelAmenitiesLinkUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotelAmenitiesLinkUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomCreateManyRoomTypeInput = {
    id?: number
    hotelId?: number | null
    price?: Decimal | DecimalJsLike | number | string | null
    availability?: boolean | null
  }

  export type RoomUpdateWithoutRoomTypeInput = {
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    availability?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hotel?: HotelUpdateOneWithoutRoomsNestedInput
    bookings?: BookingUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenitiesLinkUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutRoomTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    availability?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bookings?: BookingUncheckedUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenitiesLinkUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutRoomTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    availability?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BookingCreateManyRoomInput = {
    id?: number
    customerId?: number | null
    statusId?: number | null
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type RoomAmenitiesLinkCreateManyRoomInput = {
    id?: number
    amenityId?: number | null
  }

  export type BookingUpdateWithoutRoomInput = {
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customer?: CustomerUpdateOneWithoutBookingsNestedInput
    status?: BookingStatusUpdateOneWithoutBookingsNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    promotions?: PromotionAppliedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    promotions?: PromotionAppliedUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    statusId?: NullableIntFieldUpdateOperationsInput | number | null
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type RoomAmenitiesLinkUpdateWithoutRoomInput = {
    amenity?: RoomAmenityUpdateOneWithoutRoomsNestedInput
  }

  export type RoomAmenitiesLinkUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomAmenitiesLinkUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BookingCreateManyStatusInput = {
    id?: number
    customerId?: number | null
    roomId?: number | null
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type BookingUpdateWithoutStatusInput = {
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customer?: CustomerUpdateOneWithoutBookingsNestedInput
    room?: RoomUpdateOneWithoutBookingsNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    promotions?: PromotionAppliedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    promotions?: PromotionAppliedUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type BookingServiceCreateManyBookingInput = {
    id?: number
    serviceId?: number | null
    quantity?: number | null
  }

  export type PaymentCreateManyBookingInput = {
    id?: number
    amount?: Decimal | DecimalJsLike | number | string | null
    paymentDate?: Date | string | null
    paymentMethod?: string | null
  }

  export type PromotionAppliedCreateManyBookingInput = {
    id?: number
    promotionId: number
  }

  export type BookingServiceUpdateWithoutBookingInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    service?: ServiceUpdateOneWithoutBookingsNestedInput
  }

  export type BookingServiceUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BookingServiceUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentUpdateWithoutBookingInput = {
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromotionAppliedUpdateWithoutBookingInput = {
    promotion?: PromotionUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type PromotionAppliedUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotionId?: IntFieldUpdateOperationsInput | number
  }

  export type PromotionAppliedUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotionId?: IntFieldUpdateOperationsInput | number
  }

  export type BookingServiceCreateManyServiceInput = {
    id?: number
    bookingId: number
    quantity?: number | null
  }

  export type BookingServiceUpdateWithoutServiceInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    booking?: BookingUpdateOneRequiredWithoutServicesNestedInput
  }

  export type BookingServiceUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BookingServiceUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeCreateManyRoleInput = {
    id?: number
    departmentId?: number | null
    name?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
  }

  export type EmployeeUpdateWithoutRoleInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EmployeeUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EmployeeCreateManyDepartmentInput = {
    id?: number
    roleId?: number | null
    name?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
  }

  export type EmployeeUpdateWithoutDepartmentInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    role?: EmployeeRoleUpdateOneWithoutEmployeesNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EmployeeUncheckedUpdateManyWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PromotionAppliedCreateManyPromotionInput = {
    id?: number
    bookingId?: number | null
  }

  export type PromotionAppliedUpdateWithoutPromotionInput = {
    booking?: BookingUpdateOneWithoutPromotionsNestedInput
  }

  export type PromotionAppliedUncheckedUpdateWithoutPromotionInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PromotionAppliedUncheckedUpdateManyWithoutPromotionInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomAmenitiesLinkCreateManyAmenityInput = {
    id?: number
    roomId: number
  }

  export type RoomAmenitiesLinkUpdateWithoutAmenityInput = {
    room?: RoomUpdateOneRequiredWithoutAmenitiesNestedInput
  }

  export type RoomAmenitiesLinkUncheckedUpdateWithoutAmenityInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
  }

  export type RoomAmenitiesLinkUncheckedUpdateManyWithoutAmenityInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
  }

  export type HotelAmenitiesLinkCreateManyAmenityInput = {
    id?: number
    hotelId: number
  }

  export type HotelAmenitiesLinkUpdateWithoutAmenityInput = {
    hotel?: HotelUpdateOneRequiredWithoutAmenitiesNestedInput
  }

  export type HotelAmenitiesLinkUncheckedUpdateWithoutAmenityInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
  }

  export type HotelAmenitiesLinkUncheckedUpdateManyWithoutAmenityInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}